/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import { util } from '@tensorflow/tfjs-core';
import { activationFnSnippet, biasActivationSnippet, typeSnippet } from './activation_util';
import { getMainHeaderString as main } from './webgpu_program';
import { computeDispatch, computeWorkGroupInfoForMatMul } from './webgpu_util';
export function matMulReadFnSource(batchAEqualOne, batchBEqualOne, transposeA, transposeB, fitAOuter = false, fitBOuter = false, fitInner = false, component = 1) {
    util.assert(transposeA && component === 1 || !transposeA, () => `transposeA ${transposeA} is not compatible with component size ${component}`);
    const sampleA = `
      let batch = ${batchAEqualOne ? '0' : 'batchIn'};
      ${transposeA ? `value = getA(batch, col, row);` :
        `value = getA(batch, row, col);`}

    `;
    const sampleB = transposeB ? `value = getB(batch, col, row);` :
        `value = getB(batch, row, col);`;
    return `
  fn mm_readA(batchIn: i32, row: i32, colIn: i32) -> ${typeSnippet(component)} {
    var value = ${typeSnippet(component)}(0.0);
    let col = colIn * ${component};
    ${fitAOuter && fitInner ?
        sampleA :
        `
    ${transposeA ?
            `if(row < uniforms.dimAOuter && col < uniforms.dimInner)` :
            `if(row < uniforms.aShape[1] && col < uniforms.aShape[2])`}
    {
      ${sampleA}
    }
    `}
    return value;
  }

  fn mm_readB(batchIn: i32, row: i32, colIn: i32) -> ${typeSnippet(component)} {
    let col = colIn * ${component};
    let batch = ${batchBEqualOne ? '0' : 'batchIn'};
    var value = ${typeSnippet(component)}(0.0);
    ${sampleB}
    return value;
  }
  `;
}
export function matMulReadWriteFnSource(hasBias, activation, batchAEqualOne, batchBEqualOne, transposeA, transposeB, fitAOuter = false, fitBOuter = false, fitInner = false, component = 1) {
    return `
  ${matMulReadFnSource(batchAEqualOne, batchBEqualOne, transposeA, transposeB, fitAOuter, fitBOuter, fitInner, component)}
  fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${typeSnippet(component)}) {
    let col = colIn * ${component};
    ${fitAOuter && fitBOuter ?
        '' :
        'if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)'}
    {
      var value = valueIn;
      let coords = vec3<i32>(batch, row, col);
      ${biasActivationSnippet(hasBias, activation)}
      setOutputAtCoords(coords[0], coords[1], coords[2], value);
    }
  }
  `;
}
const writeDataToSubAVec4Snippet = (transpose) => {
    if (transpose) {
        return `
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart / InnerElementSize + inputCol);
        `;
    }
    else {
        return `
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRow + innerRow,
          kStart / InnerElementSize + inputCol);
        `;
    }
};
const calculateResultSnippet = (transposeA, innerElementSize) => {
    if (transposeA) {
        return `
        let ACached0 = mm_Asub[k * InnerElementSize][localRow];
        let ACached1 = mm_Asub[k * InnerElementSize + 1][localRow];
        let ACached2 = mm_Asub[k * InnerElementSize + 2][localRow];
        ${innerElementSize === 3 ?
            '' :
            'let ACached3 = mm_Asub[k * InnerElementSize + 3][localRow];'}
        for (var i = 0; i < RowPerThread; i = i + 1) {
          acc[i] = BCached0 * ACached0[i] + acc[i];
          acc[i] = BCached1 * ACached1[i] + acc[i];
          acc[i] = BCached2 * ACached2[i] + acc[i];
          ${innerElementSize === 3 ?
            '' :
            'acc[i] = BCached3 * ACached3[i] + acc[i];'}
        }`;
    }
    else {
        return `
        for (var i = 0; i < RowPerThread; i = i + 1) {
          let ACached = mm_Asub[tileRow + i][k];
          acc[i] = BCached0 * ACached.x + acc[i];
          acc[i] = BCached1 * ACached.y + acc[i];
          acc[i] = BCached2 * ACached.z + acc[i];
          ${innerElementSize === 3 ? '' :
            'acc[i] = BCached3 * ACached.w + acc[i];'}
        }`;
    }
};
export function makeMatMulPackedVec4Source(workPerThread, workGroupSize, transposeA = false, tileInner = 32, splitK = false, splitedDimInner = 32, isVectorA = false) {
    const tileAOuter = workGroupSize[1] * workPerThread[1];
    const tileBOuter = workGroupSize[0] * workPerThread[0];
    const tileAWidth = transposeA ? tileAOuter : tileInner;
    const tileAHight = transposeA ? tileInner : tileAOuter;
    const innerElementSize = tileAWidth / workGroupSize[0];
    const rowPerThreadB = tileInner / workGroupSize[1];
    util.assert(((transposeA && innerElementSize === 4 && workPerThread[1] === 4) ||
        (!transposeA && (innerElementSize === 3 || innerElementSize === 4))) &&
        tileAWidth % workGroupSize[0] === 0 &&
        tileInner % workGroupSize[1] === 0 && workPerThread[0] === 4, () => `If transposeA ${transposeA} is true, innerElementSize ${innerElementSize} and workPerThread[1] ${workPerThread[1]} must be 4.
          Otherwise, innerElementSize ${innerElementSize} must be 3 or 4.
      tileAWidth ${tileAWidth} must be divisible by workGroupSize[0]${workGroupSize[0]}. tileInner ${tileInner} must be divisible by workGroupSize[1] ${workGroupSize[1]}. ColPerThread ${workPerThread[0]} must be 4.`);
    return `
  var<workgroup> mm_Asub : array<array<vec${innerElementSize}<f32>, ${tileAWidth / innerElementSize}>, ${tileAHight}>;
  var<workgroup> mm_Bsub : array<array<vec4<f32>, ${tileBOuter / workPerThread[0]}>, ${tileInner}>;

  const RowPerThread = ${workPerThread[1]};
  const ColPerThread = ${workPerThread[0]};
  const InnerElementSize = ${innerElementSize};
  const TileInner = ${tileInner};

  @compute @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)
  fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,
            @builtin(global_invocation_id) GlobalId : vec3<u32>,
            @builtin(num_workgroups) NumWorkgroups: vec3<u32>,
            @builtin(workgroup_id) workgroupId: vec3<u32>) {
    localId = LocalId;
    globalId = GlobalId;
    numWorkgroups = NumWorkgroups;

    let localRow = i32(localId.y);
    let tileRow = ${isVectorA ? '0' : 'localRow * RowPerThread'};
    let tileCol = i32(localId.x);

    let globalRow = ${isVectorA ? '0' : 'i32(globalId.y) * RowPerThread'};
    let globalCol = i32(globalId.x);
    let batch = ${splitK ? '0' : 'i32(globalId.z)'};
    let globalRowStart = i32(workgroupId.y) * ${tileAOuter};

    let numTiles = ${splitK ? `${Math.ceil(splitedDimInner / tileInner)}` :
        '(uniforms.dimInner - 1) / TileInner + 1'};
    var kStart = ${splitK ? `i32(globalId.z) * ${splitedDimInner}` : '0'};

    var acc: array<vec4<f32>, RowPerThread>;

    // Loop over shared dimension.
    let tileRowB = localRow * ${rowPerThreadB};
    for (var t = 0; t < numTiles; t = t + 1) {
        // Load one tile of A into local memory.
        for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {
            let inputRow = tileRow + innerRow;
            let inputCol = tileCol;
            ${writeDataToSubAVec4Snippet(transposeA)}
        }

        // Load one tile of B into local memory.
        for (var innerRow = 0; innerRow < ${rowPerThreadB}; innerRow = innerRow + 1) {
            let inputRow = tileRowB + innerRow;
            let inputCol = tileCol;
            mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol);
        }
        kStart = kStart + TileInner;
        workgroupBarrier();

        // Compute acc values for a single thread.
        for (var k = 0; k < TileInner / InnerElementSize; k = k + 1) {
            let BCached0 = mm_Bsub[k * InnerElementSize][tileCol];
            let BCached1 = mm_Bsub[k * InnerElementSize + 1][tileCol];
            let BCached2 = mm_Bsub[k * InnerElementSize + 2][tileCol];
            ${innerElementSize === 3 ?
        '' :
        'let BCached3 = mm_Bsub[k * InnerElementSize + 3][tileCol];'}

            ${calculateResultSnippet(transposeA, innerElementSize)}
        }

        workgroupBarrier();
    }

    for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {
        mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
    }
  }`;
}
const writeDataToSubASnippet = (transpose) => {
    if (transpose) {
        return `
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart + inputCol);
        `;
    }
    else {
        return `
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRowStart + inputRow,
          kStart + inputCol);
        `;
    }
};
const readDataFromSubASnippet = (transposeA) => {
    return transposeA ? 'let ACached = mm_Asub[k][tileRow + innerRow];' :
        'let ACached = mm_Asub[tileRow + innerRow][k];';
};
// sequentialAccessByThreads means sequential data in memory is accessed by
// threads, instead of a single thread (default behavior).
export function makeMatMulPackedSource(workPerThread, workGroupSize, transposeA = false, tileInner = 32, splitK = false, splitedDimInner = 32, sequentialAccessByThreads = false) {
    const tileAOuter = workPerThread[1] * workGroupSize[1];
    const tileBOuter = workPerThread[0] * workGroupSize[0];
    const tileAWidth = transposeA ? tileAOuter : tileInner;
    const tileAHight = transposeA ? tileInner : tileAOuter;
    util.assert(tileAHight % workGroupSize[1] === 0 &&
        tileAWidth % workGroupSize[0] === 0 &&
        tileInner % workGroupSize[1] === 0, () => `tileAHight ${tileAHight} must be divisible by workGroupSize[1]${workGroupSize[1]}, tileAWidth ${tileAWidth} must be divisible by workGroupSize[0]${workGroupSize[0]}, tileInner ${tileInner} must be divisible by workGroupSize[1]${workGroupSize[1]}`);
    const rowPerThreadA = tileAHight / workGroupSize[1];
    const colPerThreadA = tileAWidth / workGroupSize[0];
    const rowPerThreadB = tileInner / workGroupSize[1];
    const matmulSnippet = sequentialAccessByThreads ?
        `
      let localRow = i32(localId.y);
      let localCol = i32(localId.x);
      let globalRowStart = i32(workgroupId.y) * ${tileAOuter};
      let globalColStart = i32(workgroupId.x) * ${tileBOuter};

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t = t + 1) {
        // Load one tile of A into local memory.
        for (var inputRow = localRow; inputRow < ${tileAHight}; inputRow = inputRow + ${workGroupSize[1]}) {
          for (var inputCol = localCol; inputCol < ${tileAWidth}; inputCol = inputCol + ${workGroupSize[0]}) {
            ${writeDataToSubASnippet(transposeA)}
          }
        }
        // Load one tile of B into local memory.
        for (var inputRow = localRow; inputRow < ${tileInner}; inputRow = inputRow + ${workGroupSize[1]}) {
              for (var inputCol = localCol; inputCol < ${tileBOuter}; inputCol = inputCol + ${workGroupSize[0]}) {
            mm_Bsub[inputRow][inputCol] = mm_readB(batch,
              kStart + inputRow,
              globalColStart + inputCol);
          }
        }
        kStart = kStart + TileInner;
        workgroupBarrier();

        // Compute acc values for a single thread.
        var BCached : array<f32, ColPerThread>;
        for (var k = 0; k < TileInner; k = k + 1) {
          for (var inner = 0; inner < ColPerThread; inner = inner + 1) {
            BCached[inner] = mm_Bsub[k][localCol + inner * ${workGroupSize[0]}];
          }
          for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {
            let ACached = ${transposeA ?
            `mm_Asub[k][localRow + innerRow * ${workGroupSize[1]}];` :
            `mm_Asub[localRow + innerRow * ${workGroupSize[1]}][k];`}
            for (var innerCol = 0; innerCol < ColPerThread; innerCol = innerCol + 1) {
              acc[innerRow][innerCol] = acc[innerRow][innerCol] +
                  ACached * BCached[innerCol];
            }
          }
        }
        workgroupBarrier();
      }
      for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {
        let gRow = globalRowStart + localRow + innerRow * ${workGroupSize[1]};
        for (var innerCol = 0; innerCol < ColPerThread; innerCol = innerCol + 1) {
          let gCol = globalColStart + localCol + innerCol * ${workGroupSize[0]};
          mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
        }
      }
      ` :
        `
  let tileRow = i32(localId.y) * RowPerThread;
  let tileCol = i32(localId.x) * ColPerThread;

  let globalRow = i32(globalId.y) * RowPerThread;
  let globalCol = i32(globalId.x) * ColPerThread;
  let globalRowStart = i32(workgroupId.y) * ${tileAOuter};

  let tileRowA = i32(localId.y) * ${rowPerThreadA};
  let tileColA = i32(localId.x) * ${colPerThreadA};
  let tileRowB = i32(localId.y) * ${rowPerThreadB};
  // Loop over shared dimension.
  for (var t = 0; t < numTiles; t = t + 1) {
    // Load one tile of A into local memory.
    for (var innerRow = 0; innerRow < ${rowPerThreadA}; innerRow = innerRow + 1) {
      for (var innerCol = 0; innerCol < ${colPerThreadA}; innerCol = innerCol + 1) {
        let inputRow = tileRowA + innerRow;
        let inputCol = tileColA + innerCol;
        ${writeDataToSubASnippet(transposeA)}
      }
    }

    // Load one tile of B into local memory.
    for (var innerRow = 0; innerRow < ${rowPerThreadB}; innerRow = innerRow + 1) {
      for (var innerCol = 0; innerCol < ColPerThread; innerCol = innerCol + 1) {
        let inputRow = tileRowB + innerRow;
        let inputCol = tileCol + innerCol;
        mm_Bsub[inputRow][inputCol] = mm_readB(batch,
          kStart + inputRow,
          globalCol + innerCol);
      }
    }
    kStart = kStart + TileInner;
    workgroupBarrier();

    // Compute acc values for a single thread.
    var BCached : array<f32, ColPerThread>;
    for (var k = 0; k < TileInner; k = k + 1) {
      for (var inner = 0; inner < ColPerThread; inner = inner + 1) {
        BCached[inner] = mm_Bsub[k][tileCol + inner];
      }

      for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {
        ${readDataFromSubASnippet(transposeA)}
        for (var innerCol = 0; innerCol < ColPerThread; innerCol = innerCol + 1) {
          acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
        }
      }
    }

    workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < ColPerThread; innerCol = innerCol + 1) {
      mm_write(batch, globalRow + innerRow, globalCol + innerCol,
          acc[innerRow][innerCol]);
    }
  }
  `;
    return `
    var<workgroup> mm_Asub : array<array<f32, ${tileAWidth}>, ${tileAHight}>;
    var<workgroup> mm_Bsub : array<array<f32, ${tileBOuter}>, ${tileInner}>;
    const RowPerThread = ${workPerThread[1]};
    const ColPerThread = ${workPerThread[0]};
    const TileInner = ${tileInner};

    @compute @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)
    fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,
              @builtin(global_invocation_id) GlobalId : vec3<u32>,
              @builtin(num_workgroups) NumWorkgroups: vec3<u32>,
              @builtin(workgroup_id) workgroupId: vec3<u32>) {
      localId = LocalId;
      globalId = GlobalId;
      numWorkgroups = NumWorkgroups;

      let batch = ${splitK ? '0' : 'i32(globalId.z)'};
      let numTiles = ${splitK ? `${Math.ceil(splitedDimInner / tileInner)}` :
        '(uniforms.dimInner - 1) / TileInner + 1'};
      var kStart = ${splitK ? `i32(globalId.z) * ${splitedDimInner}` : '0'};

      var acc : array<array<f32, ColPerThread>, RowPerThread>;

      // Without this initialization strange values show up in acc.
      for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {
        for (var innerCol = 0; innerCol < ColPerThread; innerCol = innerCol + 1) {
          acc[innerRow][innerCol] = 0.0;
        }
      }
      ${matmulSnippet}
    }
  `;
}
const readVectorASnippet = (transpose) => {
    return transpose ? `
      mm_readA(batch, colA, globalRow),
      mm_readA(batch, colA + 1, globalRow),
      mm_readA(batch, colA + 2, globalRow),
      mm_readA(batch, colA + 3, globalRow)
  ` :
        `
      mm_readA(batch, globalRow, colA),
      mm_readA(batch, globalRow, colA + 1),
      mm_readA(batch, globalRow, colA + 2),
      mm_readA(batch, globalRow, colA + 3)
  `;
};
export function makeVectorMatrixProductSource(workGroupSize, transposeA = false) {
    util.assert(workGroupSize[1] === 1 && workGroupSize[2] === 1, () => `A linear work group size is required. But got ${workGroupSize}.`);
    return `
    const TileSize = ${workGroupSize[0] * 4};
    var<workgroup> mm_Asub : array<vec4<f32>, ${workGroupSize[0]}>;

    ${main()} {
      let tileCol = i32(localId.x);
      let globalCol = i32(globalId.x);
      let globalRow = i32(globalId.y);

      let numTiles = (uniforms.dimInner - 1) / TileSize + 1;
      let batch = i32(globalId.z);
      // Without this initialization strange values show up in acc.
      var acc = 0.0;

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t = t + 1) {
        // Load one tile of A into local memory.
        let colA = t * TileSize + tileCol * 4;
        mm_Asub[tileCol] = vec4<f32>(${readVectorASnippet(transposeA)});
        workgroupBarrier();

        // Compute acc values for a single thread.
        for (var k = 0; k < TileSize / 4; k = k + 1) {
          let rowB = t * TileSize + k * 4;
          let BCached = vec4<f32>(mm_readB(batch, rowB, globalCol),
                              mm_readB(batch, rowB + 1, globalCol),
                              mm_readB(batch, rowB + 2, globalCol),
                              mm_readB(batch, rowB + 3, globalCol));

          let ACached = mm_Asub[k];
          acc = acc + dot(ACached, BCached);
        }

        workgroupBarrier();
      }

      mm_write(batch, globalRow, globalCol, acc);
    }
  `;
}
export class MatMulPackedProgram {
    constructor(aShape, outputShape, batchAEqualOne, batchBEqualOne, transposeA = false, transposeB = false, bias = null, activation = null, preluActivationWeights = null, sequentialAccessByThreads = false) {
        this.variableNames = ['A', 'B'];
        this.uniforms = `dimAOuter : i32, dimBOuter : i32, dimInner : i32,`;
        this.outputShape = outputShape;
        this.dispatchLayout = { x: [2], y: [1], z: [0] };
        const dimInner = transposeA ? aShape[1] : aShape[2];
        this.isVec4 = ((dimInner % 4 === 0 && !transposeA) ||
            (outputShape[1] % 4 === 0 && transposeA)) &&
            outputShape[2] % 4 === 0 && !transposeB;
        this.isVectorA = outputShape[1] === 1 && !transposeA;
        if (!this.isVec4 && this.isVectorA) {
            // For makeVectorMatrixProductSource
            this.elementsPerThread = [1, 1, 1];
            this.workGroupSize = [32, 1, 1];
        }
        else {
            const workGroupInfo = computeWorkGroupInfoForMatMul(outputShape[1], dimInner, outputShape[2], transposeA);
            this.workGroupSize = workGroupInfo.workGroupSize;
            this.elementsPerThread = workGroupInfo.elementsPerThread;
        }
        this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workGroupSize, this.elementsPerThread);
        const addBias = bias != null;
        const hasPreluActivationWeights = preluActivationWeights != null;
        if (addBias) {
            this.variableNames.push('bias');
        }
        if (hasPreluActivationWeights) {
            this.variableNames.push('preluActivationWeights');
        }
        this.sequentialAccessByThreads = sequentialAccessByThreads;
        this.transposeA = transposeA;
        this.transposeB = transposeB;
        this.addBias = addBias;
        this.activation = activation;
        this.hasPreluActivationWeights = hasPreluActivationWeights;
        this.batchAEqualOne = batchAEqualOne;
        this.batchBEqualOne = batchBEqualOne;
        [this.fitAOuter, this.fitBOuter, this.fitInner] =
            this.getShapeFit(outputShape[1], outputShape[2], dimInner);
        this.shaderKey = `matMulPacked_${this.elementsPerThread}_${transposeA}_${transposeB}_${this.activation}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.isVectorA}_${this.batchAEqualOne}_${this.batchBEqualOne}_${this.sequentialAccessByThreads}`;
    }
    getShapeFit(dimAOuter, dimBOuter, dimInner) {
        const tileAOuter = this.workGroupSize[1] * this.elementsPerThread[1];
        const tileBOuter = this.workGroupSize[0] * this.elementsPerThread[0];
        if (!this.isVec4 && this.isVectorA) {
            // For makeVectorMatrixProductSource
            this.tileInner = this.workGroupSize[0] * 4;
        }
        else {
            this.tileInner = tileBOuter;
        }
        const fitAOuter = dimAOuter % tileAOuter === 0;
        const fitBOuter = dimBOuter % tileBOuter === 0;
        const fitInner = dimInner % this.tileInner === 0;
        return [fitAOuter, fitBOuter, fitInner];
    }
    getUserCode() {
        const userCode = `
      ${activationFnSnippet(this.activation, this.hasPreluActivationWeights, this.isVec4)}
      ${matMulReadWriteFnSource(this.addBias, this.activation, this.batchAEqualOne, this.batchBEqualOne, false /* transposeA is implemented in makeMatMulPackedSource */, this.transposeB, this.fitAOuter, this.fitBOuter, this.fitInner, this.isVec4 ? 4 : 1)}
      ${this.isVec4 ?
            makeMatMulPackedVec4Source(this.elementsPerThread, this.workGroupSize, this.transposeA, this.tileInner, false, null, this.isVectorA) :
            (this.isVectorA ? makeVectorMatrixProductSource(this.workGroupSize, this.transposeA) :
                makeMatMulPackedSource(this.elementsPerThread, this.workGroupSize, this.transposeA, this.tileInner, false, null, this.sequentialAccessByThreads))}
    `;
        return userCode;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWF0bXVsX3BhY2tlZF93ZWJncHUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi90ZmpzLWJhY2tlbmQtd2ViZ3B1L3NyYy9tYXRtdWxfcGFja2VkX3dlYmdwdS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFFSCxPQUFPLEVBQTJCLElBQUksRUFBQyxNQUFNLHVCQUF1QixDQUFDO0FBQ3JFLE9BQU8sRUFBQyxtQkFBbUIsRUFBRSxxQkFBcUIsRUFBRSxXQUFXLEVBQUMsTUFBTSxtQkFBbUIsQ0FBQztBQUMxRixPQUFPLEVBQUMsbUJBQW1CLElBQUksSUFBSSxFQUFnQixNQUFNLGtCQUFrQixDQUFDO0FBQzVFLE9BQU8sRUFBQyxlQUFlLEVBQUUsNkJBQTZCLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFFN0UsTUFBTSxVQUFVLGtCQUFrQixDQUM5QixjQUF1QixFQUFFLGNBQXVCLEVBQUUsVUFBbUIsRUFDckUsVUFBbUIsRUFBRSxTQUFTLEdBQUcsS0FBSyxFQUFFLFNBQVMsR0FBRyxLQUFLLEVBQUUsUUFBUSxHQUFHLEtBQUssRUFDM0UsU0FBUyxHQUFHLENBQUM7SUFDZixJQUFJLENBQUMsTUFBTSxDQUNQLFVBQVUsSUFBSSxTQUFTLEtBQUssQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUM1QyxHQUFHLEVBQUUsQ0FBQyxjQUFjLFVBQVUsMENBQzFCLFNBQVMsRUFBRSxDQUFDLENBQUM7SUFDckIsTUFBTSxPQUFPLEdBQUc7b0JBQ0UsY0FBYyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLFNBQVM7UUFFOUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxnQ0FBZ0MsQ0FBQyxDQUFDO1FBQ2xDLGdDQUFnQzs7S0FFOUMsQ0FBQztJQUNKLE1BQU0sT0FBTyxHQUFHLFVBQVUsQ0FBQyxDQUFDLENBQUMsZ0NBQWdDLENBQUMsQ0FBQztRQUNsQyxnQ0FBZ0MsQ0FBQztJQUU5RCxP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QUNuQixJQUFJLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLGNBQWMsRUFDbEQsSUFBSSxDQUFDLGNBQWMsRUFDbkIsS0FBSyxDQUFDLHlEQUF5RCxFQUMvRCxJQUFJLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsUUFBUSxFQUM5RCxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUV4QixJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDVCwwQkFBMEIsQ0FDdEIsSUFBSSxDQUFDLGlCQUFpQixFQUFFLElBQUksQ0FBQyxhQUFhLEVBQUUsSUFBSSxDQUFDLFVBQVUsRUFDM0QsSUFBSSxDQUFDLFNBQVMsRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO1lBQ2xELENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsNkJBQTZCLENBQ3pCLElBQUksQ0FBQyxhQUFhLEVBQUUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUM7Z0JBQzFDLHNCQUFzQixDQUNsQixJQUFJLENBQUMsaUJBQWlCLEVBQUUsSUFBSSxDQUFDLGFBQWEsRUFDMUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsU0FBUyxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQzVDLElBQUksQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDO0tBQzdELENBQUM7UUFDRixPQUFPLFFBQVEsQ0FBQztJQUNsQixDQUFDO0NBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmltcG9ydCB7YmFja2VuZF91dGlsLCBUZW5zb3JJbmZvLCB1dGlsfSBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xuaW1wb3J0IHthY3RpdmF0aW9uRm5TbmlwcGV0LCBiaWFzQWN0aXZhdGlvblNuaXBwZXQsIHR5cGVTbmlwcGV0fSBmcm9tICcuL2FjdGl2YXRpb25fdXRpbCc7XG5pbXBvcnQge2dldE1haW5IZWFkZXJTdHJpbmcgYXMgbWFpbiwgV2ViR1BVUHJvZ3JhbX0gZnJvbSAnLi93ZWJncHVfcHJvZ3JhbSc7XG5pbXBvcnQge2NvbXB1dGVEaXNwYXRjaCwgY29tcHV0ZVdvcmtHcm91cEluZm9Gb3JNYXRNdWx9IGZyb20gJy4vd2ViZ3B1X3V0aWwnO1xuXG5leHBvcnQgZnVuY3Rpb24gbWF0TXVsUmVhZEZuU291cmNlKFxuICAgIGJhdGNoQUVxdWFsT25lOiBib29sZWFuLCBiYXRjaEJFcXVhbE9uZTogYm9vbGVhbiwgdHJhbnNwb3NlQTogYm9vbGVhbixcbiAgICB0cmFuc3Bvc2VCOiBib29sZWFuLCBmaXRBT3V0ZXIgPSBmYWxzZSwgZml0Qk91dGVyID0gZmFsc2UsIGZpdElubmVyID0gZmFsc2UsXG4gICAgY29tcG9uZW50ID0gMSkge1xuICB1dGlsLmFzc2VydChcbiAgICAgIHRyYW5zcG9zZUEgJiYgY29tcG9uZW50ID09PSAxIHx8ICF0cmFuc3Bvc2VBLFxuICAgICAgKCkgPT4gYHRyYW5zcG9zZUEgJHt0cmFuc3Bvc2VBfSBpcyBub3QgY29tcGF0aWJsZSB3aXRoIGNvbXBvbmVudCBzaXplICR7XG4gICAgICAgICAgY29tcG9uZW50fWApO1xuICBjb25zdCBzYW1wbGVBID0gYFxuICAgICAgbGV0IGJhdGNoID0gJHtiYXRjaEFFcXVhbE9uZSA/ICcwJyA6ICdiYXRjaEluJ307XG4gICAgICAke1xuICAgICAgdHJhbnNwb3NlQSA/IGB2YWx1ZSA9IGdldEEoYmF0Y2gsIGNvbCwgcm93KTtgIDpcbiAgICAgICAgICAgICAgICAgICBgdmFsdWUgPSBnZXRBKGJhdGNoLCByb3csIGNvbCk7YH1cblxuICAgIGA7XG4gIGNvbnN0IHNhbXBsZUIgPSB0cmFuc3Bvc2VCID8gYHZhbHVlID0gZ2V0QihiYXRjaCwgY29sLCByb3cpO2AgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGB2YWx1ZSA9IGdldEIoYmF0Y2gsIHJvdywgY29sKTtgO1xuXG4gIHJldHVybiBgXG4gIGZuIG1tX3JlYWRBKGJhdGNoSW46IGkzMiwgcm93OiBpMzIsIGNvbEluOiBpMzIpIC0+ICR7dHlwZVNuaXBwZXQoY29tcG9uZW50KX0ge1xuICAgIHZhciB2YWx1ZSA9ICR7dHlwZVNuaXBwZXQoY29tcG9uZW50KX0oMC4wKTtcbiAgICBsZXQgY29sID0gY29sSW4gKiAke2NvbXBvbmVudH07XG4gICAgJHtcbiAgICAgIGZpdEFPdXRlciAmJiBmaXRJbm5lciA/XG4gICAgICAgICAgc2FtcGxlQSA6XG4gICAgICAgICAgYFxuICAgICR7XG4gICAgICAgICAgICAgIHRyYW5zcG9zZUEgP1xuICAgICAgICAgICAgICAgICAgYGlmKHJvdyA8IHVuaWZvcm1zLmRpbUFPdXRlciAmJiBjb2wgPCB1bmlmb3Jtcy5kaW1Jbm5lcilgIDpcbiAgICAgICAgICAgICAgICAgIGBpZihyb3cgPCB1bmlmb3Jtcy5hU2hhcGVbMV0gJiYgY29sIDwgdW5pZm9ybXMuYVNoYXBlWzJdKWB9XG4gICAge1xuICAgICAgJHtzYW1wbGVBfVxuICAgIH1cbiAgICBgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGZuIG1tX3JlYWRCKGJhdGNoSW46IGkzMiwgcm93OiBpMzIsIGNvbEluOiBpMzIpIC0+ICR7dHlwZVNuaXBwZXQoY29tcG9uZW50KX0ge1xuICAgIGxldCBjb2wgPSBjb2xJbiAqICR7Y29tcG9uZW50fTtcbiAgICBsZXQgYmF0Y2ggPSAke2JhdGNoQkVxdWFsT25lID8gJzAnIDogJ2JhdGNoSW4nfTtcbiAgICB2YXIgdmFsdWUgPSAke3R5cGVTbmlwcGV0KGNvbXBvbmVudCl9KDAuMCk7XG4gICAgJHtzYW1wbGVCfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBgO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWF0TXVsUmVhZFdyaXRlRm5Tb3VyY2UoXG4gICAgaGFzQmlhczogYm9vbGVhbiwgYWN0aXZhdGlvbjogYmFja2VuZF91dGlsLkFjdGl2YXRpb24sXG4gICAgYmF0Y2hBRXF1YWxPbmU6IGJvb2xlYW4sIGJhdGNoQkVxdWFsT25lOiBib29sZWFuLCB0cmFuc3Bvc2VBOiBib29sZWFuLFxuICAgIHRyYW5zcG9zZUI6IGJvb2xlYW4sIGZpdEFPdXRlciA9IGZhbHNlLCBmaXRCT3V0ZXIgPSBmYWxzZSwgZml0SW5uZXIgPSBmYWxzZSxcbiAgICBjb21wb25lbnQgPSAxKSB7XG4gIHJldHVybiBgXG4gICR7XG4gICAgICBtYXRNdWxSZWFkRm5Tb3VyY2UoXG4gICAgICAgICAgYmF0Y2hBRXF1YWxPbmUsIGJhdGNoQkVxdWFsT25lLCB0cmFuc3Bvc2VBLCB0cmFuc3Bvc2VCLCBmaXRBT3V0ZXIsXG4gICAgICAgICAgZml0Qk91dGVyLCBmaXRJbm5lciwgY29tcG9uZW50KX1cbiAgZm4gbW1fd3JpdGUoYmF0Y2g6IGkzMiwgcm93OiBpMzIsIGNvbEluOiBpMzIsIHZhbHVlSW46ICR7XG4gICAgICB0eXBlU25pcHBldChjb21wb25lbnQpfSkge1xuICAgIGxldCBjb2wgPSBjb2xJbiAqICR7Y29tcG9uZW50fTtcbiAgICAke1xuICAgICAgZml0QU91dGVyICYmIGZpdEJPdXRlciA/XG4gICAgICAgICAgJycgOlxuICAgICAgICAgICdpZiAocm93IDwgdW5pZm9ybXMuZGltQU91dGVyICYmIGNvbCA8IHVuaWZvcm1zLmRpbUJPdXRlciknfVxuICAgIHtcbiAgICAgIHZhciB2YWx1ZSA9IHZhbHVlSW47XG4gICAgICBsZXQgY29vcmRzID0gdmVjMzxpMzI+KGJhdGNoLCByb3csIGNvbCk7XG4gICAgICAke2JpYXNBY3RpdmF0aW9uU25pcHBldChoYXNCaWFzLCBhY3RpdmF0aW9uKX1cbiAgICAgIHNldE91dHB1dEF0Q29vcmRzKGNvb3Jkc1swXSwgY29vcmRzWzFdLCBjb29yZHNbMl0sIHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgYDtcbn1cblxuY29uc3Qgd3JpdGVEYXRhVG9TdWJBVmVjNFNuaXBwZXQgPSAodHJhbnNwb3NlOiBib29sZWFuKSA9PiB7XG4gIGlmICh0cmFuc3Bvc2UpIHtcbiAgICByZXR1cm4gYFxuICAgICAgICBtbV9Bc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQShiYXRjaCxcbiAgICAgICAgICBrU3RhcnQgKyBpbnB1dFJvdyxcbiAgICAgICAgICBnbG9iYWxSb3dTdGFydCAvIElubmVyRWxlbWVudFNpemUgKyBpbnB1dENvbCk7XG4gICAgICAgIGA7XG5cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYFxuICAgICAgICBtbV9Bc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQShiYXRjaCxcbiAgICAgICAgICBnbG9iYWxSb3cgKyBpbm5lclJvdyxcbiAgICAgICAgICBrU3RhcnQgLyBJbm5lckVsZW1lbnRTaXplICsgaW5wdXRDb2wpO1xuICAgICAgICBgO1xuICB9XG59O1xuXG5jb25zdCBjYWxjdWxhdGVSZXN1bHRTbmlwcGV0ID1cbiAgICAodHJhbnNwb3NlQTogYm9vbGVhbiwgaW5uZXJFbGVtZW50U2l6ZTogbnVtYmVyKSA9PiB7XG4gICAgICBpZiAodHJhbnNwb3NlQSkge1xuICAgICAgICByZXR1cm4gYFxuICAgICAgICBsZXQgQUNhY2hlZDAgPSBtbV9Bc3ViW2sgKiBJbm5lckVsZW1lbnRTaXplXVtsb2NhbFJvd107XG4gICAgICAgIGxldCBBQ2FjaGVkMSA9IG1tX0FzdWJbayAqIElubmVyRWxlbWVudFNpemUgKyAxXVtsb2NhbFJvd107XG4gICAgICAgIGxldCBBQ2FjaGVkMiA9IG1tX0FzdWJbayAqIElubmVyRWxlbWVudFNpemUgKyAyXVtsb2NhbFJvd107XG4gICAgICAgICR7XG4gICAgICAgICAgICBpbm5lckVsZW1lbnRTaXplID09PSAzID9cbiAgICAgICAgICAgICAgICAnJyA6XG4gICAgICAgICAgICAgICAgJ2xldCBBQ2FjaGVkMyA9IG1tX0FzdWJbayAqIElubmVyRWxlbWVudFNpemUgKyAzXVtsb2NhbFJvd107J31cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBSb3dQZXJUaHJlYWQ7IGkgPSBpICsgMSkge1xuICAgICAgICAgIGFjY1tpXSA9IEJDYWNoZWQwICogQUNhY2hlZDBbaV0gKyBhY2NbaV07XG4gICAgICAgICAgYWNjW2ldID0gQkNhY2hlZDEgKiBBQ2FjaGVkMVtpXSArIGFjY1tpXTtcbiAgICAgICAgICBhY2NbaV0gPSBCQ2FjaGVkMiAqIEFDYWNoZWQyW2ldICsgYWNjW2ldO1xuICAgICAgICAgICR7XG4gICAgICAgICAgICBpbm5lckVsZW1lbnRTaXplID09PSAzID9cbiAgICAgICAgICAgICAgICAnJyA6XG4gICAgICAgICAgICAgICAgJ2FjY1tpXSA9IEJDYWNoZWQzICogQUNhY2hlZDNbaV0gKyBhY2NbaV07J31cbiAgICAgICAgfWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IFJvd1BlclRocmVhZDsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgbGV0IEFDYWNoZWQgPSBtbV9Bc3ViW3RpbGVSb3cgKyBpXVtrXTtcbiAgICAgICAgICBhY2NbaV0gPSBCQ2FjaGVkMCAqIEFDYWNoZWQueCArIGFjY1tpXTtcbiAgICAgICAgICBhY2NbaV0gPSBCQ2FjaGVkMSAqIEFDYWNoZWQueSArIGFjY1tpXTtcbiAgICAgICAgICBhY2NbaV0gPSBCQ2FjaGVkMiAqIEFDYWNoZWQueiArIGFjY1tpXTtcbiAgICAgICAgICAke1xuICAgICAgICAgICAgaW5uZXJFbGVtZW50U2l6ZSA9PT0gMyA/ICcnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnYWNjW2ldID0gQkNhY2hlZDMgKiBBQ2FjaGVkLncgKyBhY2NbaV07J31cbiAgICAgICAgfWA7XG4gICAgICB9XG4gICAgfTtcblxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VNYXRNdWxQYWNrZWRWZWM0U291cmNlKFxuICAgIHdvcmtQZXJUaHJlYWQ6IG51bWJlcltdLCB3b3JrR3JvdXBTaXplOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXG4gICAgdHJhbnNwb3NlQSA9IGZhbHNlLCB0aWxlSW5uZXIgPSAzMiwgc3BsaXRLID0gZmFsc2UsIHNwbGl0ZWREaW1Jbm5lciA9IDMyLFxuICAgIGlzVmVjdG9yQSA9IGZhbHNlKTogc3RyaW5nIHtcbiAgY29uc3QgdGlsZUFPdXRlciA9IHdvcmtHcm91cFNpemVbMV0gKiB3b3JrUGVyVGhyZWFkWzFdO1xuICBjb25zdCB0aWxlQk91dGVyID0gd29ya0dyb3VwU2l6ZVswXSAqIHdvcmtQZXJUaHJlYWRbMF07XG4gIGNvbnN0IHRpbGVBV2lkdGggPSB0cmFuc3Bvc2VBID8gdGlsZUFPdXRlciA6IHRpbGVJbm5lcjtcbiAgY29uc3QgdGlsZUFIaWdodCA9IHRyYW5zcG9zZUEgPyB0aWxlSW5uZXIgOiB0aWxlQU91dGVyO1xuICBjb25zdCBpbm5lckVsZW1lbnRTaXplID0gdGlsZUFXaWR0aCAvIHdvcmtHcm91cFNpemVbMF07XG4gIGNvbnN0IHJvd1BlclRocmVhZEIgPSB0aWxlSW5uZXIgLyB3b3JrR3JvdXBTaXplWzFdO1xuICB1dGlsLmFzc2VydChcbiAgICAgICgodHJhbnNwb3NlQSAmJiBpbm5lckVsZW1lbnRTaXplID09PSA0ICYmIHdvcmtQZXJUaHJlYWRbMV0gPT09IDQpIHx8XG4gICAgICAgKCF0cmFuc3Bvc2VBICYmIChpbm5lckVsZW1lbnRTaXplID09PSAzIHx8IGlubmVyRWxlbWVudFNpemUgPT09IDQpKSkgJiZcbiAgICAgICAgICB0aWxlQVdpZHRoICUgd29ya0dyb3VwU2l6ZVswXSA9PT0gMCAmJlxuICAgICAgICAgIHRpbGVJbm5lciAlIHdvcmtHcm91cFNpemVbMV0gPT09IDAgJiYgd29ya1BlclRocmVhZFswXSA9PT0gNCxcbiAgICAgICgpID0+IGBJZiB0cmFuc3Bvc2VBICR7dHJhbnNwb3NlQX0gaXMgdHJ1ZSwgaW5uZXJFbGVtZW50U2l6ZSAke1xuICAgICAgICAgIGlubmVyRWxlbWVudFNpemV9IGFuZCB3b3JrUGVyVGhyZWFkWzFdICR7d29ya1BlclRocmVhZFsxXX0gbXVzdCBiZSA0LlxuICAgICAgICAgIE90aGVyd2lzZSwgaW5uZXJFbGVtZW50U2l6ZSAke2lubmVyRWxlbWVudFNpemV9IG11c3QgYmUgMyBvciA0LlxuICAgICAgdGlsZUFXaWR0aCAke3RpbGVBV2lkdGh9IG11c3QgYmUgZGl2aXNpYmxlIGJ5IHdvcmtHcm91cFNpemVbMF0ke1xuICAgICAgICAgIHdvcmtHcm91cFNpemVbMF19LiB0aWxlSW5uZXIgJHtcbiAgICAgICAgICB0aWxlSW5uZXJ9IG11c3QgYmUgZGl2aXNpYmxlIGJ5IHdvcmtHcm91cFNpemVbMV0gJHtcbiAgICAgICAgICB3b3JrR3JvdXBTaXplWzFdfS4gQ29sUGVyVGhyZWFkICR7d29ya1BlclRocmVhZFswXX0gbXVzdCBiZSA0LmApO1xuICByZXR1cm4gYFxuICB2YXI8d29ya2dyb3VwPiBtbV9Bc3ViIDogYXJyYXk8YXJyYXk8dmVjJHtpbm5lckVsZW1lbnRTaXplfTxmMzI+LCAke1xuICAgICAgdGlsZUFXaWR0aCAvIGlubmVyRWxlbWVudFNpemV9PiwgJHt0aWxlQUhpZ2h0fT47XG4gIHZhcjx3b3JrZ3JvdXA+IG1tX0JzdWIgOiBhcnJheTxhcnJheTx2ZWM0PGYzMj4sICR7XG4gICAgICB0aWxlQk91dGVyIC8gd29ya1BlclRocmVhZFswXX0+LCAke3RpbGVJbm5lcn0+O1xuXG4gIGNvbnN0IFJvd1BlclRocmVhZCA9ICR7d29ya1BlclRocmVhZFsxXX07XG4gIGNvbnN0IENvbFBlclRocmVhZCA9ICR7d29ya1BlclRocmVhZFswXX07XG4gIGNvbnN0IElubmVyRWxlbWVudFNpemUgPSAke2lubmVyRWxlbWVudFNpemV9O1xuICBjb25zdCBUaWxlSW5uZXIgPSAke3RpbGVJbm5lcn07XG5cbiAgQGNvbXB1dGUgQHdvcmtncm91cF9zaXplKHdvcmtHcm91cFNpemVYLCB3b3JrR3JvdXBTaXplWSwgd29ya0dyb3VwU2l6ZVopXG4gIGZuIF9zdGFydChAYnVpbHRpbihsb2NhbF9pbnZvY2F0aW9uX2lkKSBMb2NhbElkIDogdmVjMzx1MzI+LFxuICAgICAgICAgICAgQGJ1aWx0aW4oZ2xvYmFsX2ludm9jYXRpb25faWQpIEdsb2JhbElkIDogdmVjMzx1MzI+LFxuICAgICAgICAgICAgQGJ1aWx0aW4obnVtX3dvcmtncm91cHMpIE51bVdvcmtncm91cHM6IHZlYzM8dTMyPixcbiAgICAgICAgICAgIEBidWlsdGluKHdvcmtncm91cF9pZCkgd29ya2dyb3VwSWQ6IHZlYzM8dTMyPikge1xuICAgIGxvY2FsSWQgPSBMb2NhbElkO1xuICAgIGdsb2JhbElkID0gR2xvYmFsSWQ7XG4gICAgbnVtV29ya2dyb3VwcyA9IE51bVdvcmtncm91cHM7XG5cbiAgICBsZXQgbG9jYWxSb3cgPSBpMzIobG9jYWxJZC55KTtcbiAgICBsZXQgdGlsZVJvdyA9ICR7aXNWZWN0b3JBID8gJzAnIDogJ2xvY2FsUm93ICogUm93UGVyVGhyZWFkJ307XG4gICAgbGV0IHRpbGVDb2wgPSBpMzIobG9jYWxJZC54KTtcblxuICAgIGxldCBnbG9iYWxSb3cgPSAke2lzVmVjdG9yQSA/ICcwJyA6ICdpMzIoZ2xvYmFsSWQueSkgKiBSb3dQZXJUaHJlYWQnfTtcbiAgICBsZXQgZ2xvYmFsQ29sID0gaTMyKGdsb2JhbElkLngpO1xuICAgIGxldCBiYXRjaCA9ICR7c3BsaXRLID8gJzAnIDogJ2kzMihnbG9iYWxJZC56KSd9O1xuICAgIGxldCBnbG9iYWxSb3dTdGFydCA9IGkzMih3b3JrZ3JvdXBJZC55KSAqICR7dGlsZUFPdXRlcn07XG5cbiAgICBsZXQgbnVtVGlsZXMgPSAke1xuICAgICAgc3BsaXRLID8gYCR7TWF0aC5jZWlsKHNwbGl0ZWREaW1Jbm5lciAvIHRpbGVJbm5lcil9YCA6XG4gICAgICAgICAgICAgICAnKHVuaWZvcm1zLmRpbUlubmVyIC0gMSkgLyBUaWxlSW5uZXIgKyAxJ307XG4gICAgdmFyIGtTdGFydCA9ICR7c3BsaXRLID8gYGkzMihnbG9iYWxJZC56KSAqICR7c3BsaXRlZERpbUlubmVyfWAgOiAnMCd9O1xuXG4gICAgdmFyIGFjYzogYXJyYXk8dmVjNDxmMzI+LCBSb3dQZXJUaHJlYWQ+O1xuXG4gICAgLy8gTG9vcCBvdmVyIHNoYXJlZCBkaW1lbnNpb24uXG4gICAgbGV0IHRpbGVSb3dCID0gbG9jYWxSb3cgKiAke3Jvd1BlclRocmVhZEJ9O1xuICAgIGZvciAodmFyIHQgPSAwOyB0IDwgbnVtVGlsZXM7IHQgPSB0ICsgMSkge1xuICAgICAgICAvLyBMb2FkIG9uZSB0aWxlIG9mIEEgaW50byBsb2NhbCBtZW1vcnkuXG4gICAgICAgIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCBSb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gICAgICAgICAgICBsZXQgaW5wdXRSb3cgPSB0aWxlUm93ICsgaW5uZXJSb3c7XG4gICAgICAgICAgICBsZXQgaW5wdXRDb2wgPSB0aWxlQ29sO1xuICAgICAgICAgICAgJHt3cml0ZURhdGFUb1N1YkFWZWM0U25pcHBldCh0cmFuc3Bvc2VBKX1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIExvYWQgb25lIHRpbGUgb2YgQiBpbnRvIGxvY2FsIG1lbW9yeS5cbiAgICAgICAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8ICR7XG4gICAgICByb3dQZXJUaHJlYWRCfTsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgICAgICAgICAgIGxldCBpbnB1dFJvdyA9IHRpbGVSb3dCICsgaW5uZXJSb3c7XG4gICAgICAgICAgICBsZXQgaW5wdXRDb2wgPSB0aWxlQ29sO1xuICAgICAgICAgICAgbW1fQnN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEIoYmF0Y2gsIGtTdGFydCArIGlucHV0Um93LCBnbG9iYWxDb2wpO1xuICAgICAgICB9XG4gICAgICAgIGtTdGFydCA9IGtTdGFydCArIFRpbGVJbm5lcjtcbiAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICAgIC8vIENvbXB1dGUgYWNjIHZhbHVlcyBmb3IgYSBzaW5nbGUgdGhyZWFkLlxuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IFRpbGVJbm5lciAvIElubmVyRWxlbWVudFNpemU7IGsgPSBrICsgMSkge1xuICAgICAgICAgICAgbGV0IEJDYWNoZWQwID0gbW1fQnN1YltrICogSW5uZXJFbGVtZW50U2l6ZV1bdGlsZUNvbF07XG4gICAgICAgICAgICBsZXQgQkNhY2hlZDEgPSBtbV9Cc3ViW2sgKiBJbm5lckVsZW1lbnRTaXplICsgMV1bdGlsZUNvbF07XG4gICAgICAgICAgICBsZXQgQkNhY2hlZDIgPSBtbV9Cc3ViW2sgKiBJbm5lckVsZW1lbnRTaXplICsgMl1bdGlsZUNvbF07XG4gICAgICAgICAgICAke1xuICAgICAgaW5uZXJFbGVtZW50U2l6ZSA9PT0gMyA/XG4gICAgICAgICAgJycgOlxuICAgICAgICAgICdsZXQgQkNhY2hlZDMgPSBtbV9Cc3ViW2sgKiBJbm5lckVsZW1lbnRTaXplICsgM11bdGlsZUNvbF07J31cblxuICAgICAgICAgICAgJHtjYWxjdWxhdGVSZXN1bHRTbmlwcGV0KHRyYW5zcG9zZUEsIGlubmVyRWxlbWVudFNpemUpfVxuICAgICAgICB9XG5cbiAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCBSb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gICAgICAgIG1tX3dyaXRlKGJhdGNoLCBnbG9iYWxSb3cgKyBpbm5lclJvdywgZ2xvYmFsQ29sLCBhY2NbaW5uZXJSb3ddKTtcbiAgICB9XG4gIH1gO1xufVxuXG5jb25zdCB3cml0ZURhdGFUb1N1YkFTbmlwcGV0ID0gKHRyYW5zcG9zZTogYm9vbGVhbikgPT4ge1xuICBpZiAodHJhbnNwb3NlKSB7XG4gICAgcmV0dXJuIGBcbiAgICAgICAgbW1fQXN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEEoYmF0Y2gsXG4gICAgICAgICAga1N0YXJ0ICsgaW5wdXRSb3csXG4gICAgICAgICAgZ2xvYmFsUm93U3RhcnQgKyBpbnB1dENvbCk7XG4gICAgICAgIGA7XG5cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYFxuICAgICAgICBtbV9Bc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQShiYXRjaCxcbiAgICAgICAgICBnbG9iYWxSb3dTdGFydCArIGlucHV0Um93LFxuICAgICAgICAgIGtTdGFydCArIGlucHV0Q29sKTtcbiAgICAgICAgYDtcbiAgfVxufTtcblxuY29uc3QgcmVhZERhdGFGcm9tU3ViQVNuaXBwZXQgPSAodHJhbnNwb3NlQTogYm9vbGVhbikgPT4ge1xuICByZXR1cm4gdHJhbnNwb3NlQSA/ICdsZXQgQUNhY2hlZCA9IG1tX0FzdWJba11bdGlsZVJvdyArIGlubmVyUm93XTsnIDpcblxuICAgICAgICAgICAgICAgICAgICAgICdsZXQgQUNhY2hlZCA9IG1tX0FzdWJbdGlsZVJvdyArIGlubmVyUm93XVtrXTsnO1xufTtcblxuLy8gc2VxdWVudGlhbEFjY2Vzc0J5VGhyZWFkcyBtZWFucyBzZXF1ZW50aWFsIGRhdGEgaW4gbWVtb3J5IGlzIGFjY2Vzc2VkIGJ5XG4vLyB0aHJlYWRzLCBpbnN0ZWFkIG9mIGEgc2luZ2xlIHRocmVhZCAoZGVmYXVsdCBiZWhhdmlvcikuXG5leHBvcnQgZnVuY3Rpb24gbWFrZU1hdE11bFBhY2tlZFNvdXJjZShcbiAgICB3b3JrUGVyVGhyZWFkOiBudW1iZXJbXSwgd29ya0dyb3VwU2l6ZTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdLFxuICAgIHRyYW5zcG9zZUEgPSBmYWxzZSwgdGlsZUlubmVyID0gMzIsIHNwbGl0SyA9IGZhbHNlLCBzcGxpdGVkRGltSW5uZXIgPSAzMixcbiAgICBzZXF1ZW50aWFsQWNjZXNzQnlUaHJlYWRzID0gZmFsc2UpOiBzdHJpbmcge1xuICBjb25zdCB0aWxlQU91dGVyID0gd29ya1BlclRocmVhZFsxXSAqIHdvcmtHcm91cFNpemVbMV07XG4gIGNvbnN0IHRpbGVCT3V0ZXIgPSB3b3JrUGVyVGhyZWFkWzBdICogd29ya0dyb3VwU2l6ZVswXTtcbiAgY29uc3QgdGlsZUFXaWR0aCA9IHRyYW5zcG9zZUEgPyB0aWxlQU91dGVyIDogdGlsZUlubmVyO1xuICBjb25zdCB0aWxlQUhpZ2h0ID0gdHJhbnNwb3NlQSA/IHRpbGVJbm5lciA6IHRpbGVBT3V0ZXI7XG4gIHV0aWwuYXNzZXJ0KFxuICAgICAgdGlsZUFIaWdodCAlIHdvcmtHcm91cFNpemVbMV0gPT09IDAgJiZcbiAgICAgICAgICB0aWxlQVdpZHRoICUgd29ya0dyb3VwU2l6ZVswXSA9PT0gMCAmJlxuICAgICAgICAgIHRpbGVJbm5lciAlIHdvcmtHcm91cFNpemVbMV0gPT09IDAsXG4gICAgICAoKSA9PiBgdGlsZUFIaWdodCAke3RpbGVBSGlnaHR9IG11c3QgYmUgZGl2aXNpYmxlIGJ5IHdvcmtHcm91cFNpemVbMV0ke1xuICAgICAgICAgIHdvcmtHcm91cFNpemVbMV19LCB0aWxlQVdpZHRoICR7XG4gICAgICAgICAgdGlsZUFXaWR0aH0gbXVzdCBiZSBkaXZpc2libGUgYnkgd29ya0dyb3VwU2l6ZVswXSR7XG4gICAgICAgICAgd29ya0dyb3VwU2l6ZVswXX0sIHRpbGVJbm5lciAke1xuICAgICAgICAgIHRpbGVJbm5lcn0gbXVzdCBiZSBkaXZpc2libGUgYnkgd29ya0dyb3VwU2l6ZVsxXSR7d29ya0dyb3VwU2l6ZVsxXX1gKTtcbiAgY29uc3Qgcm93UGVyVGhyZWFkQSA9IHRpbGVBSGlnaHQgLyB3b3JrR3JvdXBTaXplWzFdO1xuICBjb25zdCBjb2xQZXJUaHJlYWRBID0gdGlsZUFXaWR0aCAvIHdvcmtHcm91cFNpemVbMF07XG4gIGNvbnN0IHJvd1BlclRocmVhZEIgPSB0aWxlSW5uZXIgLyB3b3JrR3JvdXBTaXplWzFdO1xuICBjb25zdCBtYXRtdWxTbmlwcGV0ID0gc2VxdWVudGlhbEFjY2Vzc0J5VGhyZWFkcyA/XG4gICAgICBgXG4gICAgICBsZXQgbG9jYWxSb3cgPSBpMzIobG9jYWxJZC55KTtcbiAgICAgIGxldCBsb2NhbENvbCA9IGkzMihsb2NhbElkLngpO1xuICAgICAgbGV0IGdsb2JhbFJvd1N0YXJ0ID0gaTMyKHdvcmtncm91cElkLnkpICogJHt0aWxlQU91dGVyfTtcbiAgICAgIGxldCBnbG9iYWxDb2xTdGFydCA9IGkzMih3b3JrZ3JvdXBJZC54KSAqICR7dGlsZUJPdXRlcn07XG5cbiAgICAgIC8vIExvb3Agb3ZlciBzaGFyZWQgZGltZW5zaW9uLlxuICAgICAgZm9yICh2YXIgdCA9IDA7IHQgPCBudW1UaWxlczsgdCA9IHQgKyAxKSB7XG4gICAgICAgIC8vIExvYWQgb25lIHRpbGUgb2YgQSBpbnRvIGxvY2FsIG1lbW9yeS5cbiAgICAgICAgZm9yICh2YXIgaW5wdXRSb3cgPSBsb2NhbFJvdzsgaW5wdXRSb3cgPCAke1xuICAgICAgICAgIHRpbGVBSGlnaHR9OyBpbnB1dFJvdyA9IGlucHV0Um93ICsgJHt3b3JrR3JvdXBTaXplWzFdfSkge1xuICAgICAgICAgIGZvciAodmFyIGlucHV0Q29sID0gbG9jYWxDb2w7IGlucHV0Q29sIDwgJHtcbiAgICAgICAgICB0aWxlQVdpZHRofTsgaW5wdXRDb2wgPSBpbnB1dENvbCArICR7d29ya0dyb3VwU2l6ZVswXX0pIHtcbiAgICAgICAgICAgICR7d3JpdGVEYXRhVG9TdWJBU25pcHBldCh0cmFuc3Bvc2VBKX1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTG9hZCBvbmUgdGlsZSBvZiBCIGludG8gbG9jYWwgbWVtb3J5LlxuICAgICAgICBmb3IgKHZhciBpbnB1dFJvdyA9IGxvY2FsUm93OyBpbnB1dFJvdyA8ICR7XG4gICAgICAgICAgdGlsZUlubmVyfTsgaW5wdXRSb3cgPSBpbnB1dFJvdyArICR7d29ya0dyb3VwU2l6ZVsxXX0pIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaW5wdXRDb2wgPSBsb2NhbENvbDsgaW5wdXRDb2wgPCAke1xuICAgICAgICAgIHRpbGVCT3V0ZXJ9OyBpbnB1dENvbCA9IGlucHV0Q29sICsgJHt3b3JrR3JvdXBTaXplWzBdfSkge1xuICAgICAgICAgICAgbW1fQnN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEIoYmF0Y2gsXG4gICAgICAgICAgICAgIGtTdGFydCArIGlucHV0Um93LFxuICAgICAgICAgICAgICBnbG9iYWxDb2xTdGFydCArIGlucHV0Q29sKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAga1N0YXJ0ID0ga1N0YXJ0ICsgVGlsZUlubmVyO1xuICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSBhY2MgdmFsdWVzIGZvciBhIHNpbmdsZSB0aHJlYWQuXG4gICAgICAgIHZhciBCQ2FjaGVkIDogYXJyYXk8ZjMyLCBDb2xQZXJUaHJlYWQ+O1xuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IFRpbGVJbm5lcjsgayA9IGsgKyAxKSB7XG4gICAgICAgICAgZm9yICh2YXIgaW5uZXIgPSAwOyBpbm5lciA8IENvbFBlclRocmVhZDsgaW5uZXIgPSBpbm5lciArIDEpIHtcbiAgICAgICAgICAgIEJDYWNoZWRbaW5uZXJdID0gbW1fQnN1YltrXVtsb2NhbENvbCArIGlubmVyICogJHt3b3JrR3JvdXBTaXplWzBdfV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCBSb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gICAgICAgICAgICBsZXQgQUNhY2hlZCA9ICR7XG4gICAgICAgICAgdHJhbnNwb3NlQSA/XG4gICAgICAgICAgICAgIGBtbV9Bc3ViW2tdW2xvY2FsUm93ICsgaW5uZXJSb3cgKiAke3dvcmtHcm91cFNpemVbMV19XTtgIDpcbiAgICAgICAgICAgICAgYG1tX0FzdWJbbG9jYWxSb3cgKyBpbm5lclJvdyAqICR7d29ya0dyb3VwU2l6ZVsxXX1dW2tdO2B9XG4gICAgICAgICAgICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgQ29sUGVyVGhyZWFkOyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xuICAgICAgICAgICAgICBhY2NbaW5uZXJSb3ddW2lubmVyQ29sXSA9IGFjY1tpbm5lclJvd11baW5uZXJDb2xdICtcbiAgICAgICAgICAgICAgICAgIEFDYWNoZWQgKiBCQ2FjaGVkW2lubmVyQ29sXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8IFJvd1BlclRocmVhZDsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgICAgICAgbGV0IGdSb3cgPSBnbG9iYWxSb3dTdGFydCArIGxvY2FsUm93ICsgaW5uZXJSb3cgKiAke3dvcmtHcm91cFNpemVbMV19O1xuICAgICAgICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgQ29sUGVyVGhyZWFkOyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xuICAgICAgICAgIGxldCBnQ29sID0gZ2xvYmFsQ29sU3RhcnQgKyBsb2NhbENvbCArIGlubmVyQ29sICogJHt3b3JrR3JvdXBTaXplWzBdfTtcbiAgICAgICAgICBtbV93cml0ZShiYXRjaCwgZ1JvdywgZ0NvbCwgYWNjW2lubmVyUm93XVtpbm5lckNvbF0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBgIDpcbiAgICAgIGBcbiAgbGV0IHRpbGVSb3cgPSBpMzIobG9jYWxJZC55KSAqIFJvd1BlclRocmVhZDtcbiAgbGV0IHRpbGVDb2wgPSBpMzIobG9jYWxJZC54KSAqIENvbFBlclRocmVhZDtcblxuICBsZXQgZ2xvYmFsUm93ID0gaTMyKGdsb2JhbElkLnkpICogUm93UGVyVGhyZWFkO1xuICBsZXQgZ2xvYmFsQ29sID0gaTMyKGdsb2JhbElkLngpICogQ29sUGVyVGhyZWFkO1xuICBsZXQgZ2xvYmFsUm93U3RhcnQgPSBpMzIod29ya2dyb3VwSWQueSkgKiAke3RpbGVBT3V0ZXJ9O1xuXG4gIGxldCB0aWxlUm93QSA9IGkzMihsb2NhbElkLnkpICogJHtyb3dQZXJUaHJlYWRBfTtcbiAgbGV0IHRpbGVDb2xBID0gaTMyKGxvY2FsSWQueCkgKiAke2NvbFBlclRocmVhZEF9O1xuICBsZXQgdGlsZVJvd0IgPSBpMzIobG9jYWxJZC55KSAqICR7cm93UGVyVGhyZWFkQn07XG4gIC8vIExvb3Agb3ZlciBzaGFyZWQgZGltZW5zaW9uLlxuICBmb3IgKHZhciB0ID0gMDsgdCA8IG51bVRpbGVzOyB0ID0gdCArIDEpIHtcbiAgICAvLyBMb2FkIG9uZSB0aWxlIG9mIEEgaW50byBsb2NhbCBtZW1vcnkuXG4gICAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8ICR7XG4gICAgICAgICAgcm93UGVyVGhyZWFkQX07IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gICAgICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgJHtcbiAgICAgICAgICBjb2xQZXJUaHJlYWRBfTsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcbiAgICAgICAgbGV0IGlucHV0Um93ID0gdGlsZVJvd0EgKyBpbm5lclJvdztcbiAgICAgICAgbGV0IGlucHV0Q29sID0gdGlsZUNvbEEgKyBpbm5lckNvbDtcbiAgICAgICAgJHt3cml0ZURhdGFUb1N1YkFTbmlwcGV0KHRyYW5zcG9zZUEpfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIExvYWQgb25lIHRpbGUgb2YgQiBpbnRvIGxvY2FsIG1lbW9yeS5cbiAgICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgJHtcbiAgICAgICAgICByb3dQZXJUaHJlYWRCfTsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgICAgIGZvciAodmFyIGlubmVyQ29sID0gMDsgaW5uZXJDb2wgPCBDb2xQZXJUaHJlYWQ7IGlubmVyQ29sID0gaW5uZXJDb2wgKyAxKSB7XG4gICAgICAgIGxldCBpbnB1dFJvdyA9IHRpbGVSb3dCICsgaW5uZXJSb3c7XG4gICAgICAgIGxldCBpbnB1dENvbCA9IHRpbGVDb2wgKyBpbm5lckNvbDtcbiAgICAgICAgbW1fQnN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEIoYmF0Y2gsXG4gICAgICAgICAga1N0YXJ0ICsgaW5wdXRSb3csXG4gICAgICAgICAgZ2xvYmFsQ29sICsgaW5uZXJDb2wpO1xuICAgICAgfVxuICAgIH1cbiAgICBrU3RhcnQgPSBrU3RhcnQgKyBUaWxlSW5uZXI7XG4gICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgLy8gQ29tcHV0ZSBhY2MgdmFsdWVzIGZvciBhIHNpbmdsZSB0aHJlYWQuXG4gICAgdmFyIEJDYWNoZWQgOiBhcnJheTxmMzIsIENvbFBlclRocmVhZD47XG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBUaWxlSW5uZXI7IGsgPSBrICsgMSkge1xuICAgICAgZm9yICh2YXIgaW5uZXIgPSAwOyBpbm5lciA8IENvbFBlclRocmVhZDsgaW5uZXIgPSBpbm5lciArIDEpIHtcbiAgICAgICAgQkNhY2hlZFtpbm5lcl0gPSBtbV9Cc3ViW2tdW3RpbGVDb2wgKyBpbm5lcl07XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCBSb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gICAgICAgICR7cmVhZERhdGFGcm9tU3ViQVNuaXBwZXQodHJhbnNwb3NlQSl9XG4gICAgICAgIGZvciAodmFyIGlubmVyQ29sID0gMDsgaW5uZXJDb2wgPCBDb2xQZXJUaHJlYWQ7IGlubmVyQ29sID0gaW5uZXJDb2wgKyAxKSB7XG4gICAgICAgICAgYWNjW2lubmVyUm93XVtpbm5lckNvbF0gPSBhY2NbaW5uZXJSb3ddW2lubmVyQ29sXSArIEFDYWNoZWQgKiBCQ2FjaGVkW2lubmVyQ29sXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgfVxuXG4gIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCBSb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gICAgZm9yICh2YXIgaW5uZXJDb2wgPSAwOyBpbm5lckNvbCA8IENvbFBlclRocmVhZDsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcbiAgICAgIG1tX3dyaXRlKGJhdGNoLCBnbG9iYWxSb3cgKyBpbm5lclJvdywgZ2xvYmFsQ29sICsgaW5uZXJDb2wsXG4gICAgICAgICAgYWNjW2lubmVyUm93XVtpbm5lckNvbF0pO1xuICAgIH1cbiAgfVxuICBgO1xuXG4gIHJldHVybiBgXG4gICAgdmFyPHdvcmtncm91cD4gbW1fQXN1YiA6IGFycmF5PGFycmF5PGYzMiwgJHt0aWxlQVdpZHRofT4sICR7dGlsZUFIaWdodH0+O1xuICAgIHZhcjx3b3JrZ3JvdXA+IG1tX0JzdWIgOiBhcnJheTxhcnJheTxmMzIsICR7dGlsZUJPdXRlcn0+LCAke3RpbGVJbm5lcn0+O1xuICAgIGNvbnN0IFJvd1BlclRocmVhZCA9ICR7d29ya1BlclRocmVhZFsxXX07XG4gICAgY29uc3QgQ29sUGVyVGhyZWFkID0gJHt3b3JrUGVyVGhyZWFkWzBdfTtcbiAgICBjb25zdCBUaWxlSW5uZXIgPSAke3RpbGVJbm5lcn07XG5cbiAgICBAY29tcHV0ZSBAd29ya2dyb3VwX3NpemUod29ya0dyb3VwU2l6ZVgsIHdvcmtHcm91cFNpemVZLCB3b3JrR3JvdXBTaXplWilcbiAgICBmbiBfc3RhcnQoQGJ1aWx0aW4obG9jYWxfaW52b2NhdGlvbl9pZCkgTG9jYWxJZCA6IHZlYzM8dTMyPixcbiAgICAgICAgICAgICAgQGJ1aWx0aW4oZ2xvYmFsX2ludm9jYXRpb25faWQpIEdsb2JhbElkIDogdmVjMzx1MzI+LFxuICAgICAgICAgICAgICBAYnVpbHRpbihudW1fd29ya2dyb3VwcykgTnVtV29ya2dyb3VwczogdmVjMzx1MzI+LFxuICAgICAgICAgICAgICBAYnVpbHRpbih3b3JrZ3JvdXBfaWQpIHdvcmtncm91cElkOiB2ZWMzPHUzMj4pIHtcbiAgICAgIGxvY2FsSWQgPSBMb2NhbElkO1xuICAgICAgZ2xvYmFsSWQgPSBHbG9iYWxJZDtcbiAgICAgIG51bVdvcmtncm91cHMgPSBOdW1Xb3JrZ3JvdXBzO1xuXG4gICAgICBsZXQgYmF0Y2ggPSAke3NwbGl0SyA/ICcwJyA6ICdpMzIoZ2xvYmFsSWQueiknfTtcbiAgICAgIGxldCBudW1UaWxlcyA9ICR7XG4gICAgICBzcGxpdEsgPyBgJHtNYXRoLmNlaWwoc3BsaXRlZERpbUlubmVyIC8gdGlsZUlubmVyKX1gIDpcbiAgICAgICAgICAgICAgICcodW5pZm9ybXMuZGltSW5uZXIgLSAxKSAvIFRpbGVJbm5lciArIDEnfTtcbiAgICAgIHZhciBrU3RhcnQgPSAke3NwbGl0SyA/IGBpMzIoZ2xvYmFsSWQueikgKiAke3NwbGl0ZWREaW1Jbm5lcn1gIDogJzAnfTtcblxuICAgICAgdmFyIGFjYyA6IGFycmF5PGFycmF5PGYzMiwgQ29sUGVyVGhyZWFkPiwgUm93UGVyVGhyZWFkPjtcblxuICAgICAgLy8gV2l0aG91dCB0aGlzIGluaXRpYWxpemF0aW9uIHN0cmFuZ2UgdmFsdWVzIHNob3cgdXAgaW4gYWNjLlxuICAgICAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8IFJvd1BlclRocmVhZDsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgICAgICAgZm9yICh2YXIgaW5uZXJDb2wgPSAwOyBpbm5lckNvbCA8IENvbFBlclRocmVhZDsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcbiAgICAgICAgICBhY2NbaW5uZXJSb3ddW2lubmVyQ29sXSA9IDAuMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgJHttYXRtdWxTbmlwcGV0fVxuICAgIH1cbiAgYDtcbn1cblxuY29uc3QgcmVhZFZlY3RvckFTbmlwcGV0ID0gKHRyYW5zcG9zZTogYm9vbGVhbikgPT4ge1xuICByZXR1cm4gdHJhbnNwb3NlID8gYFxuICAgICAgbW1fcmVhZEEoYmF0Y2gsIGNvbEEsIGdsb2JhbFJvdyksXG4gICAgICBtbV9yZWFkQShiYXRjaCwgY29sQSArIDEsIGdsb2JhbFJvdyksXG4gICAgICBtbV9yZWFkQShiYXRjaCwgY29sQSArIDIsIGdsb2JhbFJvdyksXG4gICAgICBtbV9yZWFkQShiYXRjaCwgY29sQSArIDMsIGdsb2JhbFJvdylcbiAgYCA6XG4gICAgICAgICAgICAgICAgICAgICBgXG4gICAgICBtbV9yZWFkQShiYXRjaCwgZ2xvYmFsUm93LCBjb2xBKSxcbiAgICAgIG1tX3JlYWRBKGJhdGNoLCBnbG9iYWxSb3csIGNvbEEgKyAxKSxcbiAgICAgIG1tX3JlYWRBKGJhdGNoLCBnbG9iYWxSb3csIGNvbEEgKyAyKSxcbiAgICAgIG1tX3JlYWRBKGJhdGNoLCBnbG9iYWxSb3csIGNvbEEgKyAzKVxuICBgO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VWZWN0b3JNYXRyaXhQcm9kdWN0U291cmNlKFxuICAgIHdvcmtHcm91cFNpemU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSwgdHJhbnNwb3NlQSA9IGZhbHNlKTogc3RyaW5nIHtcbiAgdXRpbC5hc3NlcnQoXG4gICAgICB3b3JrR3JvdXBTaXplWzFdID09PSAxICYmIHdvcmtHcm91cFNpemVbMl0gPT09IDEsXG4gICAgICAoKSA9PiBgQSBsaW5lYXIgd29yayBncm91cCBzaXplIGlzIHJlcXVpcmVkLiBCdXQgZ290ICR7d29ya0dyb3VwU2l6ZX0uYCk7XG4gIHJldHVybiBgXG4gICAgY29uc3QgVGlsZVNpemUgPSAke3dvcmtHcm91cFNpemVbMF0gKiA0fTtcbiAgICB2YXI8d29ya2dyb3VwPiBtbV9Bc3ViIDogYXJyYXk8dmVjNDxmMzI+LCAke3dvcmtHcm91cFNpemVbMF19PjtcblxuICAgICR7bWFpbigpfSB7XG4gICAgICBsZXQgdGlsZUNvbCA9IGkzMihsb2NhbElkLngpO1xuICAgICAgbGV0IGdsb2JhbENvbCA9IGkzMihnbG9iYWxJZC54KTtcbiAgICAgIGxldCBnbG9iYWxSb3cgPSBpMzIoZ2xvYmFsSWQueSk7XG5cbiAgICAgIGxldCBudW1UaWxlcyA9ICh1bmlmb3Jtcy5kaW1Jbm5lciAtIDEpIC8gVGlsZVNpemUgKyAxO1xuICAgICAgbGV0IGJhdGNoID0gaTMyKGdsb2JhbElkLnopO1xuICAgICAgLy8gV2l0aG91dCB0aGlzIGluaXRpYWxpemF0aW9uIHN0cmFuZ2UgdmFsdWVzIHNob3cgdXAgaW4gYWNjLlxuICAgICAgdmFyIGFjYyA9IDAuMDtcblxuICAgICAgLy8gTG9vcCBvdmVyIHNoYXJlZCBkaW1lbnNpb24uXG4gICAgICBmb3IgKHZhciB0ID0gMDsgdCA8IG51bVRpbGVzOyB0ID0gdCArIDEpIHtcbiAgICAgICAgLy8gTG9hZCBvbmUgdGlsZSBvZiBBIGludG8gbG9jYWwgbWVtb3J5LlxuICAgICAgICBsZXQgY29sQSA9IHQgKiBUaWxlU2l6ZSArIHRpbGVDb2wgKiA0O1xuICAgICAgICBtbV9Bc3ViW3RpbGVDb2xdID0gdmVjNDxmMzI+KCR7cmVhZFZlY3RvckFTbmlwcGV0KHRyYW5zcG9zZUEpfSk7XG4gICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgICAvLyBDb21wdXRlIGFjYyB2YWx1ZXMgZm9yIGEgc2luZ2xlIHRocmVhZC5cbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBUaWxlU2l6ZSAvIDQ7IGsgPSBrICsgMSkge1xuICAgICAgICAgIGxldCByb3dCID0gdCAqIFRpbGVTaXplICsgayAqIDQ7XG4gICAgICAgICAgbGV0IEJDYWNoZWQgPSB2ZWM0PGYzMj4obW1fcmVhZEIoYmF0Y2gsIHJvd0IsIGdsb2JhbENvbCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtbV9yZWFkQihiYXRjaCwgcm93QiArIDEsIGdsb2JhbENvbCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtbV9yZWFkQihiYXRjaCwgcm93QiArIDIsIGdsb2JhbENvbCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtbV9yZWFkQihiYXRjaCwgcm93QiArIDMsIGdsb2JhbENvbCkpO1xuXG4gICAgICAgICAgbGV0IEFDYWNoZWQgPSBtbV9Bc3ViW2tdO1xuICAgICAgICAgIGFjYyA9IGFjYyArIGRvdChBQ2FjaGVkLCBCQ2FjaGVkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICAgIH1cblxuICAgICAgbW1fd3JpdGUoYmF0Y2gsIGdsb2JhbFJvdywgZ2xvYmFsQ29sLCBhY2MpO1xuICAgIH1cbiAgYDtcbn1cblxuZXhwb3J0IGNsYXNzIE1hdE11bFBhY2tlZFByb2dyYW0gaW1wbGVtZW50cyBXZWJHUFVQcm9ncmFtIHtcbiAgb3V0cHV0U2hhcGU6IG51bWJlcltdO1xuICBzaGFkZXJLZXk6IHN0cmluZztcbiAgZGlzcGF0Y2hMYXlvdXQ6IHt4OiBudW1iZXJbXSwgeTogbnVtYmVyW10sIHo6IG51bWJlcltdfTtcbiAgZGlzcGF0Y2g6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbiAgdmFyaWFibGVOYW1lcyA9IFsnQScsICdCJ107XG4gIHVuaWZvcm1zID0gYGRpbUFPdXRlciA6IGkzMiwgZGltQk91dGVyIDogaTMyLCBkaW1Jbm5lciA6IGkzMixgO1xuICB3b3JrR3JvdXBTaXplOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG4gIGVsZW1lbnRzUGVyVGhyZWFkOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG4gIHRyYW5zcG9zZUE6IGJvb2xlYW47XG4gIHRyYW5zcG9zZUI6IGJvb2xlYW47XG4gIGFkZEJpYXM6IGJvb2xlYW47XG4gIGFjdGl2YXRpb246IGJhY2tlbmRfdXRpbC5BY3RpdmF0aW9uO1xuICBoYXNQcmVsdUFjdGl2YXRpb25XZWlnaHRzOiBib29sZWFuO1xuICBiYXRjaEFFcXVhbE9uZTogYm9vbGVhbjtcbiAgYmF0Y2hCRXF1YWxPbmU6IGJvb2xlYW47XG4gIGZpdEFPdXRlcjogYm9vbGVhbjtcbiAgZml0Qk91dGVyOiBib29sZWFuO1xuICBmaXRJbm5lcjogYm9vbGVhbjtcbiAgdGlsZUlubmVyOiBudW1iZXI7XG4gIGlzVmVjdG9yQTogYm9vbGVhbjtcbiAgaXNWZWM0OiBib29sZWFuO1xuICBwcml2YXRlIHNlcXVlbnRpYWxBY2Nlc3NCeVRocmVhZHM6IGJvb2xlYW47XG5cbiAgY29uc3RydWN0b3IoXG4gICAgICBhU2hhcGU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSwgb3V0cHV0U2hhcGU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSxcbiAgICAgIGJhdGNoQUVxdWFsT25lOiBib29sZWFuLCBiYXRjaEJFcXVhbE9uZTogYm9vbGVhbiwgdHJhbnNwb3NlQSA9IGZhbHNlLFxuICAgICAgdHJhbnNwb3NlQiA9IGZhbHNlLCBiaWFzOiBUZW5zb3JJbmZvID0gbnVsbCxcbiAgICAgIGFjdGl2YXRpb246IGJhY2tlbmRfdXRpbC5BY3RpdmF0aW9uID0gbnVsbCxcbiAgICAgIHByZWx1QWN0aXZhdGlvbldlaWdodHM6IFRlbnNvckluZm8gPSBudWxsLFxuICAgICAgc2VxdWVudGlhbEFjY2Vzc0J5VGhyZWFkcyA9IGZhbHNlKSB7XG4gICAgdGhpcy5vdXRwdXRTaGFwZSA9IG91dHB1dFNoYXBlO1xuICAgIHRoaXMuZGlzcGF0Y2hMYXlvdXQgPSB7eDogWzJdLCB5OiBbMV0sIHo6IFswXX07XG4gICAgY29uc3QgZGltSW5uZXIgPSB0cmFuc3Bvc2VBID8gYVNoYXBlWzFdIDogYVNoYXBlWzJdO1xuICAgIHRoaXMuaXNWZWM0ID0gKChkaW1Jbm5lciAlIDQgPT09IDAgJiYgIXRyYW5zcG9zZUEpIHx8XG4gICAgICAgICAgICAgICAgICAgKG91dHB1dFNoYXBlWzFdICUgNCA9PT0gMCAmJiB0cmFuc3Bvc2VBKSkgJiZcbiAgICAgICAgb3V0cHV0U2hhcGVbMl0gJSA0ID09PSAwICYmICF0cmFuc3Bvc2VCO1xuICAgIHRoaXMuaXNWZWN0b3JBID0gb3V0cHV0U2hhcGVbMV0gPT09IDEgJiYgIXRyYW5zcG9zZUE7XG5cbiAgICBpZiAoIXRoaXMuaXNWZWM0ICYmIHRoaXMuaXNWZWN0b3JBKSB7XG4gICAgICAvLyBGb3IgbWFrZVZlY3Rvck1hdHJpeFByb2R1Y3RTb3VyY2VcbiAgICAgIHRoaXMuZWxlbWVudHNQZXJUaHJlYWQgPSBbMSwgMSwgMV07XG4gICAgICB0aGlzLndvcmtHcm91cFNpemUgPSBbMzIsIDEsIDFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB3b3JrR3JvdXBJbmZvID0gY29tcHV0ZVdvcmtHcm91cEluZm9Gb3JNYXRNdWwoXG4gICAgICAgICAgb3V0cHV0U2hhcGVbMV0sIGRpbUlubmVyLCBvdXRwdXRTaGFwZVsyXSwgdHJhbnNwb3NlQSk7XG4gICAgICB0aGlzLndvcmtHcm91cFNpemUgPSB3b3JrR3JvdXBJbmZvLndvcmtHcm91cFNpemU7XG4gICAgICB0aGlzLmVsZW1lbnRzUGVyVGhyZWFkID0gd29ya0dyb3VwSW5mby5lbGVtZW50c1BlclRocmVhZDtcbiAgICB9XG5cbiAgICB0aGlzLmRpc3BhdGNoID0gY29tcHV0ZURpc3BhdGNoKFxuICAgICAgICB0aGlzLmRpc3BhdGNoTGF5b3V0LCB0aGlzLm91dHB1dFNoYXBlLCB0aGlzLndvcmtHcm91cFNpemUsXG4gICAgICAgIHRoaXMuZWxlbWVudHNQZXJUaHJlYWQpO1xuXG4gICAgY29uc3QgYWRkQmlhcyA9IGJpYXMgIT0gbnVsbDtcbiAgICBjb25zdCBoYXNQcmVsdUFjdGl2YXRpb25XZWlnaHRzID0gcHJlbHVBY3RpdmF0aW9uV2VpZ2h0cyAhPSBudWxsO1xuICAgIGlmIChhZGRCaWFzKSB7XG4gICAgICB0aGlzLnZhcmlhYmxlTmFtZXMucHVzaCgnYmlhcycpO1xuICAgIH1cblxuICAgIGlmIChoYXNQcmVsdUFjdGl2YXRpb25XZWlnaHRzKSB7XG4gICAgICB0aGlzLnZhcmlhYmxlTmFtZXMucHVzaCgncHJlbHVBY3RpdmF0aW9uV2VpZ2h0cycpO1xuICAgIH1cblxuICAgIHRoaXMuc2VxdWVudGlhbEFjY2Vzc0J5VGhyZWFkcyA9IHNlcXVlbnRpYWxBY2Nlc3NCeVRocmVhZHM7XG4gICAgdGhpcy50cmFuc3Bvc2VBID0gdHJhbnNwb3NlQTtcbiAgICB0aGlzLnRyYW5zcG9zZUIgPSB0cmFuc3Bvc2VCO1xuICAgIHRoaXMuYWRkQmlhcyA9IGFkZEJpYXM7XG4gICAgdGhpcy5hY3RpdmF0aW9uID0gYWN0aXZhdGlvbjtcbiAgICB0aGlzLmhhc1ByZWx1QWN0aXZhdGlvbldlaWdodHMgPSBoYXNQcmVsdUFjdGl2YXRpb25XZWlnaHRzO1xuICAgIHRoaXMuYmF0Y2hBRXF1YWxPbmUgPSBiYXRjaEFFcXVhbE9uZTtcbiAgICB0aGlzLmJhdGNoQkVxdWFsT25lID0gYmF0Y2hCRXF1YWxPbmU7XG4gICAgW3RoaXMuZml0QU91dGVyLCB0aGlzLmZpdEJPdXRlciwgdGhpcy5maXRJbm5lcl0gPVxuICAgICAgICB0aGlzLmdldFNoYXBlRml0KG91dHB1dFNoYXBlWzFdLCBvdXRwdXRTaGFwZVsyXSwgZGltSW5uZXIpO1xuICAgIHRoaXMuc2hhZGVyS2V5ID0gYG1hdE11bFBhY2tlZF8ke3RoaXMuZWxlbWVudHNQZXJUaHJlYWR9XyR7dHJhbnNwb3NlQX1fJHtcbiAgICAgICAgdHJhbnNwb3NlQn1fJHt0aGlzLmFjdGl2YXRpb259XyR7dGhpcy5maXRBT3V0ZXJ9XyR7dGhpcy5maXRCT3V0ZXJ9XyR7XG4gICAgICAgIHRoaXMuZml0SW5uZXJ9XyR7dGhpcy5pc1ZlYzR9XyR7dGhpcy5pc1ZlY3RvckF9XyR7XG4gICAgICAgIHRoaXMuYmF0Y2hBRXF1YWxPbmV9XyR7dGhpcy5iYXRjaEJFcXVhbE9uZX1fJHtcbiAgICAgICAgdGhpcy5zZXF1ZW50aWFsQWNjZXNzQnlUaHJlYWRzfWA7XG4gIH1cblxuICBnZXRTaGFwZUZpdChkaW1BT3V0ZXI6IG51bWJlciwgZGltQk91dGVyOiBudW1iZXIsIGRpbUlubmVyOiBudW1iZXIpOlxuICAgICAgYm9vbGVhbltdIHtcbiAgICBjb25zdCB0aWxlQU91dGVyID0gdGhpcy53b3JrR3JvdXBTaXplWzFdICogdGhpcy5lbGVtZW50c1BlclRocmVhZFsxXTtcbiAgICBjb25zdCB0aWxlQk91dGVyID0gdGhpcy53b3JrR3JvdXBTaXplWzBdICogdGhpcy5lbGVtZW50c1BlclRocmVhZFswXTtcblxuICAgIGlmICghdGhpcy5pc1ZlYzQgJiYgdGhpcy5pc1ZlY3RvckEpIHtcbiAgICAgIC8vIEZvciBtYWtlVmVjdG9yTWF0cml4UHJvZHVjdFNvdXJjZVxuICAgICAgdGhpcy50aWxlSW5uZXIgPSB0aGlzLndvcmtHcm91cFNpemVbMF0gKiA0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRpbGVJbm5lciA9IHRpbGVCT3V0ZXI7XG4gICAgfVxuXG4gICAgY29uc3QgZml0QU91dGVyID0gZGltQU91dGVyICUgdGlsZUFPdXRlciA9PT0gMDtcbiAgICBjb25zdCBmaXRCT3V0ZXIgPSBkaW1CT3V0ZXIgJSB0aWxlQk91dGVyID09PSAwO1xuICAgIGNvbnN0IGZpdElubmVyID0gZGltSW5uZXIgJSB0aGlzLnRpbGVJbm5lciA9PT0gMDtcbiAgICByZXR1cm4gW2ZpdEFPdXRlciwgZml0Qk91dGVyLCBmaXRJbm5lcl07XG4gIH1cblxuICBnZXRVc2VyQ29kZSgpOiBzdHJpbmcge1xuICAgIGNvbnN0IHVzZXJDb2RlID0gYFxuICAgICAgJHtcbiAgICAgICAgYWN0aXZhdGlvbkZuU25pcHBldChcbiAgICAgICAgICAgIHRoaXMuYWN0aXZhdGlvbiwgdGhpcy5oYXNQcmVsdUFjdGl2YXRpb25XZWlnaHRzLCB0aGlzLmlzVmVjNCl9XG4gICAgICAke1xuICAgICAgICBtYXRNdWxSZWFkV3JpdGVGblNvdXJjZShcbiAgICAgICAgICAgIHRoaXMuYWRkQmlhcywgdGhpcy5hY3RpdmF0aW9uLCB0aGlzLmJhdGNoQUVxdWFsT25lLFxuICAgICAgICAgICAgdGhpcy5iYXRjaEJFcXVhbE9uZSxcbiAgICAgICAgICAgIGZhbHNlIC8qIHRyYW5zcG9zZUEgaXMgaW1wbGVtZW50ZWQgaW4gbWFrZU1hdE11bFBhY2tlZFNvdXJjZSAqLyxcbiAgICAgICAgICAgIHRoaXMudHJhbnNwb3NlQiwgdGhpcy5maXRBT3V0ZXIsIHRoaXMuZml0Qk91dGVyLCB0aGlzLmZpdElubmVyLFxuICAgICAgICAgICAgdGhpcy5pc1ZlYzQgPyA0IDogMSl9XG4gICAgICAke1xuICAgICAgICB0aGlzLmlzVmVjNCA/XG4gICAgICAgICAgICBtYWtlTWF0TXVsUGFja2VkVmVjNFNvdXJjZShcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnRzUGVyVGhyZWFkLCB0aGlzLndvcmtHcm91cFNpemUsIHRoaXMudHJhbnNwb3NlQSxcbiAgICAgICAgICAgICAgICB0aGlzLnRpbGVJbm5lciwgZmFsc2UsIG51bGwsIHRoaXMuaXNWZWN0b3JBKSA6XG4gICAgICAgICAgICAodGhpcy5pc1ZlY3RvckEgPyBtYWtlVmVjdG9yTWF0cml4UHJvZHVjdFNvdXJjZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLndvcmtHcm91cFNpemUsIHRoaXMudHJhbnNwb3NlQSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFrZU1hdE11bFBhY2tlZFNvdXJjZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnRzUGVyVGhyZWFkLCB0aGlzLndvcmtHcm91cFNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFuc3Bvc2VBLCB0aGlzLnRpbGVJbm5lciwgZmFsc2UsIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXF1ZW50aWFsQWNjZXNzQnlUaHJlYWRzKSl9XG4gICAgYDtcbiAgICByZXR1cm4gdXNlckNvZGU7XG4gIH1cbn1cbiJdfQ==