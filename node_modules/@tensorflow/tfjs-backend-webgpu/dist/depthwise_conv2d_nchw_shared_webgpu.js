/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import { activationFnSnippet, biasActivationSnippet } from './activation_util';
import { getWorkGroupSizeString } from './webgpu_program';
import { computeDispatch } from './webgpu_util';
export class DepthwiseConv2DNCHWSharedProgram {
    constructor(outputShape, filterHeight, filterWidth, addBias = false, activation = null, hasPreluActivation = false) {
        this.variableNames = ['x', 'W'];
        this.uniforms = `pad : vec2<i32>, inDims : vec2<i32>,`;
        this.workGroupSize = [16, 16, 1];
        this.outputShape = outputShape;
        this.dispatchLayout = { x: [3], y: [2], z: [0, 1] };
        this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workGroupSize);
        if (addBias) {
            this.variableNames.push('bias');
        }
        if (hasPreluActivation) {
            this.variableNames.push('preluActivationWeights');
        }
        this.addBias = addBias;
        this.activation = activation;
        this.hasPreluActivation = hasPreluActivation;
        this.filterHeight = filterHeight;
        this.filterWidth = filterWidth;
        this.shaderKey = `depthwiseNCHW_${this.activation}_${this.filterHeight}_${this.filterWidth}`;
    }
    getUserCode() {
        const filterSize = this.filterWidth * this.filterHeight;
        const workGroupSize = this.workGroupSize[0] * this.workGroupSize[1] * this.workGroupSize[2];
        const tileAHeight = this.workGroupSize[1] + this.filterHeight - 1;
        const tileAWidth = this.workGroupSize[0] + this.filterWidth - 1;
        const userCode = `
      ${activationFnSnippet(this.activation, this.hasPreluActivation, false, 4)}

      var<workgroup> mm_Asub : array<array<f32, ${tileAWidth}>, ${tileAHeight}>;
      var<workgroup> mm_Bsub : array<array<f32, ${this.filterWidth}>, ${this.filterHeight}>;
      fn readX(batch : i32, channel : i32, row : i32, col : i32) -> f32 {
        var value = 0.0;
        if (row >=0 && row < uniforms.inDims[0] && col >=0 && col < uniforms.inDims[1])
        {
          value = getX(batch, channel, row, col);
        }
        return value;
      }

      ${getWorkGroupSizeString()}
      fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,
                @builtin(global_invocation_id) GlobalId : vec3<u32>,
                @builtin(local_invocation_index) LocalIndex: u32,
                @builtin(num_workgroups) NumWorkgroups: vec3<u32>) {
        localId = LocalId;
        globalId = GlobalId;
        let localIndex = i32(LocalIndex);
        numWorkgroups = NumWorkgroups;
        let coords = getOutputCoords();
        let batch = coords[0];
        let xRCCorner = vec2<i32>(coords.zw) - uniforms.pad;
        let channelMul = uniforms.wShape[3];
        let d1 = coords[1] / channelMul;
        let q = coords[1] % channelMul;

        let inputRowStart = xRCCorner.x;
        let inputColStart = xRCCorner.y;

        let localRow = i32(localId.y);
        let localCol = i32(localId.x);

        // Load one tile of X into local memory.
        for (var inputRow = localRow; inputRow < ${tileAHeight}; inputRow = inputRow + ${this.workGroupSize[1]}) {
          for (var inputCol = localCol; inputCol < ${tileAWidth}; inputCol = inputCol + ${this.workGroupSize[0]}) {
            let rowOffset = inputRow - localRow;
            let colOffset = inputCol - localCol;
            mm_Asub[inputRow][inputCol] = readX(batch, d1, inputRowStart + rowOffset, inputColStart + colOffset);
          }
        }

        // Load one tile of W into local memory.
        var wIndex = localIndex;
        ${filterSize < workGroupSize ?
            `if (wIndex < ${filterSize})` :
            `for(; wIndex < ${filterSize}; wIndex = wIndex + ${workGroupSize})`}

        {
          let wRow = wIndex / ${this.filterWidth};
          let wCol = wIndex % ${this.filterWidth};
          mm_Bsub[wRow][wCol] = getW(wRow, wCol, d1, q);
        }

        workgroupBarrier();

        var value = 0.0;
        for (var wR = 0; wR < ${this.filterHeight}; wR = wR + 1) {
          for (var wC = 0; wC < ${this.filterWidth}; wC = wC + 1) {
            let xVal = mm_Asub[localRow + wR][localCol + wC];
            let wVal = mm_Bsub[wR][wC];
            value = fma(xVal, wVal, value);
          }
        }
        ${biasActivationSnippet(this.addBias, this.activation)}
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `;
        return userCode;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVwdGh3aXNlX2NvbnYyZF9uY2h3X3NoYXJlZF93ZWJncHUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi90ZmpzLWJhY2tlbmQtd2ViZ3B1L3NyYy9kZXB0aHdpc2VfY29udjJkX25jaHdfc2hhcmVkX3dlYmdwdS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFJSCxPQUFPLEVBQUMsbUJBQW1CLEVBQUUscUJBQXFCLEVBQUMsTUFBTSxtQkFBbUIsQ0FBQztBQUM3RSxPQUFPLEVBQUMsc0JBQXNCLEVBQWdCLE1BQU0sa0JBQWtCLENBQUM7QUFDdkUsT0FBTyxFQUFDLGVBQWUsRUFBQyxNQUFNLGVBQWUsQ0FBQztBQUU5QyxNQUFNLE9BQU8sZ0NBQWdDO0lBYzNDLFlBQ0ksV0FBcUIsRUFBRSxZQUFvQixFQUFFLFdBQW1CLEVBQ2hFLE9BQU8sR0FBRyxLQUFLLEVBQUUsYUFBc0MsSUFBSSxFQUMzRCxrQkFBa0IsR0FBRyxLQUFLO1FBWjlCLGtCQUFhLEdBQUcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFDM0IsYUFBUSxHQUFHLHNDQUFzQyxDQUFDO1FBQ2xELGtCQUFhLEdBQTZCLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQztRQVdwRCxJQUFJLENBQUMsV0FBVyxHQUFHLFdBQVcsQ0FBQztRQUMvQixJQUFJLENBQUMsY0FBYyxHQUFHLEVBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFDLENBQUM7UUFDbEQsSUFBSSxDQUFDLFFBQVEsR0FBRyxlQUFlLENBQzNCLElBQUksQ0FBQyxjQUFjLEVBQUUsSUFBSSxDQUFDLFdBQVcsRUFBRSxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7UUFFL0QsSUFBSSxPQUFPLEVBQUU7WUFDWCxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztTQUNqQztRQUNELElBQUksa0JBQWtCLEVBQUU7WUFDdEIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsd0JBQXdCLENBQUMsQ0FBQztTQUNuRDtRQUVELElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDO1FBQ3ZCLElBQUksQ0FBQyxVQUFVLEdBQUcsVUFBVSxDQUFDO1FBQzdCLElBQUksQ0FBQyxrQkFBa0IsR0FBRyxrQkFBa0IsQ0FBQztRQUM3QyxJQUFJLENBQUMsWUFBWSxHQUFHLFlBQVksQ0FBQztRQUNqQyxJQUFJLENBQUMsV0FBVyxHQUFHLFdBQVcsQ0FBQztRQUMvQixJQUFJLENBQUMsU0FBUyxHQUFHLGlCQUFpQixJQUFJLENBQUMsVUFBVSxJQUFJLElBQUksQ0FBQyxZQUFZLElBQ2xFLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztJQUN6QixDQUFDO0lBRUQsV0FBVztRQUNULE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQztRQUN4RCxNQUFNLGFBQWEsR0FDZixJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUMxRSxNQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxZQUFZLEdBQUcsQ0FBQyxDQUFDO1FBQ2xFLE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLFdBQVcsR0FBRyxDQUFDLENBQUM7UUFFaEUsTUFBTSxRQUFRLEdBQUc7UUFDYixtQkFBbUIsQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxrQkFBa0IsRUFBRSxLQUFLLEVBQUUsQ0FBQyxDQUFDOztrREFFN0IsVUFBVSxNQUFNLFdBQVc7a0RBQzNCLElBQUksQ0FBQyxXQUFXLE1BQzFELElBQUksQ0FBQyxZQUFZOzs7Ozs7Ozs7O1FBVWpCLHNCQUFzQixFQUFFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzttREF3QnhCLFdBQVcsMkJBQTJCLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDO3FEQUUzRCxVQUFVLDJCQUEyQixJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQzs7Ozs7Ozs7O1VBVTFELFVBQVUsR0FBRyxhQUFhLENBQUMsQ0FBQztZQUN4QixnQkFBZ0IsVUFBVSxHQUFHLENBQUMsQ0FBQztZQUMvQixrQkFBa0IsVUFBVSx1QkFBdUIsYUFBYSxHQUFHOzs7Z0NBRy9DLElBQUksQ0FBQyxXQUFXO2dDQUNoQixJQUFJLENBQUMsV0FBVzs7Ozs7OztnQ0FPaEIsSUFBSSxDQUFDLFlBQVk7a0NBQ2YsSUFBSSxDQUFDLFdBQVc7Ozs7OztVQU14QyxxQkFBcUIsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxVQUFVLENBQUM7Ozs7O0tBS3pELENBQUM7UUFDRixPQUFPLFFBQVEsQ0FBQztJQUNsQixDQUFDO0NBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmltcG9ydCB7YmFja2VuZF91dGlsfSBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xuXG5pbXBvcnQge2FjdGl2YXRpb25GblNuaXBwZXQsIGJpYXNBY3RpdmF0aW9uU25pcHBldH0gZnJvbSAnLi9hY3RpdmF0aW9uX3V0aWwnO1xuaW1wb3J0IHtnZXRXb3JrR3JvdXBTaXplU3RyaW5nLCBXZWJHUFVQcm9ncmFtfSBmcm9tICcuL3dlYmdwdV9wcm9ncmFtJztcbmltcG9ydCB7Y29tcHV0ZURpc3BhdGNofSBmcm9tICcuL3dlYmdwdV91dGlsJztcblxuZXhwb3J0IGNsYXNzIERlcHRod2lzZUNvbnYyRE5DSFdTaGFyZWRQcm9ncmFtIGltcGxlbWVudHMgV2ViR1BVUHJvZ3JhbSB7XG4gIG91dHB1dFNoYXBlOiBudW1iZXJbXTtcbiAgc2hhZGVyS2V5OiBzdHJpbmc7XG4gIGRpc3BhdGNoTGF5b3V0OiB7eDogbnVtYmVyW10sIHk6IG51bWJlcltdLCB6OiBudW1iZXJbXX07XG4gIGRpc3BhdGNoOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG4gIHZhcmlhYmxlTmFtZXMgPSBbJ3gnLCAnVyddO1xuICB1bmlmb3JtcyA9IGBwYWQgOiB2ZWMyPGkzMj4sIGluRGltcyA6IHZlYzI8aTMyPixgO1xuICB3b3JrR3JvdXBTaXplOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0gPSBbMTYsIDE2LCAxXTtcbiAgYWRkQmlhczogYm9vbGVhbjtcbiAgYWN0aXZhdGlvbjogYmFja2VuZF91dGlsLkFjdGl2YXRpb247XG4gIGhhc1ByZWx1QWN0aXZhdGlvbjogYm9vbGVhbjtcbiAgZmlsdGVySGVpZ2h0OiBudW1iZXI7XG4gIGZpbHRlcldpZHRoOiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgICBvdXRwdXRTaGFwZTogbnVtYmVyW10sIGZpbHRlckhlaWdodDogbnVtYmVyLCBmaWx0ZXJXaWR0aDogbnVtYmVyLFxuICAgICAgYWRkQmlhcyA9IGZhbHNlLCBhY3RpdmF0aW9uOiBiYWNrZW5kX3V0aWwuQWN0aXZhdGlvbiA9IG51bGwsXG4gICAgICBoYXNQcmVsdUFjdGl2YXRpb24gPSBmYWxzZSkge1xuICAgIHRoaXMub3V0cHV0U2hhcGUgPSBvdXRwdXRTaGFwZTtcbiAgICB0aGlzLmRpc3BhdGNoTGF5b3V0ID0ge3g6IFszXSwgeTogWzJdLCB6OiBbMCwgMV19O1xuICAgIHRoaXMuZGlzcGF0Y2ggPSBjb21wdXRlRGlzcGF0Y2goXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hMYXlvdXQsIHRoaXMub3V0cHV0U2hhcGUsIHRoaXMud29ya0dyb3VwU2l6ZSk7XG5cbiAgICBpZiAoYWRkQmlhcykge1xuICAgICAgdGhpcy52YXJpYWJsZU5hbWVzLnB1c2goJ2JpYXMnKTtcbiAgICB9XG4gICAgaWYgKGhhc1ByZWx1QWN0aXZhdGlvbikge1xuICAgICAgdGhpcy52YXJpYWJsZU5hbWVzLnB1c2goJ3ByZWx1QWN0aXZhdGlvbldlaWdodHMnKTtcbiAgICB9XG5cbiAgICB0aGlzLmFkZEJpYXMgPSBhZGRCaWFzO1xuICAgIHRoaXMuYWN0aXZhdGlvbiA9IGFjdGl2YXRpb247XG4gICAgdGhpcy5oYXNQcmVsdUFjdGl2YXRpb24gPSBoYXNQcmVsdUFjdGl2YXRpb247XG4gICAgdGhpcy5maWx0ZXJIZWlnaHQgPSBmaWx0ZXJIZWlnaHQ7XG4gICAgdGhpcy5maWx0ZXJXaWR0aCA9IGZpbHRlcldpZHRoO1xuICAgIHRoaXMuc2hhZGVyS2V5ID0gYGRlcHRod2lzZU5DSFdfJHt0aGlzLmFjdGl2YXRpb259XyR7dGhpcy5maWx0ZXJIZWlnaHR9XyR7XG4gICAgICAgIHRoaXMuZmlsdGVyV2lkdGh9YDtcbiAgfVxuXG4gIGdldFVzZXJDb2RlKCk6IHN0cmluZyB7XG4gICAgY29uc3QgZmlsdGVyU2l6ZSA9IHRoaXMuZmlsdGVyV2lkdGggKiB0aGlzLmZpbHRlckhlaWdodDtcbiAgICBjb25zdCB3b3JrR3JvdXBTaXplID1cbiAgICAgICAgdGhpcy53b3JrR3JvdXBTaXplWzBdICogdGhpcy53b3JrR3JvdXBTaXplWzFdICogdGhpcy53b3JrR3JvdXBTaXplWzJdO1xuICAgIGNvbnN0IHRpbGVBSGVpZ2h0ID0gdGhpcy53b3JrR3JvdXBTaXplWzFdICsgdGhpcy5maWx0ZXJIZWlnaHQgLSAxO1xuICAgIGNvbnN0IHRpbGVBV2lkdGggPSB0aGlzLndvcmtHcm91cFNpemVbMF0gKyB0aGlzLmZpbHRlcldpZHRoIC0gMTtcblxuICAgIGNvbnN0IHVzZXJDb2RlID0gYFxuICAgICAgJHthY3RpdmF0aW9uRm5TbmlwcGV0KHRoaXMuYWN0aXZhdGlvbiwgdGhpcy5oYXNQcmVsdUFjdGl2YXRpb24sIGZhbHNlLCA0KX1cblxuICAgICAgdmFyPHdvcmtncm91cD4gbW1fQXN1YiA6IGFycmF5PGFycmF5PGYzMiwgJHt0aWxlQVdpZHRofT4sICR7dGlsZUFIZWlnaHR9PjtcbiAgICAgIHZhcjx3b3JrZ3JvdXA+IG1tX0JzdWIgOiBhcnJheTxhcnJheTxmMzIsICR7dGhpcy5maWx0ZXJXaWR0aH0+LCAke1xuICAgICAgICB0aGlzLmZpbHRlckhlaWdodH0+O1xuICAgICAgZm4gcmVhZFgoYmF0Y2ggOiBpMzIsIGNoYW5uZWwgOiBpMzIsIHJvdyA6IGkzMiwgY29sIDogaTMyKSAtPiBmMzIge1xuICAgICAgICB2YXIgdmFsdWUgPSAwLjA7XG4gICAgICAgIGlmIChyb3cgPj0wICYmIHJvdyA8IHVuaWZvcm1zLmluRGltc1swXSAmJiBjb2wgPj0wICYmIGNvbCA8IHVuaWZvcm1zLmluRGltc1sxXSlcbiAgICAgICAge1xuICAgICAgICAgIHZhbHVlID0gZ2V0WChiYXRjaCwgY2hhbm5lbCwgcm93LCBjb2wpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgJHtnZXRXb3JrR3JvdXBTaXplU3RyaW5nKCl9XG4gICAgICBmbiBfc3RhcnQoQGJ1aWx0aW4obG9jYWxfaW52b2NhdGlvbl9pZCkgTG9jYWxJZCA6IHZlYzM8dTMyPixcbiAgICAgICAgICAgICAgICBAYnVpbHRpbihnbG9iYWxfaW52b2NhdGlvbl9pZCkgR2xvYmFsSWQgOiB2ZWMzPHUzMj4sXG4gICAgICAgICAgICAgICAgQGJ1aWx0aW4obG9jYWxfaW52b2NhdGlvbl9pbmRleCkgTG9jYWxJbmRleDogdTMyLFxuICAgICAgICAgICAgICAgIEBidWlsdGluKG51bV93b3JrZ3JvdXBzKSBOdW1Xb3JrZ3JvdXBzOiB2ZWMzPHUzMj4pIHtcbiAgICAgICAgbG9jYWxJZCA9IExvY2FsSWQ7XG4gICAgICAgIGdsb2JhbElkID0gR2xvYmFsSWQ7XG4gICAgICAgIGxldCBsb2NhbEluZGV4ID0gaTMyKExvY2FsSW5kZXgpO1xuICAgICAgICBudW1Xb3JrZ3JvdXBzID0gTnVtV29ya2dyb3VwcztcbiAgICAgICAgbGV0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICBsZXQgYmF0Y2ggPSBjb29yZHNbMF07XG4gICAgICAgIGxldCB4UkNDb3JuZXIgPSB2ZWMyPGkzMj4oY29vcmRzLnp3KSAtIHVuaWZvcm1zLnBhZDtcbiAgICAgICAgbGV0IGNoYW5uZWxNdWwgPSB1bmlmb3Jtcy53U2hhcGVbM107XG4gICAgICAgIGxldCBkMSA9IGNvb3Jkc1sxXSAvIGNoYW5uZWxNdWw7XG4gICAgICAgIGxldCBxID0gY29vcmRzWzFdICUgY2hhbm5lbE11bDtcblxuICAgICAgICBsZXQgaW5wdXRSb3dTdGFydCA9IHhSQ0Nvcm5lci54O1xuICAgICAgICBsZXQgaW5wdXRDb2xTdGFydCA9IHhSQ0Nvcm5lci55O1xuXG4gICAgICAgIGxldCBsb2NhbFJvdyA9IGkzMihsb2NhbElkLnkpO1xuICAgICAgICBsZXQgbG9jYWxDb2wgPSBpMzIobG9jYWxJZC54KTtcblxuICAgICAgICAvLyBMb2FkIG9uZSB0aWxlIG9mIFggaW50byBsb2NhbCBtZW1vcnkuXG4gICAgICAgIGZvciAodmFyIGlucHV0Um93ID0gbG9jYWxSb3c7IGlucHV0Um93IDwgJHtcbiAgICAgICAgdGlsZUFIZWlnaHR9OyBpbnB1dFJvdyA9IGlucHV0Um93ICsgJHt0aGlzLndvcmtHcm91cFNpemVbMV19KSB7XG4gICAgICAgICAgZm9yICh2YXIgaW5wdXRDb2wgPSBsb2NhbENvbDsgaW5wdXRDb2wgPCAke1xuICAgICAgICB0aWxlQVdpZHRofTsgaW5wdXRDb2wgPSBpbnB1dENvbCArICR7dGhpcy53b3JrR3JvdXBTaXplWzBdfSkge1xuICAgICAgICAgICAgbGV0IHJvd09mZnNldCA9IGlucHV0Um93IC0gbG9jYWxSb3c7XG4gICAgICAgICAgICBsZXQgY29sT2Zmc2V0ID0gaW5wdXRDb2wgLSBsb2NhbENvbDtcbiAgICAgICAgICAgIG1tX0FzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IHJlYWRYKGJhdGNoLCBkMSwgaW5wdXRSb3dTdGFydCArIHJvd09mZnNldCwgaW5wdXRDb2xTdGFydCArIGNvbE9mZnNldCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gTG9hZCBvbmUgdGlsZSBvZiBXIGludG8gbG9jYWwgbWVtb3J5LlxuICAgICAgICB2YXIgd0luZGV4ID0gbG9jYWxJbmRleDtcbiAgICAgICAgJHtcbiAgICAgICAgZmlsdGVyU2l6ZSA8IHdvcmtHcm91cFNpemUgP1xuICAgICAgICAgICAgYGlmICh3SW5kZXggPCAke2ZpbHRlclNpemV9KWAgOlxuICAgICAgICAgICAgYGZvcig7IHdJbmRleCA8ICR7ZmlsdGVyU2l6ZX07IHdJbmRleCA9IHdJbmRleCArICR7d29ya0dyb3VwU2l6ZX0pYH1cblxuICAgICAgICB7XG4gICAgICAgICAgbGV0IHdSb3cgPSB3SW5kZXggLyAke3RoaXMuZmlsdGVyV2lkdGh9O1xuICAgICAgICAgIGxldCB3Q29sID0gd0luZGV4ICUgJHt0aGlzLmZpbHRlcldpZHRofTtcbiAgICAgICAgICBtbV9Cc3ViW3dSb3ddW3dDb2xdID0gZ2V0Vyh3Um93LCB3Q29sLCBkMSwgcSk7XG4gICAgICAgIH1cblxuICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgICAgdmFyIHZhbHVlID0gMC4wO1xuICAgICAgICBmb3IgKHZhciB3UiA9IDA7IHdSIDwgJHt0aGlzLmZpbHRlckhlaWdodH07IHdSID0gd1IgKyAxKSB7XG4gICAgICAgICAgZm9yICh2YXIgd0MgPSAwOyB3QyA8ICR7dGhpcy5maWx0ZXJXaWR0aH07IHdDID0gd0MgKyAxKSB7XG4gICAgICAgICAgICBsZXQgeFZhbCA9IG1tX0FzdWJbbG9jYWxSb3cgKyB3Ul1bbG9jYWxDb2wgKyB3Q107XG4gICAgICAgICAgICBsZXQgd1ZhbCA9IG1tX0JzdWJbd1JdW3dDXTtcbiAgICAgICAgICAgIHZhbHVlID0gZm1hKHhWYWwsIHdWYWwsIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgJHtiaWFzQWN0aXZhdGlvblNuaXBwZXQodGhpcy5hZGRCaWFzLCB0aGlzLmFjdGl2YXRpb24pfVxuICAgICAgICBpZiAoY29vcmRzSW5Cb3VuZHM0RChjb29yZHMsIHVuaWZvcm1zLm91dFNoYXBlKSkge1xuICAgICAgICAgIHNldE91dHB1dEF0Q29vcmRzKGNvb3Jkc1swXSwgY29vcmRzWzFdLCBjb29yZHNbMl0sIGNvb3Jkc1szXSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgYDtcbiAgICByZXR1cm4gdXNlckNvZGU7XG4gIH1cbn1cbiJdfQ==