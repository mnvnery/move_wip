/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import { activationFnSnippet } from './activation_util';
import { matMulReadWriteFnSource } from './matmul_packed_webgpu';
import { getMainHeaderString as main } from './webgpu_program';
export function makeMatMulSmallOutputSizeSource(workGroupSize) {
    const tileAOuter = workGroupSize[1];
    const tileBOuter = workGroupSize[0];
    const tileInner = tileAOuter > tileBOuter ? tileAOuter : tileBOuter;
    return `
  var<workgroup> mm_Asub : array<array<f32, ${tileInner}>, ${tileAOuter}>;
  var<workgroup> mm_Bsub : array<array<f32, ${tileBOuter}>, ${tileInner}>;

  // If the output size is small for matrix multiplication, avoid to use vec4
  // and handle some elements per thread to optimally utilize the ALU.
  // Read data from global memory to registers firstly, then store them into
  // shared memory, so it is instruction-Level parallelism for arithmetic
  // operations and others handle IO operations between barrier api, makes ALU
  // and load/store units work simultaneously, could improves the performance.
  ${main()} {
    let tileRow = i32(localId.y);
    let tileCol = i32(localId.x);
    let globalRow = i32(globalId.y);
    let globalCol = i32(globalId.x);
    let batch = i32(globalId.z);

    // uniforms.dimInner should be greater than 0.
    let numTiles = (uniforms.dimInner - 1) / ${tileInner} + 1;
    var acc = 0.0;

    var globalColA = tileCol;
    var globalRowB = 0;
    var regA = mm_readA(batch, globalRow, globalColA);
    var regB0 = mm_readB(batch, globalRowB + 2 * tileRow, globalCol);
    var regB1 = mm_readB(batch, globalRowB + 2 * tileRow + 1, globalCol);
    globalColA = globalColA + ${tileInner};
    globalRowB = globalRowB + ${tileInner};

    for (var t = 0; t < numTiles; t = t + 1) {
      mm_Asub[tileRow][tileCol] = regA;
      mm_Bsub[2 * tileRow][tileCol] = regB0;
      mm_Bsub[2 * tileRow + 1][tileCol] = regB1;

      workgroupBarrier();

      regA = mm_readA(batch, globalRow, globalColA);
      regB0 = mm_readB(batch, globalRowB + 2 * tileRow, globalCol);
      regB1 = mm_readB(batch, globalRowB + 2 * tileRow + 1, globalCol);
      globalColA = globalColA + ${tileInner};
      globalRowB = globalRowB + ${tileInner};

      for (var k = 0; k < ${tileInner}; k = k + 1) {
        acc = acc + mm_Asub[tileRow][k] * mm_Bsub[k][tileCol];
      }
      workgroupBarrier();
    }

    mm_write(batch, globalRow, globalCol, acc);
  }
  `;
}
export class MatMulSmallOutputSizeProgram {
    constructor(aShape, bShape, outputShape, transposeA = false, transposeB = false, bias = null, activation = null, preluActivationWeights = null) {
        this.variableNames = ['A', 'B'];
        this.uniforms = `dimAOuter : i32, dimBOuter : i32, dimInner : i32,`;
        this.workGroupSize = [16, 8, 1];
        this.outputShape = outputShape;
        this.dispatchLayout = { x: [2], y: [1], z: [0] };
        this.dispatch = [
            Math.ceil(outputShape[2] / this.workGroupSize[0]),
            Math.ceil(outputShape[1] / this.workGroupSize[1]), outputShape[0]
        ];
        const addBias = bias != null;
        if (addBias) {
            this.variableNames.push('bias');
        }
        const hasPreluActivationWeights = preluActivationWeights != null;
        if (hasPreluActivationWeights) {
            this.variableNames.push('preluActivationWeights');
        }
        this.transposeA = transposeA;
        this.transposeB = transposeB;
        this.addBias = addBias;
        this.activation = activation;
        this.hasPreluActivationWeights = hasPreluActivationWeights;
        this.batchAEqualOne = aShape[0] === 1;
        this.batchBEqualOne = bShape[0] === 1;
        this.shaderKey = `matMulSmallOutputSize_${this.activation}_${transposeA}_${transposeB}_${this.batchAEqualOne}_${this.batchBEqualOne}`;
    }
    getUserCode() {
        const userCode = `
      ${activationFnSnippet(this.activation, this.hasPreluActivationWeights)}
      ${matMulReadWriteFnSource(this.addBias, this.activation, this.batchAEqualOne, this.batchBEqualOne, this.transposeA, this.transposeB)}
      ${makeMatMulSmallOutputSizeSource(this.workGroupSize)}
    `;
        return userCode;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWF0bXVsX3NtYWxsX291dHB1dF9zaXplX3dlYmdwdS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3RmanMtYmFja2VuZC13ZWJncHUvc3JjL21hdG11bF9zbWFsbF9vdXRwdXRfc2l6ZV93ZWJncHUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBR0gsT0FBTyxFQUFDLG1CQUFtQixFQUFDLE1BQU0sbUJBQW1CLENBQUM7QUFDdEQsT0FBTyxFQUFDLHVCQUF1QixFQUFDLE1BQU0sd0JBQXdCLENBQUM7QUFDL0QsT0FBTyxFQUFDLG1CQUFtQixJQUFJLElBQUksRUFBZ0IsTUFBTSxrQkFBa0IsQ0FBQztBQUU1RSxNQUFNLFVBQVUsK0JBQStCLENBQzNDLGFBQXVDO0lBQ3pDLE1BQU0sVUFBVSxHQUFHLGFBQWEsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNwQyxNQUFNLFVBQVUsR0FBRyxhQUFhLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDcEMsTUFBTSxTQUFTLEdBQUcsVUFBVSxHQUFHLFVBQVUsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUM7SUFDcEUsT0FBTzs4Q0FDcUMsU0FBUyxNQUFNLFVBQVU7OENBQ3pCLFVBQVUsTUFBTSxTQUFTOzs7Ozs7OztJQVFuRSxJQUFJLEVBQUU7Ozs7Ozs7OytDQVFxQyxTQUFTOzs7Ozs7OztnQ0FReEIsU0FBUztnQ0FDVCxTQUFTOzs7Ozs7Ozs7Ozs7a0NBWVAsU0FBUztrQ0FDVCxTQUFTOzs0QkFFZixTQUFTOzs7Ozs7OztHQVFsQyxDQUFDO0FBQ0osQ0FBQztBQUVELE1BQU0sT0FBTyw0QkFBNEI7SUFnQnZDLFlBQ0ksTUFBZ0MsRUFBRSxNQUFnQyxFQUNsRSxXQUFxQyxFQUFFLFVBQVUsR0FBRyxLQUFLLEVBQ3pELFVBQVUsR0FBRyxLQUFLLEVBQUUsT0FBbUIsSUFBSSxFQUMzQyxhQUFzQyxJQUFJLEVBQzFDLHlCQUFxQyxJQUFJO1FBaEI3QyxrQkFBYSxHQUFHLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBQzNCLGFBQVEsR0FBRyxtREFBbUQsQ0FBQztRQUMvRCxrQkFBYSxHQUE2QixDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFlbkQsSUFBSSxDQUFDLFdBQVcsR0FBRyxXQUFXLENBQUM7UUFFL0IsSUFBSSxDQUFDLGNBQWMsR0FBRyxFQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFDLENBQUM7UUFDL0MsSUFBSSxDQUFDLFFBQVEsR0FBRztZQUNkLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDakQsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLFdBQVcsQ0FBQyxDQUFDLENBQUM7U0FDbEUsQ0FBQztRQUVGLE1BQU0sT0FBTyxHQUFHLElBQUksSUFBSSxJQUFJLENBQUM7UUFDN0IsSUFBSSxPQUFPLEVBQUU7WUFDWCxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztTQUNqQztRQUVELE1BQU0seUJBQXlCLEdBQUcsc0JBQXNCLElBQUksSUFBSSxDQUFDO1FBQ2pFLElBQUkseUJBQXlCLEVBQUU7WUFDN0IsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsd0JBQXdCLENBQUMsQ0FBQztTQUNuRDtRQUVELElBQUksQ0FBQyxVQUFVLEdBQUcsVUFBVSxDQUFDO1FBQzdCLElBQUksQ0FBQyxVQUFVLEdBQUcsVUFBVSxDQUFDO1FBQzdCLElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDO1FBQ3ZCLElBQUksQ0FBQyxVQUFVLEdBQUcsVUFBVSxDQUFDO1FBQzdCLElBQUksQ0FBQyx5QkFBeUIsR0FBRyx5QkFBeUIsQ0FBQztRQUMzRCxJQUFJLENBQUMsY0FBYyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDdEMsSUFBSSxDQUFDLGNBQWMsR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ3RDLElBQUksQ0FBQyxTQUFTLEdBQUcseUJBQXlCLElBQUksQ0FBQyxVQUFVLElBQUksVUFBVSxJQUNuRSxVQUFVLElBQUksSUFBSSxDQUFDLGNBQWMsSUFBSSxJQUFJLENBQUMsY0FBYyxFQUFFLENBQUM7SUFDakUsQ0FBQztJQUVELFdBQVc7UUFDVCxNQUFNLFFBQVEsR0FBRztRQUNiLG1CQUFtQixDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLHlCQUF5QixDQUFDO1FBRXBFLHVCQUF1QixDQUNuQixJQUFJLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLGNBQWMsRUFDbEQsSUFBSSxDQUFDLGNBQWMsRUFBRSxJQUFJLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxVQUFVLENBQUM7UUFDMUQsK0JBQStCLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQztLQUN0RCxDQUFDO1FBQ0YsT0FBTyxRQUFRLENBQUM7SUFDbEIsQ0FBQztDQUNGIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG5pbXBvcnQge2JhY2tlbmRfdXRpbCwgVGVuc29ySW5mb30gZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcbmltcG9ydCB7YWN0aXZhdGlvbkZuU25pcHBldH0gZnJvbSAnLi9hY3RpdmF0aW9uX3V0aWwnO1xuaW1wb3J0IHttYXRNdWxSZWFkV3JpdGVGblNvdXJjZX0gZnJvbSAnLi9tYXRtdWxfcGFja2VkX3dlYmdwdSc7XG5pbXBvcnQge2dldE1haW5IZWFkZXJTdHJpbmcgYXMgbWFpbiwgV2ViR1BVUHJvZ3JhbX0gZnJvbSAnLi93ZWJncHVfcHJvZ3JhbSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBtYWtlTWF0TXVsU21hbGxPdXRwdXRTaXplU291cmNlKFxuICAgIHdvcmtHcm91cFNpemU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSk6IHN0cmluZyB7XG4gIGNvbnN0IHRpbGVBT3V0ZXIgPSB3b3JrR3JvdXBTaXplWzFdO1xuICBjb25zdCB0aWxlQk91dGVyID0gd29ya0dyb3VwU2l6ZVswXTtcbiAgY29uc3QgdGlsZUlubmVyID0gdGlsZUFPdXRlciA+IHRpbGVCT3V0ZXIgPyB0aWxlQU91dGVyIDogdGlsZUJPdXRlcjtcbiAgcmV0dXJuIGBcbiAgdmFyPHdvcmtncm91cD4gbW1fQXN1YiA6IGFycmF5PGFycmF5PGYzMiwgJHt0aWxlSW5uZXJ9PiwgJHt0aWxlQU91dGVyfT47XG4gIHZhcjx3b3JrZ3JvdXA+IG1tX0JzdWIgOiBhcnJheTxhcnJheTxmMzIsICR7dGlsZUJPdXRlcn0+LCAke3RpbGVJbm5lcn0+O1xuXG4gIC8vIElmIHRoZSBvdXRwdXQgc2l6ZSBpcyBzbWFsbCBmb3IgbWF0cml4IG11bHRpcGxpY2F0aW9uLCBhdm9pZCB0byB1c2UgdmVjNFxuICAvLyBhbmQgaGFuZGxlIHNvbWUgZWxlbWVudHMgcGVyIHRocmVhZCB0byBvcHRpbWFsbHkgdXRpbGl6ZSB0aGUgQUxVLlxuICAvLyBSZWFkIGRhdGEgZnJvbSBnbG9iYWwgbWVtb3J5IHRvIHJlZ2lzdGVycyBmaXJzdGx5LCB0aGVuIHN0b3JlIHRoZW0gaW50b1xuICAvLyBzaGFyZWQgbWVtb3J5LCBzbyBpdCBpcyBpbnN0cnVjdGlvbi1MZXZlbCBwYXJhbGxlbGlzbSBmb3IgYXJpdGhtZXRpY1xuICAvLyBvcGVyYXRpb25zIGFuZCBvdGhlcnMgaGFuZGxlIElPIG9wZXJhdGlvbnMgYmV0d2VlbiBiYXJyaWVyIGFwaSwgbWFrZXMgQUxVXG4gIC8vIGFuZCBsb2FkL3N0b3JlIHVuaXRzIHdvcmsgc2ltdWx0YW5lb3VzbHksIGNvdWxkIGltcHJvdmVzIHRoZSBwZXJmb3JtYW5jZS5cbiAgJHttYWluKCl9IHtcbiAgICBsZXQgdGlsZVJvdyA9IGkzMihsb2NhbElkLnkpO1xuICAgIGxldCB0aWxlQ29sID0gaTMyKGxvY2FsSWQueCk7XG4gICAgbGV0IGdsb2JhbFJvdyA9IGkzMihnbG9iYWxJZC55KTtcbiAgICBsZXQgZ2xvYmFsQ29sID0gaTMyKGdsb2JhbElkLngpO1xuICAgIGxldCBiYXRjaCA9IGkzMihnbG9iYWxJZC56KTtcblxuICAgIC8vIHVuaWZvcm1zLmRpbUlubmVyIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gMC5cbiAgICBsZXQgbnVtVGlsZXMgPSAodW5pZm9ybXMuZGltSW5uZXIgLSAxKSAvICR7dGlsZUlubmVyfSArIDE7XG4gICAgdmFyIGFjYyA9IDAuMDtcblxuICAgIHZhciBnbG9iYWxDb2xBID0gdGlsZUNvbDtcbiAgICB2YXIgZ2xvYmFsUm93QiA9IDA7XG4gICAgdmFyIHJlZ0EgPSBtbV9yZWFkQShiYXRjaCwgZ2xvYmFsUm93LCBnbG9iYWxDb2xBKTtcbiAgICB2YXIgcmVnQjAgPSBtbV9yZWFkQihiYXRjaCwgZ2xvYmFsUm93QiArIDIgKiB0aWxlUm93LCBnbG9iYWxDb2wpO1xuICAgIHZhciByZWdCMSA9IG1tX3JlYWRCKGJhdGNoLCBnbG9iYWxSb3dCICsgMiAqIHRpbGVSb3cgKyAxLCBnbG9iYWxDb2wpO1xuICAgIGdsb2JhbENvbEEgPSBnbG9iYWxDb2xBICsgJHt0aWxlSW5uZXJ9O1xuICAgIGdsb2JhbFJvd0IgPSBnbG9iYWxSb3dCICsgJHt0aWxlSW5uZXJ9O1xuXG4gICAgZm9yICh2YXIgdCA9IDA7IHQgPCBudW1UaWxlczsgdCA9IHQgKyAxKSB7XG4gICAgICBtbV9Bc3ViW3RpbGVSb3ddW3RpbGVDb2xdID0gcmVnQTtcbiAgICAgIG1tX0JzdWJbMiAqIHRpbGVSb3ddW3RpbGVDb2xdID0gcmVnQjA7XG4gICAgICBtbV9Cc3ViWzIgKiB0aWxlUm93ICsgMV1bdGlsZUNvbF0gPSByZWdCMTtcblxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICByZWdBID0gbW1fcmVhZEEoYmF0Y2gsIGdsb2JhbFJvdywgZ2xvYmFsQ29sQSk7XG4gICAgICByZWdCMCA9IG1tX3JlYWRCKGJhdGNoLCBnbG9iYWxSb3dCICsgMiAqIHRpbGVSb3csIGdsb2JhbENvbCk7XG4gICAgICByZWdCMSA9IG1tX3JlYWRCKGJhdGNoLCBnbG9iYWxSb3dCICsgMiAqIHRpbGVSb3cgKyAxLCBnbG9iYWxDb2wpO1xuICAgICAgZ2xvYmFsQ29sQSA9IGdsb2JhbENvbEEgKyAke3RpbGVJbm5lcn07XG4gICAgICBnbG9iYWxSb3dCID0gZ2xvYmFsUm93QiArICR7dGlsZUlubmVyfTtcblxuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCAke3RpbGVJbm5lcn07IGsgPSBrICsgMSkge1xuICAgICAgICBhY2MgPSBhY2MgKyBtbV9Bc3ViW3RpbGVSb3ddW2tdICogbW1fQnN1YltrXVt0aWxlQ29sXTtcbiAgICAgIH1cbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICB9XG5cbiAgICBtbV93cml0ZShiYXRjaCwgZ2xvYmFsUm93LCBnbG9iYWxDb2wsIGFjYyk7XG4gIH1cbiAgYDtcbn1cblxuZXhwb3J0IGNsYXNzIE1hdE11bFNtYWxsT3V0cHV0U2l6ZVByb2dyYW0gaW1wbGVtZW50cyBXZWJHUFVQcm9ncmFtIHtcbiAgb3V0cHV0U2hhcGU6IG51bWJlcltdO1xuICBzaGFkZXJLZXk6IHN0cmluZztcbiAgZGlzcGF0Y2hMYXlvdXQ6IHt4OiBudW1iZXJbXSwgeTogbnVtYmVyW10sIHo6IG51bWJlcltdfTtcbiAgZGlzcGF0Y2g6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbiAgdmFyaWFibGVOYW1lcyA9IFsnQScsICdCJ107XG4gIHVuaWZvcm1zID0gYGRpbUFPdXRlciA6IGkzMiwgZGltQk91dGVyIDogaTMyLCBkaW1Jbm5lciA6IGkzMixgO1xuICB3b3JrR3JvdXBTaXplOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0gPSBbMTYsIDgsIDFdO1xuICB0cmFuc3Bvc2VBOiBib29sZWFuO1xuICB0cmFuc3Bvc2VCOiBib29sZWFuO1xuICBhZGRCaWFzOiBib29sZWFuO1xuICBhY3RpdmF0aW9uOiBiYWNrZW5kX3V0aWwuQWN0aXZhdGlvbjtcbiAgaGFzUHJlbHVBY3RpdmF0aW9uV2VpZ2h0czogYm9vbGVhbjtcbiAgYmF0Y2hBRXF1YWxPbmU6IGJvb2xlYW47XG4gIGJhdGNoQkVxdWFsT25lOiBib29sZWFuO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgICAgYVNoYXBlOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sIGJTaGFwZTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdLFxuICAgICAgb3V0cHV0U2hhcGU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSwgdHJhbnNwb3NlQSA9IGZhbHNlLFxuICAgICAgdHJhbnNwb3NlQiA9IGZhbHNlLCBiaWFzOiBUZW5zb3JJbmZvID0gbnVsbCxcbiAgICAgIGFjdGl2YXRpb246IGJhY2tlbmRfdXRpbC5BY3RpdmF0aW9uID0gbnVsbCxcbiAgICAgIHByZWx1QWN0aXZhdGlvbldlaWdodHM6IFRlbnNvckluZm8gPSBudWxsKSB7XG4gICAgdGhpcy5vdXRwdXRTaGFwZSA9IG91dHB1dFNoYXBlO1xuXG4gICAgdGhpcy5kaXNwYXRjaExheW91dCA9IHt4OiBbMl0sIHk6IFsxXSwgejogWzBdfTtcbiAgICB0aGlzLmRpc3BhdGNoID0gW1xuICAgICAgTWF0aC5jZWlsKG91dHB1dFNoYXBlWzJdIC8gdGhpcy53b3JrR3JvdXBTaXplWzBdKSxcbiAgICAgIE1hdGguY2VpbChvdXRwdXRTaGFwZVsxXSAvIHRoaXMud29ya0dyb3VwU2l6ZVsxXSksIG91dHB1dFNoYXBlWzBdXG4gICAgXTtcblxuICAgIGNvbnN0IGFkZEJpYXMgPSBiaWFzICE9IG51bGw7XG4gICAgaWYgKGFkZEJpYXMpIHtcbiAgICAgIHRoaXMudmFyaWFibGVOYW1lcy5wdXNoKCdiaWFzJyk7XG4gICAgfVxuXG4gICAgY29uc3QgaGFzUHJlbHVBY3RpdmF0aW9uV2VpZ2h0cyA9IHByZWx1QWN0aXZhdGlvbldlaWdodHMgIT0gbnVsbDtcbiAgICBpZiAoaGFzUHJlbHVBY3RpdmF0aW9uV2VpZ2h0cykge1xuICAgICAgdGhpcy52YXJpYWJsZU5hbWVzLnB1c2goJ3ByZWx1QWN0aXZhdGlvbldlaWdodHMnKTtcbiAgICB9XG5cbiAgICB0aGlzLnRyYW5zcG9zZUEgPSB0cmFuc3Bvc2VBO1xuICAgIHRoaXMudHJhbnNwb3NlQiA9IHRyYW5zcG9zZUI7XG4gICAgdGhpcy5hZGRCaWFzID0gYWRkQmlhcztcbiAgICB0aGlzLmFjdGl2YXRpb24gPSBhY3RpdmF0aW9uO1xuICAgIHRoaXMuaGFzUHJlbHVBY3RpdmF0aW9uV2VpZ2h0cyA9IGhhc1ByZWx1QWN0aXZhdGlvbldlaWdodHM7XG4gICAgdGhpcy5iYXRjaEFFcXVhbE9uZSA9IGFTaGFwZVswXSA9PT0gMTtcbiAgICB0aGlzLmJhdGNoQkVxdWFsT25lID0gYlNoYXBlWzBdID09PSAxO1xuICAgIHRoaXMuc2hhZGVyS2V5ID0gYG1hdE11bFNtYWxsT3V0cHV0U2l6ZV8ke3RoaXMuYWN0aXZhdGlvbn1fJHt0cmFuc3Bvc2VBfV8ke1xuICAgICAgICB0cmFuc3Bvc2VCfV8ke3RoaXMuYmF0Y2hBRXF1YWxPbmV9XyR7dGhpcy5iYXRjaEJFcXVhbE9uZX1gO1xuICB9XG5cbiAgZ2V0VXNlckNvZGUoKTogc3RyaW5nIHtcbiAgICBjb25zdCB1c2VyQ29kZSA9IGBcbiAgICAgICR7YWN0aXZhdGlvbkZuU25pcHBldCh0aGlzLmFjdGl2YXRpb24sIHRoaXMuaGFzUHJlbHVBY3RpdmF0aW9uV2VpZ2h0cyl9XG4gICAgICAke1xuICAgICAgICBtYXRNdWxSZWFkV3JpdGVGblNvdXJjZShcbiAgICAgICAgICAgIHRoaXMuYWRkQmlhcywgdGhpcy5hY3RpdmF0aW9uLCB0aGlzLmJhdGNoQUVxdWFsT25lLFxuICAgICAgICAgICAgdGhpcy5iYXRjaEJFcXVhbE9uZSwgdGhpcy50cmFuc3Bvc2VBLCB0aGlzLnRyYW5zcG9zZUIpfVxuICAgICAgJHttYWtlTWF0TXVsU21hbGxPdXRwdXRTaXplU291cmNlKHRoaXMud29ya0dyb3VwU2l6ZSl9XG4gICAgYDtcbiAgICByZXR1cm4gdXNlckNvZGU7XG4gIH1cbn1cbiJdfQ==