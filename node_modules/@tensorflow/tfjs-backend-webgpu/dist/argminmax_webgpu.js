/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import { backend_util, util } from '@tensorflow/tfjs-core';
import { getCoordsXYZ, getMainHeaderString as main } from './webgpu_program';
import { computeDispatch, flatDispatchLayout } from './webgpu_util';
export class ArgMinMaxProgram {
    constructor(inputShape, axis, reduceType) {
        this.workGroupSize = [64, 1, 1];
        this.variableNames = ['x'];
        this.uniforms = 'infinityValue : f32,';
        this.size = true;
        const axes = [axis];
        this.op = reduceType === 'min' ? '<' : '>';
        // |outShape| is the shape with the removed axis
        const [outputShape, reduceShape] = backend_util.computeOutAndReduceShapes(inputShape, axes);
        this.outputShape = outputShape.length === 0 ? [1] : outputShape;
        this.dispatchLayout = flatDispatchLayout(this.outputShape);
        // The shared algorithm is mainly used for large reduce size. It fully
        // utilizes the threads in one workgroup to do the reduction. However,
        // when the reduce size is very small or the output shape is too large. It's
        // better to use the plain algorithm to reduce the number of workgroups to
        // speedup. The threthold can be further tuned.
        if (util.sizeFromShape(reduceShape) < 32 ||
            util.sizeFromShape(outputShape) > 1000) {
            this.type = 'plain';
            this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workGroupSize);
        }
        else {
            this.type = 'shared';
            // A work group only outputs a data, so we transfer [1, 1, 1] to compute
            // dispatch size.
            this.dispatch =
                computeDispatch(this.dispatchLayout, this.outputShape, [1, 1, 1]);
        }
        this.inputShape = inputShape;
        this.shaderKey = `argMinMax_${this.op}_${this.type}`;
    }
    getUserCode() {
        const getInputShapeLastDim = () => {
            if (this.inputShape.length === 1) {
                return 'uniforms.xShape';
            }
            else {
                return `uniforms.xShape.${getCoordsXYZ(this.inputShape.length - 1)}`;
            }
        };
        const splitOutputCoords = () => {
            let snippet = '';
            if (this.outputShape.length === 1) {
                if (this.inputShape.length !== 1) {
                    snippet += 'outputCoords,';
                }
            }
            else {
                for (let i = 0; i < this.outputShape.length; i++) {
                    snippet += `outputCoords.${getCoordsXYZ(i)},`;
                }
            }
            return snippet;
        };
        if (this.type === 'shared') {
            const sharedMemorySnippet = `
      var<workgroup> xBestIndices : array<i32, ${this.workGroupSize[0]}>;
      var<workgroup> xBestValues : array<f32, ${this.workGroupSize[0]}>;
    `;
            const userCode = `
      fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
      }

      ${sharedMemorySnippet}

      ${main('index')} {
        let outputIndex = index / i32(workGroupSizeX);
        let reduceLength = ${getInputShapeLastDim()};

        var bestIndex = i32(localId.x);
        var bestValue = uniforms.infinityValue;
        let outputCoords = getCoordsFromIndex(outputIndex);
        for (var k = i32(localId.x); k < reduceLength && outputIndex < uniforms.size;
            k = k + i32(workGroupSizeX)) {
          let candidate = getX(${splitOutputCoords()} k);
          if (!isnan(candidate) && candidate ${this.op} bestValue) {
            bestValue = candidate;
            bestIndex = k;
          }
        }
        xBestValues[localId.x] = bestValue;
        xBestIndices[localId.x] = bestIndex;
        workgroupBarrier();

        var reduceSize = min(u32(reduceLength), workGroupSizeX);
        for (var currentSize = reduceSize / 2u; reduceSize > 1u;
            currentSize = reduceSize / 2u) {
          let interval = DIV_CEIL(reduceSize, 2u);
          if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              xBestValues[localId.x] = bestValue;
              xBestIndices[localId.x] = xBestIndices[localId.x + interval];
            }
          }
          reduceSize = interval;
          workgroupBarrier();
        }

        if (localId.x == 0u && outputIndex < uniforms.size) {
          setOutputAtIndexI32(outputIndex, xBestIndices[localId.x]);
        }
      }
    `;
            return userCode;
        }
        else {
            const userCode = `
      ${main('index')} {
        if (index < uniforms.size) {
          let outputCoords = getCoordsFromIndex(index);
          var bestIndex = 0;
          var bestValue = getX(${splitOutputCoords()} 0);
          let reduceLength = ${getInputShapeLastDim()};
          for (var i = 1; i < reduceLength; i++) {
            let candidate = getX(${splitOutputCoords()} i);
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              bestIndex = i;
            }
          }
          setOutputAtIndexI32(index, bestIndex);
        }
      }
      `;
            return userCode;
        }
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXJnbWlubWF4X3dlYmdwdS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3RmanMtYmFja2VuZC13ZWJncHUvc3JjL2FyZ21pbm1heF93ZWJncHUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBRUgsT0FBTyxFQUFDLFlBQVksRUFBRSxJQUFJLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQUN6RCxPQUFPLEVBQUMsWUFBWSxFQUFFLG1CQUFtQixJQUFJLElBQUksRUFBZ0IsTUFBTSxrQkFBa0IsQ0FBQztBQUMxRixPQUFPLEVBQUMsZUFBZSxFQUFFLGtCQUFrQixFQUFDLE1BQU0sZUFBZSxDQUFDO0FBRWxFLE1BQU0sT0FBTyxnQkFBZ0I7SUFjM0IsWUFBWSxVQUFvQixFQUFFLElBQVksRUFBRSxVQUF1QjtRQVR2RSxrQkFBYSxHQUE2QixDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDckQsa0JBQWEsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ3RCLGFBQVEsR0FBRyxzQkFBc0IsQ0FBQztRQUlsQyxTQUFJLEdBQUcsSUFBSSxDQUFDO1FBSVYsTUFBTSxJQUFJLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUVwQixJQUFJLENBQUMsRUFBRSxHQUFHLFVBQVUsS0FBSyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDO1FBRTNDLGdEQUFnRDtRQUNoRCxNQUFNLENBQUMsV0FBVyxFQUFFLFdBQVcsQ0FBQyxHQUM1QixZQUFZLENBQUMseUJBQXlCLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxDQUFDO1FBRTdELElBQUksQ0FBQyxXQUFXLEdBQUcsV0FBVyxDQUFDLE1BQU0sS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQztRQUNoRSxJ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QUMsRUFBRTs7Ozs7Ozs7T0FRNUIsQ0FBQztZQUNGLE9BQU8sUUFBUSxDQUFDO1NBQ2pCO0lBQ0gsQ0FBQztDQUNGIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG5pbXBvcnQge2JhY2tlbmRfdXRpbCwgdXRpbH0gZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcbmltcG9ydCB7Z2V0Q29vcmRzWFlaLCBnZXRNYWluSGVhZGVyU3RyaW5nIGFzIG1haW4sIFdlYkdQVVByb2dyYW19IGZyb20gJy4vd2ViZ3B1X3Byb2dyYW0nO1xuaW1wb3J0IHtjb21wdXRlRGlzcGF0Y2gsIGZsYXREaXNwYXRjaExheW91dH0gZnJvbSAnLi93ZWJncHVfdXRpbCc7XG5cbmV4cG9ydCBjbGFzcyBBcmdNaW5NYXhQcm9ncmFtIGltcGxlbWVudHMgV2ViR1BVUHJvZ3JhbSB7XG4gIG91dHB1dFNoYXBlOiBudW1iZXJbXTtcbiAgc2hhZGVyS2V5OiBzdHJpbmc7XG4gIGRpc3BhdGNoTGF5b3V0OiB7eDogbnVtYmVyW119O1xuICBkaXNwYXRjaDogW251bWJlciwgbnVtYmVyLCBudW1iZXJdO1xuICB3b3JrR3JvdXBTaXplOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0gPSBbNjQsIDEsIDFdO1xuICB2YXJpYWJsZU5hbWVzID0gWyd4J107XG4gIHVuaWZvcm1zID0gJ2luZmluaXR5VmFsdWUgOiBmMzIsJztcbiAgaW5wdXRTaGFwZTogbnVtYmVyW107XG4gIHJlZHVjdGlvbkZhY3RvcjogbnVtYmVyO1xuICBvcDogc3RyaW5nO1xuICBzaXplID0gdHJ1ZTtcbiAgcHJpdmF0ZSB0eXBlOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IoaW5wdXRTaGFwZTogbnVtYmVyW10sIGF4aXM6IG51bWJlciwgcmVkdWNlVHlwZTogJ21pbid8J21heCcpIHtcbiAgICBjb25zdCBheGVzID0gW2F4aXNdO1xuXG4gICAgdGhpcy5vcCA9IHJlZHVjZVR5cGUgPT09ICdtaW4nID8gJzwnIDogJz4nO1xuXG4gICAgLy8gfG91dFNoYXBlfCBpcyB0aGUgc2hhcGUgd2l0aCB0aGUgcmVtb3ZlZCBheGlzXG4gICAgY29uc3QgW291dHB1dFNoYXBlLCByZWR1Y2VTaGFwZV0gPVxuICAgICAgICBiYWNrZW5kX3V0aWwuY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyhpbnB1dFNoYXBlLCBheGVzKTtcblxuICAgIHRoaXMub3V0cHV0U2hhcGUgPSBvdXRwdXRTaGFwZS5sZW5ndGggPT09IDAgPyBbMV0gOiBvdXRwdXRTaGFwZTtcbiAgICB0aGlzLmRpc3BhdGNoTGF5b3V0ID0gZmxhdERpc3BhdGNoTGF5b3V0KHRoaXMub3V0cHV0U2hhcGUpO1xuICAgIC8vIFRoZSBzaGFyZWQgYWxnb3JpdGhtIGlzIG1haW5seSB1c2VkIGZvciBsYXJnZSByZWR1Y2Ugc2l6ZS4gSXQgZnVsbHlcbiAgICAvLyB1dGlsaXplcyB0aGUgdGhyZWFkcyBpbiBvbmUgd29ya2dyb3VwIHRvIGRvIHRoZSByZWR1Y3Rpb24uIEhvd2V2ZXIsXG4gICAgLy8gd2hlbiB0aGUgcmVkdWNlIHNpemUgaXMgdmVyeSBzbWFsbCBvciB0aGUgb3V0cHV0IHNoYXBlIGlzIHRvbyBsYXJnZS4gSXQnc1xuICAgIC8vIGJldHRlciB0byB1c2UgdGhlIHBsYWluIGFsZ29yaXRobSB0byByZWR1Y2UgdGhlIG51bWJlciBvZiB3b3JrZ3JvdXBzIHRvXG4gICAgLy8gc3BlZWR1cC4gVGhlIHRocmV0aG9sZCBjYW4gYmUgZnVydGhlciB0dW5lZC5cbiAgICBpZiAodXRpbC5zaXplRnJvbVNoYXBlKHJlZHVjZVNoYXBlKSA8IDMyIHx8XG4gICAgICAgIHV0aWwuc2l6ZUZyb21TaGFwZShvdXRwdXRTaGFwZSkgPiAxMDAwKSB7XG4gICAgICB0aGlzLnR5cGUgPSAncGxhaW4nO1xuICAgICAgdGhpcy5kaXNwYXRjaCA9IGNvbXB1dGVEaXNwYXRjaChcbiAgICAgICAgICB0aGlzLmRpc3BhdGNoTGF5b3V0LCB0aGlzLm91dHB1dFNoYXBlLCB0aGlzLndvcmtHcm91cFNpemUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnR5cGUgPSAnc2hhcmVkJztcbiAgICAgIC8vIEEgd29yayBncm91cCBvbmx5IG91dHB1dHMgYSBkYXRhLCBzbyB3ZSB0cmFuc2ZlciBbMSwgMSwgMV0gdG8gY29tcHV0ZVxuICAgICAgLy8gZGlzcGF0Y2ggc2l6ZS5cbiAgICAgIHRoaXMuZGlzcGF0Y2ggPVxuICAgICAgICAgIGNvbXB1dGVEaXNwYXRjaCh0aGlzLmRpc3BhdGNoTGF5b3V0LCB0aGlzLm91dHB1dFNoYXBlLCBbMSwgMSwgMV0pO1xuICAgIH1cblxuICAgIHRoaXMuaW5wdXRTaGFwZSA9IGlucHV0U2hhcGU7XG4gICAgdGhpcy5zaGFkZXJLZXkgPSBgYXJnTWluTWF4XyR7dGhpcy5vcH1fJHt0aGlzLnR5cGV9YDtcbiAgfVxuXG4gIGdldFVzZXJDb2RlKCk6IHN0cmluZyB7XG4gICAgY29uc3QgZ2V0SW5wdXRTaGFwZUxhc3REaW0gPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5pbnB1dFNoYXBlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gJ3VuaWZvcm1zLnhTaGFwZSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYHVuaWZvcm1zLnhTaGFwZS4ke2dldENvb3Jkc1hZWih0aGlzLmlucHV0U2hhcGUubGVuZ3RoIC0gMSl9YDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3Qgc3BsaXRPdXRwdXRDb29yZHMgPSAoKSA9PiB7XG4gICAgICBsZXQgc25pcHBldCA9ICcnO1xuICAgICAgaWYgKHRoaXMub3V0cHV0U2hhcGUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGlmICh0aGlzLmlucHV0U2hhcGUubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgc25pcHBldCArPSAnb3V0cHV0Q29vcmRzLCc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5vdXRwdXRTaGFwZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHNuaXBwZXQgKz0gYG91dHB1dENvb3Jkcy4ke2dldENvb3Jkc1hZWihpKX0sYDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHNuaXBwZXQ7XG4gICAgfTtcblxuICAgIGlmICh0aGlzLnR5cGUgPT09ICdzaGFyZWQnKSB7XG4gICAgICBjb25zdCBzaGFyZWRNZW1vcnlTbmlwcGV0ID0gYFxuICAgICAgdmFyPHdvcmtncm91cD4geEJlc3RJbmRpY2VzIDogYXJyYXk8aTMyLCAke3RoaXMud29ya0dyb3VwU2l6ZVswXX0+O1xuICAgICAgdmFyPHdvcmtncm91cD4geEJlc3RWYWx1ZXMgOiBhcnJheTxmMzIsICR7dGhpcy53b3JrR3JvdXBTaXplWzBdfT47XG4gICAgYDtcbiAgICAgIGNvbnN0IHVzZXJDb2RlID0gYFxuICAgICAgZm4gRElWX0NFSUwoYSA6IHUzMiwgYiA6IHUzMikgLT4gdTMyIHtcbiAgICAgICAgcmV0dXJuICgoYSAtIDF1KSAvIGIgKyAxdSk7XG4gICAgICB9XG5cbiAgICAgICR7c2hhcmVkTWVtb3J5U25pcHBldH1cblxuICAgICAgJHttYWluKCdpbmRleCcpfSB7XG4gICAgICAgIGxldCBvdXRwdXRJbmRleCA9IGluZGV4IC8gaTMyKHdvcmtHcm91cFNpemVYKTtcbiAgICAgICAgbGV0IHJlZHVjZUxlbmd0aCA9ICR7Z2V0SW5wdXRTaGFwZUxhc3REaW0oKX07XG5cbiAgICAgICAgdmFyIGJlc3RJbmRleCA9IGkzMihsb2NhbElkLngpO1xuICAgICAgICB2YXIgYmVzdFZhbHVlID0gdW5pZm9ybXMuaW5maW5pdHlWYWx1ZTtcbiAgICAgICAgbGV0IG91dHB1dENvb3JkcyA9IGdldENvb3Jkc0Zyb21JbmRleChvdXRwdXRJbmRleCk7XG4gICAgICAgIGZvciAodmFyIGsgPSBpMzIobG9jYWxJZC54KTsgayA8IHJlZHVjZUxlbmd0aCAmJiBvdXRwdXRJbmRleCA8IHVuaWZvcm1zLnNpemU7XG4gICAgICAgICAgICBrID0gayArIGkzMih3b3JrR3JvdXBTaXplWCkpIHtcbiAgICAgICAgICBsZXQgY2FuZGlkYXRlID0gZ2V0WCgke3NwbGl0T3V0cHV0Q29vcmRzKCl9IGspO1xuICAgICAgICAgIGlmICghaXNuYW4oY2FuZGlkYXRlKSAmJiBjYW5kaWRhdGUgJHt0aGlzLm9wfSBiZXN0VmFsdWUpIHtcbiAgICAgICAgICAgIGJlc3RWYWx1ZSA9IGNhbmRpZGF0ZTtcbiAgICAgICAgICAgIGJlc3RJbmRleCA9IGs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHhCZXN0VmFsdWVzW2xvY2FsSWQueF0gPSBiZXN0VmFsdWU7XG4gICAgICAgIHhCZXN0SW5kaWNlc1tsb2NhbElkLnhdID0gYmVzdEluZGV4O1xuICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgICAgdmFyIHJlZHVjZVNpemUgPSBtaW4odTMyKHJlZHVjZUxlbmd0aCksIHdvcmtHcm91cFNpemVYKTtcbiAgICAgICAgZm9yICh2YXIgY3VycmVudFNpemUgPSByZWR1Y2VTaXplIC8gMnU7IHJlZHVjZVNpemUgPiAxdTtcbiAgICAgICAgICAgIGN1cnJlbnRTaXplID0gcmVkdWNlU2l6ZSAvIDJ1KSB7XG4gICAgICAgICAgbGV0IGludGVydmFsID0gRElWX0NFSUwocmVkdWNlU2l6ZSwgMnUpO1xuICAgICAgICAgIGlmIChsb2NhbElkLnggPCBjdXJyZW50U2l6ZSkge1xuICAgICAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHhCZXN0VmFsdWVzW2xvY2FsSWQueCArIGludGVydmFsXTtcbiAgICAgICAgICAgIGlmIChjYW5kaWRhdGUgJHt0aGlzLm9wfSBiZXN0VmFsdWUpIHtcbiAgICAgICAgICAgICAgYmVzdFZhbHVlID0gY2FuZGlkYXRlO1xuICAgICAgICAgICAgICB4QmVzdFZhbHVlc1tsb2NhbElkLnhdID0gYmVzdFZhbHVlO1xuICAgICAgICAgICAgICB4QmVzdEluZGljZXNbbG9jYWxJZC54XSA9IHhCZXN0SW5kaWNlc1tsb2NhbElkLnggKyBpbnRlcnZhbF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlZHVjZVNpemUgPSBpbnRlcnZhbDtcbiAgICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobG9jYWxJZC54ID09IDB1ICYmIG91dHB1dEluZGV4IDwgdW5pZm9ybXMuc2l6ZSkge1xuICAgICAgICAgIHNldE91dHB1dEF0SW5kZXhJMzIob3V0cHV0SW5kZXgsIHhCZXN0SW5kaWNlc1tsb2NhbElkLnhdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGA7XG4gICAgICByZXR1cm4gdXNlckNvZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHVzZXJDb2RlID0gYFxuICAgICAgJHttYWluKCdpbmRleCcpfSB7XG4gICAgICAgIGlmIChpbmRleCA8IHVuaWZvcm1zLnNpemUpIHtcbiAgICAgICAgICBsZXQgb3V0cHV0Q29vcmRzID0gZ2V0Q29vcmRzRnJvbUluZGV4KGluZGV4KTtcbiAgICAgICAgICB2YXIgYmVzdEluZGV4ID0gMDtcbiAgICAgICAgICB2YXIgYmVzdFZhbHVlID0gZ2V0WCgke3NwbGl0T3V0cHV0Q29vcmRzKCl9IDApO1xuICAgICAgICAgIGxldCByZWR1Y2VMZW5ndGggPSAke2dldElucHV0U2hhcGVMYXN0RGltKCl9O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgcmVkdWNlTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjYW5kaWRhdGUgPSBnZXRYKCR7c3BsaXRPdXRwdXRDb29yZHMoKX0gaSk7XG4gICAgICAgICAgICBpZiAoY2FuZGlkYXRlICR7dGhpcy5vcH0gYmVzdFZhbHVlKSB7XG4gICAgICAgICAgICAgIGJlc3RWYWx1ZSA9IGNhbmRpZGF0ZTtcbiAgICAgICAgICAgICAgYmVzdEluZGV4ID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgc2V0T3V0cHV0QXRJbmRleEkzMihpbmRleCwgYmVzdEluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYDtcbiAgICAgIHJldHVybiB1c2VyQ29kZTtcbiAgICB9XG4gIH1cbn1cbiJdfQ==