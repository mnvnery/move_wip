/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import { getCoordsDataType, getMainHeaderString as main, mapToWgslTypes } from './webgpu_program';
import { computeDispatch, flatDispatchLayout } from './webgpu_util';
export class ScatterProgram {
    constructor(flattenXShape, sliceDim, indicesRank, updatesRank, strides, shape, outputDtype, sumDupeIndices = true) {
        this.variableNames = ['updates', 'indices'];
        this.workGroupSize = [64, 1, 1];
        this.atomic = true;
        this.outputShape = shape;
        this.type = outputDtype;
        this.sumDupeIndices = sumDupeIndices;
        this.dispatchLayout = flatDispatchLayout(flattenXShape);
        // Dispatching based on |updates| shape instead of output shape.
        this.dispatch =
            computeDispatch(this.dispatchLayout, flattenXShape, this.workGroupSize);
        this.sliceDimGreaterThanOne = sliceDim > 1;
        this.shaderKey = `scatter_${indicesRank}_${updatesRank}_${this.sliceDimGreaterThanOne}_${outputDtype}_${sumDupeIndices}`;
        const stridesType = getCoordsDataType(strides.length);
        this.uniforms = `sliceDim : i32, strides: ${stridesType}, size: i32,`;
        this.updatesRank = updatesRank;
        this.indicesRank = indicesRank;
    }
    getUserCode() {
        let indicesString = '';
        if (this.indicesRank === 1) {
            indicesString = 'coords[0]';
        }
        else if (this.indicesRank === 2) {
            indicesString = 'coords[0], j';
        }
        const indicesSnippet = `getIndices(${indicesString})`;
        const strideString = this.sliceDimGreaterThanOne ? 'uniforms.strides[j]' :
            'uniforms.strides';
        let outCoordsString = '';
        let getUpdatesCoordsFromFlatIndex = '';
        if (this.dispatchLayout.x.length === 1) {
            outCoordsString = 'flattenedIndex';
            getUpdatesCoordsFromFlatIndex = `
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {
        return index;
      }
      `;
        }
        else if (this.dispatchLayout.x.length === 2) {
            outCoordsString = 'vec2<i32>(flattenedIndex, coords[1])';
            getUpdatesCoordsFromFlatIndex = `
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {
        // N.B. |updates| could be a scalar tensor, conceptually representing a
        // 2D tensor with all values equal to that. By design, its size must be
        // the same as |outShape[1]| in one dimension, and |indicesShape[0]|
        // gives the other.
        let sliceSize = uniforms.outShape[1];
        let d0 = index / sliceSize;
        let d1 = index - d0 * sliceSize;
        return vec2<i32>(d0, d1);
      }
      `;
        }
        const updatesString = Array.from({ length: this.updatesRank }, (_, idx) => `coords[${idx}]`);
        const updatesSnippet = `getUpdates(${updatesString.join(', ')})`;
        const atomicRMW = (ptr, val) => {
            let atomicAddSnippet = `atomicAdd(${ptr}, bitcast<i32>(${val}))`;
            if (this.type === 'float32') {
                atomicAddSnippet = `
          {
            var oldBits = 0;
            var newBits = bitcast<i32>(${val});
            loop {
              let info = atomicCompareExchangeWeak(${ptr}, oldBits, newBits);
              if (info.exchanged) {
                break;
              }
              oldBits = info.old_value;
              let oldValue = bitcast<f32>(oldBits);
              let newValue = oldValue + (${val});
              newBits = bitcast<i32>(newValue);
            }
          }
        `;
            }
            const atomicStoreSnippet = `atomicStore(${ptr}, bitcast<i32>(${val}));`;
            return this.sumDupeIndices ? atomicAddSnippet : atomicStoreSnippet;
        };
        const userCode = `
    ${getUpdatesCoordsFromFlatIndex}

      ${main('index')} {
        if (index < uniforms.size) {
          let coords = getUpdatesCoordsFromFlatIndex(index);
          var flattenedIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexInside = i32(round(${indicesSnippet}));
            flattenedIndex = flattenedIndex + indexInside * ${strideString};
          }
          let updateValue =
              ${mapToWgslTypes(this.type, false)}(${updatesSnippet});
          let flatIndex = getOutputIndexFromCoords(${outCoordsString});

          ${atomicRMW('&result[flatIndex]', 'updateValue')};
        }
      }`;
        return userCode;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2NhdHRlcl93ZWJncHUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi90ZmpzLWJhY2tlbmQtd2ViZ3B1L3NyYy9zY2F0dGVyX3dlYmdwdS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFHSCxPQUFPLEVBQUMsaUJBQWlCLEVBQUUsbUJBQW1CLElBQUksSUFBSSxFQUFFLGNBQWMsRUFBZ0IsTUFBTSxrQkFBa0IsQ0FBQztBQUMvRyxPQUFPLEVBQUMsZUFBZSxFQUFFLGtCQUFrQixFQUFDLE1BQU0sZUFBZSxDQUFDO0FBRWxFLE1BQU0sT0FBTyxjQUFjO0lBZXpCLFlBQ0ksYUFBdUIsRUFBRSxRQUFnQixFQUFFLFdBQW1CLEVBQzlELFdBQW1CLEVBQUUsT0FBaUIsRUFBRSxLQUFlLEVBQ3ZELFdBQXFCLEVBQUUsY0FBYyxHQUFHLElBQUk7UUFqQmhELGtCQUFhLEdBQUcsQ0FBQyxTQUFTLEVBQUUsU0FBUyxDQUFDLENBQUM7UUFPdkMsa0JBQWEsR0FBNkIsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBSXJELFdBQU0sR0FBRyxJQUFJLENBQUM7UUFPWixJQUFJLENBQUMsV0FBVyxHQUFHLEtBQUssQ0FBQztRQUN6QixJQUFJLENBQUMsSUFBSSxHQUFHLFdBQVcsQ0FBQztRQUN4QixJQUFJLENBQUMsY0FBYyxHQUFHLGNBQWMsQ0FBQztRQUNyQyxJQUFJLENBQUMsY0FBYyxHQUFHLGtCQUFrQixDQUFDLGFBQWEsQ0FBQyxDQUFDO1FBQ3hELGdFQUFnRTtRQUNoRSxJQUFJLENBQUMsUUFBUTtZQUNULGVBQWUsQ0FBQyxJQUFJLENBQUMsY0FBYyxFQUFFLGFBQWEsRUFBRSxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7UUFDNUUsSUFBSSxDQUFDLHNCQUFzQixHQUFHLFFBQVEsR0FBRyxDQUFDLENBQUM7UUFDM0MsSUFBSSxDQUFDLFNBQVMsR0FBRyxXQUFXLFdBQVcsSUFBSSxXQUFXLElBQ2xELElBQUksQ0FBQyxzQkFBc0IsSUFBSSxXQUFXLElBQUksY0FBYyxFQUFFLENBQUM7UUFDbkUsTUFBTSxXQUFXLEdBQUcsaUJBQWlCLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ3RELElBQUksQ0FBQyxRQUFRLEdBQUcsNEJBQTRCLFdBQVcsY0FBYyxDQUFDO1FBQ3RFLElBQUksQ0FBQyxXQUFXLEdBQUcsV0FBVyxDQUFDO1FBQy9CLElBQUksQ0FBQyxXQUFXLEdBQUcsV0FBVyxDQUFDO0lBQ2pDLENBQUM7SUFFRCxXQUFXO1FBQ1QsSUFBSSxhQUFhLEdBQUcsRUFBRSxDQUFDO1FBQ3ZCLElBQUksSUFBSSxDQUFDLFdBQVcsS0FBSyxDQUFDLEVBQUU7WUFDMUIsYUFBYSxHQUFHLFdBQVcsQ0FBQztTQUM3QjthQUFNLElBQUksSUFBSSxDQUFDLFdBQVcsS0FBSyxDQUFDLEVBQUU7WUFDakMsYUFBYSxHQUFHLGNBQWMsQ0FBQztTQUNoQztRQUNELE1BQU0sY0FBYyxHQUFHLGNBQWMsYUFBYSxHQUFHLENBQUM7UUFFdEQsTUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLHNCQUFzQixDQUFDLENBQUMsQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDO1lBQ3ZCLGtCQUFrQixDQUFDO1FBRXRFLElBQUksZUFBZSxHQUFHLEVBQUUsQ0FBQztRQUN6QixJQUFJLDZCQUE2QixHQUFHLEVBQUUsQ0FBQztRQUN2QyxJQUFJLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7WUFDdEMsZUFBZSxHQUFHLGdCQUFnQixDQUFDO1lBQ25DLDZCQUE2QixHQUFHOzs7O09BSS9CLENBQUM7U0FDSDthQUFNLElBQUksSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtZQUM3QyxlQUFlLEdBQUcsc0NBQXNDLENBQUM7WUFDekQsNkJBQTZCLEdBQUc7Ozs7Ozs7Ozs7O09BVy9CLENBQUM7U0FDSDtRQUNELE1BQU0sYUFBYSxHQUNmLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLFdBQVcsRUFBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLEdBQUcsRUFBRSxFQUFFLENBQUMsVUFBVSxHQUFHLEdBQUcsQ0FBQyxDQUFDO1FBQ3pFLE1BQU0sY0FBYyxHQUFHLGNBQWMsYUFBYSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDO1FBRWpFLE1BQU0sU0FBUyxHQUFHLENBQUMsR0FBVyxFQUFFLEdBQVcsRUFBRSxFQUFFO1lBQzdDLElBQUksZ0JBQWdCLEdBQUcsYUFBYSxHQUFHLGtCQUFrQixHQUFHLElBQUksQ0FBQztZQUNqRSxJQUFJLElBQUksQ0FBQyxJQUFJLEtBQUssU0FBUyxFQUFFO2dCQUMzQixnQkFBZ0IsR0FBRzs7O3lDQUdjLEdBQUc7O3FEQUVTLEdBQUc7Ozs7OzsyQ0FNYixHQUFHOzs7O1NBSXJDLENBQUM7YUFDSDtZQUNELE1BQU0sa0JBQWtCLEdBQUcsZUFBZSxHQUFHLGtCQUFrQixHQUFHLEtBQUssQ0FBQztZQUN4RSxPQUFPLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxrQkFBa0IsQ0FBQztRQUNyRSxDQUFDLENBQUM7UUFFRixNQUFNLFFBQVEsR0FBRztNQUNmLDZCQUE2Qjs7UUFFM0IsSUFBSSxDQUFDLE9BQU8sQ0FBQzs7Ozs7MENBS3FCLGNBQWM7OERBQ00sWUFBWTs7O2dCQUcxRCxjQUFjLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsSUFBSSxjQUFjO3FEQUNiLGVBQWU7O1lBRXhELFNBQVMsQ0FBQyxvQkFBb0IsRUFBRSxhQUFhLENBQUM7O1FBRWxELENBQUM7UUFDTCxPQUFPLFFBQVEsQ0FBQztJQUNsQixDQUFDO0NBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmltcG9ydCB7RGF0YVR5cGV9IGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XG5pbXBvcnQge2dldENvb3Jkc0RhdGFUeXBlLCBnZXRNYWluSGVhZGVyU3RyaW5nIGFzIG1haW4sIG1hcFRvV2dzbFR5cGVzLCBXZWJHUFVQcm9ncmFtfSBmcm9tICcuL3dlYmdwdV9wcm9ncmFtJztcbmltcG9ydCB7Y29tcHV0ZURpc3BhdGNoLCBmbGF0RGlzcGF0Y2hMYXlvdXR9IGZyb20gJy4vd2ViZ3B1X3V0aWwnO1xuXG5leHBvcnQgY2xhc3MgU2NhdHRlclByb2dyYW0gaW1wbGVtZW50cyBXZWJHUFVQcm9ncmFtIHtcbiAgdmFyaWFibGVOYW1lcyA9IFsndXBkYXRlcycsICdpbmRpY2VzJ107XG4gIHVuaWZvcm1zOiBzdHJpbmc7XG4gIG91dHB1dFNoYXBlOiBudW1iZXJbXTtcbiAgc3VtRHVwZUluZGljZXM6IGJvb2xlYW47XG4gIHNoYWRlcktleTogc3RyaW5nO1xuICBkaXNwYXRjaExheW91dDoge3g6IG51bWJlcltdfTtcbiAgZGlzcGF0Y2g6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbiAgd29ya0dyb3VwU2l6ZTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdID0gWzY0LCAxLCAxXTtcbiAgdXBkYXRlc1Jhbms6IG51bWJlcjtcbiAgaW5kaWNlc1Jhbms6IG51bWJlcjtcbiAgc2xpY2VEaW1HcmVhdGVyVGhhbk9uZTogYm9vbGVhbjtcbiAgYXRvbWljID0gdHJ1ZTtcbiAgdHlwZTogRGF0YVR5cGU7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgICBmbGF0dGVuWFNoYXBlOiBudW1iZXJbXSwgc2xpY2VEaW06IG51bWJlciwgaW5kaWNlc1Jhbms6IG51bWJlcixcbiAgICAgIHVwZGF0ZXNSYW5rOiBudW1iZXIsIHN0cmlkZXM6IG51bWJlcltdLCBzaGFwZTogbnVtYmVyW10sXG4gICAgICBvdXRwdXREdHlwZTogRGF0YVR5cGUsIHN1bUR1cGVJbmRpY2VzID0gdHJ1ZSkge1xuICAgIHRoaXMub3V0cHV0U2hhcGUgPSBzaGFwZTtcbiAgICB0aGlzLnR5cGUgPSBvdXRwdXREdHlwZTtcbiAgICB0aGlzLnN1bUR1cGVJbmRpY2VzID0gc3VtRHVwZUluZGljZXM7XG4gICAgdGhpcy5kaXNwYXRjaExheW91dCA9IGZsYXREaXNwYXRjaExheW91dChmbGF0dGVuWFNoYXBlKTtcbiAgICAvLyBEaXNwYXRjaGluZyBiYXNlZCBvbiB8dXBkYXRlc3wgc2hhcGUgaW5zdGVhZCBvZiBvdXRwdXQgc2hhcGUuXG4gICAgdGhpcy5kaXNwYXRjaCA9XG4gICAgICAgIGNvbXB1dGVEaXNwYXRjaCh0aGlzLmRpc3BhdGNoTGF5b3V0LCBmbGF0dGVuWFNoYXBlLCB0aGlzLndvcmtHcm91cFNpemUpO1xuICAgIHRoaXMuc2xpY2VEaW1HcmVhdGVyVGhhbk9uZSA9IHNsaWNlRGltID4gMTtcbiAgICB0aGlzLnNoYWRlcktleSA9IGBzY2F0dGVyXyR7aW5kaWNlc1Jhbmt9XyR7dXBkYXRlc1Jhbmt9XyR7XG4gICAgICAgIHRoaXMuc2xpY2VEaW1HcmVhdGVyVGhhbk9uZX1fJHtvdXRwdXREdHlwZX1fJHtzdW1EdXBlSW5kaWNlc31gO1xuICAgIGNvbnN0IHN0cmlkZXNUeXBlID0gZ2V0Q29vcmRzRGF0YVR5cGUoc3RyaWRlcy5sZW5ndGgpO1xuICAgIHRoaXMudW5pZm9ybXMgPSBgc2xpY2VEaW0gOiBpMzIsIHN0cmlkZXM6ICR7c3RyaWRlc1R5cGV9LCBzaXplOiBpMzIsYDtcbiAgICB0aGlzLnVwZGF0ZXNSYW5rID0gdXBkYXRlc1Jhbms7XG4gICAgdGhpcy5pbmRpY2VzUmFuayA9IGluZGljZXNSYW5rO1xuICB9XG5cbiAgZ2V0VXNlckNvZGUoKTogc3RyaW5nIHtcbiAgICBsZXQgaW5kaWNlc1N0cmluZyA9ICcnO1xuICAgIGlmICh0aGlzLmluZGljZXNSYW5rID09PSAxKSB7XG4gICAgICBpbmRpY2VzU3RyaW5nID0gJ2Nvb3Jkc1swXSc7XG4gICAgfSBlbHNlIGlmICh0aGlzLmluZGljZXNSYW5rID09PSAyKSB7XG4gICAgICBpbmRpY2VzU3RyaW5nID0gJ2Nvb3Jkc1swXSwgaic7XG4gICAgfVxuICAgIGNvbnN0IGluZGljZXNTbmlwcGV0ID0gYGdldEluZGljZXMoJHtpbmRpY2VzU3RyaW5nfSlgO1xuXG4gICAgY29uc3Qgc3RyaWRlU3RyaW5nID0gdGhpcy5zbGljZURpbUdyZWF0ZXJUaGFuT25lID8gJ3VuaWZvcm1zLnN0cmlkZXNbal0nIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAndW5pZm9ybXMuc3RyaWRlcyc7XG5cbiAgICBsZXQgb3V0Q29vcmRzU3RyaW5nID0gJyc7XG4gICAgbGV0IGdldFVwZGF0ZXNDb29yZHNGcm9tRmxhdEluZGV4ID0gJyc7XG4gICAgaWYgKHRoaXMuZGlzcGF0Y2hMYXlvdXQueC5sZW5ndGggPT09IDEpIHtcbiAgICAgIG91dENvb3Jkc1N0cmluZyA9ICdmbGF0dGVuZWRJbmRleCc7XG4gICAgICBnZXRVcGRhdGVzQ29vcmRzRnJvbUZsYXRJbmRleCA9IGBcbiAgICAgIGZuIGdldFVwZGF0ZXNDb29yZHNGcm9tRmxhdEluZGV4KGluZGV4IDogaTMyKSAtPiBpMzIge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgICBgO1xuICAgIH0gZWxzZSBpZiAodGhpcy5kaXNwYXRjaExheW91dC54Lmxlbmd0aCA9PT0gMikge1xuICAgICAgb3V0Q29vcmRzU3RyaW5nID0gJ3ZlYzI8aTMyPihmbGF0dGVuZWRJbmRleCwgY29vcmRzWzFdKSc7XG4gICAgICBnZXRVcGRhdGVzQ29vcmRzRnJvbUZsYXRJbmRleCA9IGBcbiAgICAgIGZuIGdldFVwZGF0ZXNDb29yZHNGcm9tRmxhdEluZGV4KGluZGV4IDogaTMyKSAtPiB2ZWMyPGkzMj4ge1xuICAgICAgICAvLyBOLkIuIHx1cGRhdGVzfCBjb3VsZCBiZSBhIHNjYWxhciB0ZW5zb3IsIGNvbmNlcHR1YWxseSByZXByZXNlbnRpbmcgYVxuICAgICAgICAvLyAyRCB0ZW5zb3Igd2l0aCBhbGwgdmFsdWVzIGVxdWFsIHRvIHRoYXQuIEJ5IGRlc2lnbiwgaXRzIHNpemUgbXVzdCBiZVxuICAgICAgICAvLyB0aGUgc2FtZSBhcyB8b3V0U2hhcGVbMV18IGluIG9uZSBkaW1lbnNpb24sIGFuZCB8aW5kaWNlc1NoYXBlWzBdfFxuICAgICAgICAvLyBnaXZlcyB0aGUgb3RoZXIuXG4gICAgICAgIGxldCBzbGljZVNpemUgPSB1bmlmb3Jtcy5vdXRTaGFwZVsxXTtcbiAgICAgICAgbGV0IGQwID0gaW5kZXggLyBzbGljZVNpemU7XG4gICAgICAgIGxldCBkMSA9IGluZGV4IC0gZDAgKiBzbGljZVNpemU7XG4gICAgICAgIHJldHVybiB2ZWMyPGkzMj4oZDAsIGQxKTtcbiAgICAgIH1cbiAgICAgIGA7XG4gICAgfVxuICAgIGNvbnN0IHVwZGF0ZXNTdHJpbmcgPVxuICAgICAgICBBcnJheS5mcm9tKHtsZW5ndGg6IHRoaXMudXBkYXRlc1Jhbmt9LCAoXywgaWR4KSA9PiBgY29vcmRzWyR7aWR4fV1gKTtcbiAgICBjb25zdCB1cGRhdGVzU25pcHBldCA9IGBnZXRVcGRhdGVzKCR7dXBkYXRlc1N0cmluZy5qb2luKCcsICcpfSlgO1xuXG4gICAgY29uc3QgYXRvbWljUk1XID0gKHB0cjogc3RyaW5nLCB2YWw6IHN0cmluZykgPT4ge1xuICAgICAgbGV0IGF0b21pY0FkZFNuaXBwZXQgPSBgYXRvbWljQWRkKCR7cHRyfSwgYml0Y2FzdDxpMzI+KCR7dmFsfSkpYDtcbiAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdmbG9hdDMyJykge1xuICAgICAgICBhdG9taWNBZGRTbmlwcGV0ID0gYFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBvbGRCaXRzID0gMDtcbiAgICAgICAgICAgIHZhciBuZXdCaXRzID0gYml0Y2FzdDxpMzI+KCR7dmFsfSk7XG4gICAgICAgICAgICBsb29wIHtcbiAgICAgICAgICAgICAgbGV0IGluZm8gPSBhdG9taWNDb21wYXJlRXhjaGFuZ2VXZWFrKCR7cHRyfSwgb2xkQml0cywgbmV3Qml0cyk7XG4gICAgICAgICAgICAgIGlmIChpbmZvLmV4Y2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG9sZEJpdHMgPSBpbmZvLm9sZF92YWx1ZTtcbiAgICAgICAgICAgICAgbGV0IG9sZFZhbHVlID0gYml0Y2FzdDxmMzI+KG9sZEJpdHMpO1xuICAgICAgICAgICAgICBsZXQgbmV3VmFsdWUgPSBvbGRWYWx1ZSArICgke3ZhbH0pO1xuICAgICAgICAgICAgICBuZXdCaXRzID0gYml0Y2FzdDxpMzI+KG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIGA7XG4gICAgICB9XG4gICAgICBjb25zdCBhdG9taWNTdG9yZVNuaXBwZXQgPSBgYXRvbWljU3RvcmUoJHtwdHJ9LCBiaXRjYXN0PGkzMj4oJHt2YWx9KSk7YDtcbiAgICAgIHJldHVybiB0aGlzLnN1bUR1cGVJbmRpY2VzID8gYXRvbWljQWRkU25pcHBldCA6IGF0b21pY1N0b3JlU25pcHBldDtcbiAgICB9O1xuXG4gICAgY29uc3QgdXNlckNvZGUgPSBgXG4gICAgJHtnZXRVcGRhdGVzQ29vcmRzRnJvbUZsYXRJbmRleH1cblxuICAgICAgJHttYWluKCdpbmRleCcpfSB7XG4gICAgICAgIGlmIChpbmRleCA8IHVuaWZvcm1zLnNpemUpIHtcbiAgICAgICAgICBsZXQgY29vcmRzID0gZ2V0VXBkYXRlc0Nvb3Jkc0Zyb21GbGF0SW5kZXgoaW5kZXgpO1xuICAgICAgICAgIHZhciBmbGF0dGVuZWRJbmRleCA9IDA7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB1bmlmb3Jtcy5zbGljZURpbTsgaiA9IGogKyAxKSB7XG4gICAgICAgICAgICBsZXQgaW5kZXhJbnNpZGUgPSBpMzIocm91bmQoJHtpbmRpY2VzU25pcHBldH0pKTtcbiAgICAgICAgICAgIGZsYXR0ZW5lZEluZGV4ID0gZmxhdHRlbmVkSW5kZXggKyBpbmRleEluc2lkZSAqICR7c3RyaWRlU3RyaW5nfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IHVwZGF0ZVZhbHVlID1cbiAgICAgICAgICAgICAgJHttYXBUb1dnc2xUeXBlcyh0aGlzLnR5cGUsIGZhbHNlKX0oJHt1cGRhdGVzU25pcHBldH0pO1xuICAgICAgICAgIGxldCBmbGF0SW5kZXggPSBnZXRPdXRwdXRJbmRleEZyb21Db29yZHMoJHtvdXRDb29yZHNTdHJpbmd9KTtcblxuICAgICAgICAgICR7YXRvbWljUk1XKCcmcmVzdWx0W2ZsYXRJbmRleF0nLCAndXBkYXRlVmFsdWUnKX07XG4gICAgICAgIH1cbiAgICAgIH1gO1xuICAgIHJldHVybiB1c2VyQ29kZTtcbiAgfVxufVxuIl19