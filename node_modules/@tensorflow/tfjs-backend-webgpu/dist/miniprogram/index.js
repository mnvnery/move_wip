/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("@tensorflow/tfjs-core")):"function"==typeof define&&define.amd?define(["exports","@tensorflow/tfjs-core"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).tf=e.tf||{},e.tf)}(this,(function(e,t){"use strict";function n(e){if(e&&e.__esModule)return e;var t=Object.create(null);return e&&Object.keys(e).forEach((function(n){if("default"!==n){var r=Object.getOwnPropertyDescriptor(e,n);Object.defineProperty(t,n,r.get?r:{enumerable:!0,get:function(){return e[n]}})}})),t.default=e,t}var r=n(t),i=function(e,t){return i=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])},i(e,t)};function a(e,t,n,r){return new(n||(n=Promise))((function(i,a){function o(e){try{u(r.next(e))}catch(e){a(e)}}function s(e){try{u(r.throw(e))}catch(e){a(e)}}function u(e){var t;e.done?i(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(o,s)}u((r=r.apply(e,t||[])).next())}))}function o(e,t){var n,r,i,a,o={label:0,sent:function(){if(1&i[0])throw i[1];return i[1]},trys:[],ops:[]};return a={next:s(0),throw:s(1),return:s(2)},"function"==typeof Symbol&&(a[Symbol.iterator]=function(){return this}),a;function s(a){return function(s){return function(a){if(n)throw new TypeError("Generator is already executing.");for(;o;)try{if(n=1,r&&(i=2&a[0]?r.return:a[0]?r.throw||((i=r.return)&&i.call(r),0):r.next)&&!(i=i.call(r,a[1])).done)return i;switch(r=0,i&&(a=[2&a[0],i.value]),a[0]){case 0:case 1:i=a;break;case 4:return o.label++,{value:a[1],done:!1};case 5:o.label++,r=a[1],a=[0];continue;case 7:a=o.ops.pop(),o.trys.pop();continue;default:if(!(i=o.trys,(i=i.length>0&&i[i.length-1])||6!==a[0]&&2!==a[0])){o=0;continue}if(3===a[0]&&(!i||a[1]>i[0]&&a[1]<i[3])){o.label=a[1];break}if(6===a[0]&&o.label<i[1]){o.label=i[1],i=a;break}if(i&&o.label<i[2]){o.label=i[2],o.ops.push(a);break}i[2]&&o.ops.pop(),o.trys.pop();continue}a=t.call(e,o)}catch(e){a=[6,e],r=0}finally{n=i=0}if(5&a[0])throw a[1];return{value:a[0]?a[1]:void 0,done:!0}}([a,s])}}}function s(e){var t="function"==typeof Symbol&&Symbol.iterator,n=t&&e[t],r=0;if(n)return n.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&r>=e.length&&(e=void 0),{value:e&&e[r++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")}function u(e,t){var n="function"==typeof Symbol&&e[Symbol.iterator];if(!n)return e;var r,i,a=n.call(e),o=[];try{for(;(void 0===t||t-- >0)&&!(r=a.next()).done;)o.push(r.value)}catch(e){i={error:e}}finally{try{r&&!r.done&&(n=a.return)&&n.call(a)}finally{if(i)throw i.error}}return o}function l(){for(var e=[],t=0;t<arguments.length;t++)e=e.concat(u(arguments[t]));return e}var d=t.env();d.registerFlag("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE",(function(){return 15})),d.registerFlag("WEBGPU_CPU_FORWARD",(function(){return!0})),d.registerFlag("WEBGPU_MATMUL_PROGRAM_TYPE",(function(){return-1})),d.registerFlag("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE",(function(){return!1})),d.registerFlag("WEBGPU_USE_LOW_POWER_GPU",(function(){return!1})),d.registerFlag("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD",(function(){return 1e3})),d.registerFlag("WEBGPU_USE_PROFILE_TOOL",(function(){return!1})),d.registerFlag("WEBGPU_IMPORT_EXTERNAL_TEXTURE",(function(){return!0})),d.registerFlag("WEBGPU_USE_NAIVE_CONV2D_DEBUG",(function(){return!1}));var h=function(){function e(e){e&&(this.vendor=e.vendor)}return e.prototype.isIntel=function(){return"intel"===this.vendor},e}(),p=function(){function e(e){this.device=e,this.numUsedBuffers=0,this.numFreeBuffers=0,this.freeBuffers=new Map,this.usedBuffers=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}return e.prototype.acquireUploadBuffer=function(e,t){return this.acquireBuffer(e,t,!0)},e.prototype.acquireBuffer=function(e,t,n){void 0===n&&(n=!1);var r=c(e,t);if(this.freeBuffers.has(r)||this.freeBuffers.set(r,[]),this.usedBuffers.has(r)||this.usedBuffers.set(r,[]),this.numBytesUsed+=e,this.numUsedBuffers++,this.freeBuffers.get(r).length>0){this.numFreeBuffers--;var i=this.freeBuffers.get(r).shift();return this.usedBuffers.get(r).push(i),i}this.numBytesAllocated+=e;var a=this.device.createBuffer({size:e,usage:t,mappedAtCreation:n});return this.usedBuffers.get(r).push(a),a},e.prototype.releaseBuffer=function(e,t,n){if(0!==this.freeBuffers.size){var r=c(t,n);this.freeBuffers.has(r)||this.freeBuffers.set(r,[]),this.freeBuffers.get(r).push(e),this.numFreeBuffers++,this.numUsedBuffers--;var i=this.usedBuffers.get(r),a=i.indexOf(e);if(a<0)throw new Error("Cannot release a buffer that was never provided by this buffer manager");i.splice(a,1),this.numBytesUsed-=t}},e.prototype.releaseUploadBuffer=function(e,t,n){var r=this;e.mapAsync(GPUMapMode.WRITE).then((function(){r.releaseBuffer(e,t,n)}),(function(e){}))},e.prototype.getNumUsedBuffers=function(){return this.numUsedBuffers},e.prototype.getNumFreeBuffers=function(){return this.numFreeBuffers},e.prototype.dispose=function(){this.freeBuffers.forEach((function(e,t){e.forEach((function(e){e.destroy()}))})),this.usedBuffers.forEach((function(e,t){e.forEach((function(e){e.destroy()}))})),this.freeBuffers=new Map,this.usedBuffers=new Map,this.numUsedBuffers=0,this.numFreeBuffers=0,this.numBytesUsed=0,this.numBytesAllocated=0},e}();function c(e,t){return e+"_"+t}var f=function(){function e(e){this.device=e,this.numUsedTextures=0,this.numFreeTextures=0,this.freeTextures=new Map,this.usedTextures=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}return e.prototype.acquireTexture=function(e,t,n,r){var i=e*t*v(n),a=m(e,t,n,r);if(this.freeTextures.has(a)||this.freeTextures.set(a,[]),this.usedTextures.has(a)||this.usedTextures.set(a,[]),this.numBytesUsed+=i,this.numUsedTextures++,this.freeTextures.get(a).length>0){this.numFreeTextures--;var o=this.freeTextures.get(a).shift();return this.usedTextures.get(a).push(o),o}this.numBytesAllocated+=i;var s=this.device.createTexture({size:[e,t],format:n,usage:r});return this.usedTextures.get(a).push(s),s},e.prototype.releaseTexture=function(e,t,n,r,i){if(0!==this.freeTextures.size){var a=m(t,n,r,i);this.freeTextures.has(a)||this.freeTextures.set(a,[]),this.freeTextures.get(a).push(e),this.numFreeTextures++,this.numUsedTextures--;var o=this.usedTextures.get(a),s=o.indexOf(e);if(s<0)throw new Error("Cannot release a texture that was never provided by this texture manager");o.splice(s,1);var u=t*n*v(r);this.numBytesUsed-=u}},e.prototype.getNumUsedTextures=function(){return this.numUsedTextures},e.prototype.getNumFreeTextures=function(){return this.numFreeTextures},e.prototype.dispose=function(){this.freeTextures.forEach((function(e,t){e.forEach((function(e){e.destroy()}))})),this.usedTextures.forEach((function(e,t){e.forEach((function(e){e.destroy()}))})),this.freeTextures=new Map,this.usedTextures=new Map,this.numUsedTextures=0,this.numFreeTextures=0,this.numBytesUsed=0,this.numBytesAllocated=0},e}();function m(e,t,n,r){return e+"_"+t+"_"+n+"_"+r}function v(e){if("rgba8unorm"===e)return 16;throw new Error(e+" is not supported!")}function g(e,t){if(Math.max.apply(Math,l(e))>3)throw new Error("Cannot symbolically compute strides for rank > 4 tensor.");var n=e.length,r=e.map((function(e){return t+"["+e+"]"})),i=new Array(n-1);i[n-2]=r[n-1];for(var a=n-3;a>=0;--a)i[a]="("+i[a+1]+" * "+r[a+1]+")";return i}var b=function(e,n,r,i){var a=function(e,n,r){var i=[];if(i.push("\n      const workGroupSizeX = "+r.workGroupSize[0]+"u;\n      const workGroupSizeY = "+r.workGroupSize[1]+"u;\n      const workGroupSizeZ = "+r.workGroupSize[2]+"u;\n\n      var<private> localId: vec3<u32>;\n      var<private> globalId: vec3<u32>;\n      var<private> numWorkgroups: vec3<u32>;\n\n      // Only used when the y/z dimension of workgroup size is 1.\n      fn getGlobalIndex() -> i32 {\n        "+(C(r)?"  return i32(globalId.x);":"  let localInvocationIndex = localId.z * workGroupSizeX * workGroupSizeY +\n                   localId.y * workGroupSizeX + localId.x;\n               let workGroupID = (globalId - localId)/vec3<u32>(\n                   workGroupSizeX, workGroupSizeY, workGroupSizeZ);\n\n               return i32((workGroupID.z * numWorkgroups.x * numWorkgroups.y +\n                   workGroupID.y * numWorkgroups.x + workGroupID.x) *\n                   (workGroupSizeX * workGroupSizeY * workGroupSizeZ) +\n                   localInvocationIndex);\n        ")+"\n      }\n    "),r.isFromPixels)return i.push("\n        struct Uniform {\n          size            : i32,\n          numChannels     : i32,\n          outShapeStrides : vec2<i32>,\n        };\n\n        @group(0) @binding(0) var<storage, read_write> result: array<"+R(n.dtype,r.isVec4)+">;\n        @group(0) @binding(2) var<uniform> uniforms: Uniform;\n      "),[k,i.join("\n"),I(n.shape),r.getUserCode()].join("\n");var a="struct Uniforms { NAN : f32, ";r.variableNames.forEach((function(t,n){var r=x(e[n].shape.length);a+=t.charAt(0).toLowerCase()+t.slice(1)+"Shape : "+r+", "}));var o=x(n.shape.length);a+="outShape : "+o+", ";var s=x(n.shape.length-1);a+="\n         outShapeStrides: "+s+", ",r.size&&(a+="size : i32, ");r.uniforms&&(a+=r.uniforms);a=function(e){var t=/(\w+)\s*:\s*vec(5|6)/g;e=e.replace(t,(function(e){return"@align(16) "+e}));var n=/vec(5|6)\s*,\s*(\w+)/g;return e=e.replace(n,(function(e,t,n){return"vec"+t+", @align(16) "+n}))}(a+="};"),i.push(a),r.atomic?i.push("\n      @group(0) @binding(0) var<storage, read_write> result: array<atomic<i32>>;\n    "):i.push("\n      @group(0) @binding(0) var<storage, read_write> result: array<"+R(n.dtype,r.isVec4)+">;\n    ");r.variableNames.forEach((function(t,n){i.push("\n      @group(0) @binding("+(1+n)+") var<storage, read> "+t+": array<"+(r.variableTypes?r.variableTypes[n]:R(e[n].dtype,r.isVec4))+">;\n        ")})),""!==a&&i.push("\n      @group(0) @binding("+(1+r.variableNames.length)+") var<uniform> uniforms: Uniforms;\n      ");var u=function(e,t){var n=t.x,r=t.y,i=void 0===r?[]:r,a=t.z,o=void 0===a?[]:a,s=e.length,u=n.length+i.length+o.length;if(u!==s)return"";if(n.length===s){return"fn getOutputCoords() -> "+x(s)+"{\n    let globalIndex = getGlobalIndex();\n    return getCoordsFromIndex(globalIndex);\n  }\n  "}for(var l="",d=[n,i,o],h=0;h<d.length;h++){var p=d[h];if(0!==p.length)if(1===p.length)l+="let d"+p[0]+" = i32(globalId["+h+"]);";else{var c=g(p,"uniforms.outShape");l+="var index"+h+" = i32(globalId["+h+"]);";for(var f=0;f<c.length;f++)l+="let d"+p[f]+" = index"+h+" / "+c[f]+";",f===c.length-1?l+="let d"+p[f+1]+" = index"+h+" - d"+p[f]+" * "+c[f]+";":l+="index"+h+" = index"+h+" - d"+p[f]+" * "+c[f]+";"}}var m=[];for(h=0;h<u;h++)m.push("d"+h);var v=x(u),b="fn getOutputCoords() -> "+v+" {\n  "+l+"\n";0===m.length?b+="return "+v+"(0); }":b+="return "+v+"("+m.join(",")+"); }";return b}(n.shape,r.dispatchLayout),l=[k,i.join("\n"),I(n.shape),u,S(n.shape.length)];r.atomic||l.push(function(e,t,n){var r,i=e.length,a=R(t,n);r=n?"fn setOutputAtIndex(flatIndex : i32, value : vec4<f32>) {\n      result[flatIndex] = "+a+"(value);\n    }\n    fn setOutputAtIndexI32(flatIndex : i32, value : vec4<i32>) {\n      result[flatIndex] = "+a+"(value);\n    }":"fn setOutputAtIndex(flatIndex : i32, value : f32) {\n      result[flatIndex] = "+a+"(value);\n    }\n    fn setOutputAtIndexI32(flatIndex : i32, value : i32) {\n      result[flatIndex] = "+a+"(value);\n    }";if(i>=2){var o=["d0","d1","d2","d3","d4","d5"].slice(0,i),s=x(i);r+=n?"\n      fn setOutputAtCoords("+o.map((function(e){return e+" : i32"})).join(", ")+", value : vec4<f32>) {\n        let flatIndex = getOutputIndexFromCoords("+s+"("+o.join(", ")+"));\n        setOutputAtIndex(flatIndex / 4, value);\n      }\n      fn setOutputAtCoordsI32("+o.map((function(e){return e+" : i32"})).join(", ")+", value : vec4<i32>) {\n        let flatIndex = getOutputIndexFromCoords("+s+"("+o.join(", ")+"));\n        setOutputAtIndexI32(flatIndex / 4, value);\n      }\n    ":"\n      fn setOutputAtCoords("+o.map((function(e){return e+" : i32"})).join(", ")+", value : f32) {\n        let flatIndex = getOutputIndexFromCoords("+s+"("+o.join(", ")+"));\n        setOutputAtIndex(flatIndex, value);\n      }\n      fn setOutputAtCoordsI32("+o.map((function(e){return e+" : i32"})).join(", ")+", value : i32) {\n        let flatIndex = getOutputIndexFromCoords("+s+"("+o.join(", ")+"));\n        setOutputAtIndexI32(flatIndex, value);\n      }\n    "}return r}(n.shape,n.dtype,r.isVec4));var d=e.map((function(e,i){return function(e,n,r,i){var a=function(e,t){var n=e.name,r=e.shape.length,i=x(r),a="get"+n.charAt(0).toUpperCase()+n.slice(1),o=["d0","d1","d2","d3","d4","d5"].slice(0,r),s=o.map((function(e){return e+" : i32"})).join(", ");if(r<1)return t?"\n        fn "+a+"() -> vec4<f32> {\n          return vec4<f32>("+n+"[0]);\n        }\n      ":"\n      fn "+a+"() ->f32 {\n        return f32("+n+"[0]);\n      }\n    ";var u="uniforms."+(n.charAt(0).toLowerCase()+n.slice(1))+"Shape",l=r+"D";0===r&&(l="1D");if(t)return"\n      fn "+a+"("+s+") -> vec4<f32> {\n        return vec4<f32>("+n+"[getIndexFromCoords"+l+"("+i+"("+o.join(",")+"),\n          "+u+") / 4]);\n      }\n      ";return"\n    fn "+a+"("+s+") -> f32 {\n      return f32("+n+"[getIndexFromCoords"+l+"("+i+"("+o.join(",")+"),\n        "+u+")]);\n    }\n   "}(e,r);e.shape.length<=n.length&&(a+=function(e,n,r,i){var a=e.name,o=a.charAt(0).toUpperCase()+a.slice(1),s="get"+o+"ByOutput",u=e.shape.length,l=n.length,d=x(l);if(t.util.arraysEqual(e.shape,n)&&i)return r?"\n      fn "+s+"Index(globalIndex : i32) -> vec4<f32> {\n        return vec4<f32>("+a+"[globalIndex]);\n      }\n\n      fn "+s+"Coords(coords : "+d+") -> vec4<f32> {\n        return vec4<f32>("+a+"["+(l>1?"getOutputIndexFromCoords(coords)":"coords")+" / 4]);\n      }\n      ":"\n    fn "+s+"Index(globalIndex : i32) -> f32 {\n      return f32("+a+"[globalIndex]);\n    }\n\n    fn "+s+"Coords(coords : "+d+") -> f32 {\n      return f32("+a+"["+(l>1?"getOutputIndexFromCoords(coords)":"coords")+"]);\n    }\n    ";var h=t.backend_util.getBroadcastDims(e.shape,n),p=l-u,c="";if(0===u)return r?"\n    fn "+s+"Index(globalIndex : i32) -> vec4<f32> {\n      return get"+o+"();\n    }\n\n    fn "+s+"Coords(coords : "+d+") -> vec4<f32> {\n      return get"+o+"();\n    }\n  ":"\n    fn "+s+"Index(globalIndex : i32) -> f32{\n      return get"+o+"();\n    }\n\n    fn "+s+"Coords(coords : "+d+") -> f32{\n      return get"+o+"();\n    }\n  ";c=l<2&&h.length>=1?"coords = 0;":h.map((function(e){return"coords."+y(e+p)+" = 0;"})).join("\n");var f="";if(l<2&&u>0)f="coords";else if(l>1){var m=x(u),v=e.shape.map((function(e,t){return"coords."+y(t+p)})).join(", ");f=m+"("+v+")"}else f="coords";var g="uniforms."+(a.charAt(0).toLowerCase()+a.slice(1))+"Shape",b=u+"D";if(r)return"\n    fn "+s+"Index(globalIndex : i32) -> vec4<f32> {\n      var coords = getCoordsFromIndex(globalIndex);\n      "+c+"\n      return "+a+"[getIndexFromCoords"+b+"("+f+", "+g+") / 4];\n    }\n\n    fn "+s+"Coords(coordsIn : "+d+") -> vec4<f32> {\n      var coords = coordsIn;\n      "+c+"\n      return "+a+"[getIndexFromCoords"+b+"("+f+", "+g+") / 4];\n    }\n  ";return"\n  fn "+s+"Index(globalIndex : i32) -> f32 {\n    var coords = getCoordsFromIndex(globalIndex);\n    "+c+"\n    return f32("+a+"[getIndexFromCoords"+b+"("+f+", "+g+")]);\n  }\n\n  fn "+s+"Coords(coordsIn : "+d+") -> f32 {\n    var coords = coordsIn;\n    "+c+"\n    return f32("+a+"[getIndexFromCoords"+b+"("+f+", "+g+")]);\n  }\n"}(e,n,r,i));return a}(e,n.shape,r.variableTypes?"vec4<f32>"===r.variableTypes[i]:r.isVec4,r.dispatchLayout.x.length===n.shape.length)})).join("\n");return l.push(d),l.push(r.getUserCode()),l.join("\n")}(r,{dtype:i.dtype,shape:i.shape},n),o=e.createShaderModule({code:a,label:n.constructor.name});return e.createComputePipeline({compute:{module:o,entryPoint:"_start"},label:n.constructor.name,layout:"auto"})};function x(e){if(e<=1)return"i32";if(2===e)return"vec2<i32>";if(3===e)return"vec3<i32>";if(4===e)return"vec4<i32>";if(5===e)return"vec5";if(6===e)return"vec6";throw Error("GPU for rank "+e+" is not yet supported")}function y(e){if(0===e)return"x";if(1===e)return"y";if(2===e)return"z";if(3===e)return"w";if(4===e)return"u";if(5===e)return"v";throw Error("Index "+e+" is not yet supported")}function w(){for(var e,t=[],n=0;n<arguments.length;n++)t[n]=arguments[n];switch(t.length){case 0:e="\n        \n  @compute @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n\n        fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,\n                  @builtin(global_invocation_id) GlobalId : vec3<u32>,\n                  @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {\n          localId = LocalId;\n          globalId = GlobalId;\n          numWorkgroups = NumWorkgroups;\n          main();\n        }\n\n        fn main()\n      ";break;case 1:e="\n        \n  @compute @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n\n        fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,\n                  @builtin(global_invocation_id) GlobalId : vec3<u32>,\n                  @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {\n          localId = LocalId;\n          globalId = GlobalId;\n          numWorkgroups = NumWorkgroups;\n          main(getGlobalIndex());\n        }\n\n        fn main("+t[0]+" : i32)\n      ";break;default:throw Error("Unreachable")}return e}var k="\n  struct vec5 {x: i32, y: i32, z: i32, w: i32, u: i32};\n  struct vec6 {x: i32, y: i32, z: i32, w: i32, u: i32, v: i32};\n\n  // Checks whether coordinates lie within the bounds of the shape.\n  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {\n    return all(coord >= vec2<i32>(0)) && all(coord < shape);\n  }\n  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {\n    return all(coord >= vec3<i32>(0)) && all(coord < shape);\n  }\n  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {\n    return all(coord >= vec4<i32>(0)) && all(coord < shape);\n  }\n\n  fn getIndexFromCoords1D(coord : i32, shape : i32) -> i32 {\n    return coord;\n  }\n  fn getIndexFromCoords2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {\n    return dot(coords, vec2<i32>(shape.y, 1));\n  }\n  fn getIndexFromCoords3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {\n    return dot(coords, vec3<i32>(shape.y * shape.z, shape.z, 1));\n  }\n  fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n    return dot(coords, vec4<i32>(\n        shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\n  }\n  fn getIndexFromCoords5D(coords : vec5, shape : vec5) -> i32 {\n    let shapeStrides: vec5 = vec5(shape.y * shape.z * shape.w * shape.u, shape.z * shape.w * shape.u, shape.w * shape.u, shape.u, 1);\n    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u;\n  }\n  fn getIndexFromCoords6D(coords : vec6, shape : vec6) -> i32 {\n    let shapeStrides: vec6 = vec6(shape.y * shape.z * shape.w * shape.u * shape.v, shape.z * shape.w * shape.u * shape.v, shape.w * shape.u * shape.v, shape.u * shape.v, shape.v, 1);\n    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u + coords.v*shapeStrides.v;\n  }\n\n  fn idiv(a: i32, b: i32, sign: f32) -> i32 {\n    var res: i32 = a / b;\n    let modulo: i32 = a % b;\n    if (sign < 0. && modulo != 0) {\n      res = res - 1;\n    }\n    return res;\n  }\n\n  // NaN defination in IEEE 754-1985 is :\n  //   - sign = either 0 or 1.\n  //   - biased exponent = all 1 bits.\n  //   - fraction = anything except all 0 bits (since all 0 bits represents infinity).\n  // https://en.wikipedia.org/wiki/IEEE_754-1985#Representation_of_non-numbers\n  fn isnan(val: f32) -> bool {\n    let floatToUint: u32 = bitcast<u32>(val);\n    return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n  }\n  fn isnanVec4(val : vec4<f32>) -> vec4<bool> {\n    return vec4<bool>(isnan(val[0]), isnan(val[1]), isnan(val[2]), isnan(val[3]));\n  }\n";function I(e){var n=e.length;if(n<=1)return"fn getCoordsFromIndex(index : i32) -> i32 { return index; }";for(var r,i=t.util.computeStrides(e),a=x(n),o=[],s=0;s<n;s++)o.push("d"+s);return 1===i.length?"    fn getCoordsFromIndex(index : i32) -> vec2<i32> {\n      let d0 = index / uniforms.outShapeStrides; let d1 = index - d0 * uniforms.outShapeStrides;\n      return vec2<i32>(d0, d1);\n    }":(r="var index2 = index;"+i.map((function(e,t){return"let "+o[t]+" = index2 / uniforms.outShapeStrides."+y(t)+"; "+(t===i.length-1?"let "+o[t+1]+" = index2 - "+o[t]+" * uniforms.outShapeStrides."+y(t):"index2 = index2 - "+o[t]+" * uniforms.outShapeStrides."+y(t))+";"})).join(""),"\n    fn getCoordsFromIndex(index : i32) -> "+a+" {\n      "+r+"\n      return "+a+"("+o.join(",")+");\n    }\n  ")}function S(e){var n="";switch(e){case 0:case 1:n+="\n        fn getOutputIndexFromCoords(coords : i32) -> i32 {\n          return coords;\n        }\n        ";break;case 2:n+="\n        fn getOutputIndexFromCoords(coords : vec2<i32>) -> i32 {\n          return dot(coords, vec2<i32>(uniforms.outShapeStrides, 1));\n        }\n        ";break;case 3:n+="\n        fn getOutputIndexFromCoords(coords : vec3<i32>) -> i32 {\n          return dot(coords, vec3<i32>(uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, 1));\n        }\n        ";break;case 4:n+="\n        fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\n          return dot(coords, vec4<i32>(\n            uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, uniforms.outShapeStrides.z, 1));\n        }\n        ";break;case 5:n+="\n        fn getOutputIndexFromCoords(coords : vec5) -> i32 {\n          return coords.x * uniforms.outShapeStrides.x +\n              coords.y * uniforms.outShapeStrides.y +\n              coords.z * uniforms.outShapeStrides.z +\n              coords.w * uniforms.outShapeStrides.w +\n              coords.u;\n        }\n        ";break;case 6:n+="\n        fn getOutputIndexFromCoords(coords : vec6) -> i32 {\n          return coords.x * uniforms.outShapeStrides.x +\n              coords.y * uniforms.outShapeStrides.y +\n              coords.z * uniforms.outShapeStrides.z +\n              coords.w * uniforms.outShapeStrides.w +\n              coords.u * uniforms.outShapeStrides.u +\n              coords.v;\n        }\n        ";break;default:t.util.assert(!1,(function(){return"Unsupported "+e+"D shape"}))}return n}function C(e){return 1===e.dispatch[1]&&1===e.dispatch[2]}function R(e,t){return"float32"===e?t?"vec4<f32>":"f32":"int32"===e||"bool"===e?t?"vec4<i32>":"i32":e}var A,T=function(e){for(var t=1,n=0;n<e.length;n++)t*=e[n];return t};function z(e,t,n,r){void 0===n&&(n=[1,1,1]),void 0===r&&(r=[1,1,1]);var i=u([Math.ceil(T(e.x.map((function(e){return t[e]})))/(n[0]*r[0])),e.y?Math.ceil(T(e.y.map((function(e){return t[e]})))/(n[1]*r[1])):1,e.z?Math.ceil(T(e.z.map((function(e){return t[e]})))/(n[2]*r[2])):1],3);return[i[0],i[1],i[2]]}function P(e,t,n,r){void 0===r&&(r=!1);var i=[8,8,1],a=[4,4,1];return r||(e<=8&&(a[1]=1),t<=16&&n<=16&&(i[0]=4)),{workGroupSize:i,elementsPerThread:a}}function _(e,t,n){if(void 0===n&&(n=!1),n)return[8,8,1];var r=T(e.x.map((function(e){return t[e]}))),i=T(e.y.map((function(e){return t[e]})));return r<=4?[4,16,1]:i<=4?[16,4,1]:[16,16,1]}function N(e,t,n){if(void 0===n&&(n=!1),n)return[4,4,1];var r=T(e.x.map((function(e){return t[e]}))),i=T(e.y.map((function(e){return t[e]})));return r<=4?[1,2,1]:i<=4?[2,1,1]:[2,2,1]}function B(e){return{x:e.map((function(e,t){return t}))}}function E(e){if("float32"===e||"int32"===e||"bool"===e||"string"===e)return 4;if("complex64"===e)return 8;throw new Error("Unknown dtype "+e)}function F(e,t){if("float32"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t||"string"===t)return Uint8Array.from(new Int32Array(e));throw new Error("Unknown dtype "+t)}function G(){return("undefined"!=typeof window||"undefined"!=typeof WorkerGlobalScope)&&!!navigator.gpu}!function(e){e[e.MatMulReduceProgram=0]="MatMulReduceProgram",e[e.MatMulSplitKProgram=1]="MatMulSplitKProgram",e[e.MatMulSmallOutputSizeProgram=2]="MatMulSmallOutputSizeProgram",e[e.MatMulPackedProgram=3]="MatMulPackedProgram",e[e.MatMulMax=4]="MatMulMax"}(A||(A={}));var L={__proto__:null,tilesFitEvenlyIntoShape:function(e,t){if(e.length!==t.length)throw new Error("Cannot compute whether rank "+e.length+" tiles fit evenly into rank "+t.length+" shape - ranks must match.");return t.every((function(t,n){return t%e[n]==0}))},computeDispatch:z,computeWorkGroupInfoForMatMul:P,computeWorkGroupSizeForConv2d:_,computeWorkPerThreadForConv2d:N,flatDispatchLayout:B,GPUBytesPerElement:E,ArrayBufferToTypedArray:F,isWebGPUSupported:G,get MatMulProgramType(){return A}},O=t.env().getNumber("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD"),U=function(e){function n(n,r){var i=e.call(this)||this;if(i.commandQueueOwnedIds=new WeakSet,i.dispatchNumberInEncoder=0,i.disposed=!1,i.downloadWaitMs=0,i.tensorDataPendingDisposal=[],i.stagingPendingDisposal=[],i.uniformPendingDisposal=[],i.uploadWaitMs=0,!G())throw new Error("WebGPU is not supported on this device");return i.pipelineCache={},i.device=n,i.queue=n.queue,i.currentCommandEncoder=null,i.currentComputePass=null,i.supportTimeQuery=n.features.has("timestamp-query"),i.adapterInfo=new h(r),i.bufferManager=new p(i.device),i.textureManager=new f(i.device),i.tensorMap=new t.DataStorage(i,t.engine()),i.supportTimeQuery&&(i.querySet=i.device.createQuerySet({type:"timestamp",count:2})),t.env().getBool("WEBGPU_USE_PROFILE_TOOL")&&(i.dummyCanvas=document.createElement("canvas"),i.dummyCanvas.width=1,i.dummyCanvas.height=1,i.dummyContext=i.dummyCanvas.getContext("webgpu"),i.dummyContext.configure({device:n,format:"bgra8unorm"}),document.body.appendChild(i.dummyCanvas)),i}return function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Class extends value "+String(t)+" is not a constructor or null");function n(){this.constructor=e}i(e,t),e.prototype=null===t?Object.create(t):(n.prototype=t.prototype,new n)}(n,e),n.prototype.nextDataId=function(){return n.nextDataId++},n.prototype.floatPrecision=function(){return 32},n.prototype.defaultGpuBufferUsage=function(){return GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST},n.prototype.disposeData=function(e,t){if(void 0===t&&(t=!1),this.tensorDataPendingDisposal.indexOf(e)>=0)return!1;if(!this.tensorMap.has(e))return!0;var n=this.tensorMap.get(e);if(this.decRef(e),!t&&n.refCount>0)return!1;if(this.commandQueueOwnedIds.has(e))return this.tensorDataPendingDisposal.push(e),!1;var r=this.tensorMap.get(e).complexTensorInfos;return null!=r&&(this.disposeData(r.real.dataId,t),this.disposeData(r.imag.dataId,t)),this.releaseResource(e),this.tensorMap.delete(e),!0},n.prototype.memory=function(){return{numBytesInGPU:this.bufferManager.numBytesUsed,numBytesAllocatedInGPU:this.bufferManager.numBytesAllocated,unreliable:!1}},n.prototype.releaseResource=function(e){var t=this.tensorMap.get(e);if(t&&t.resourceInfo){if("texture"in t.resourceInfo){var n=t.resourceInfo;n.texture instanceof GPUTexture&&this.textureManager.releaseTexture(n.texture,n.width,n.height,n.format,n.usage),n.texture=null}else{var r=t.resourceInfo;this.bufferManager.releaseBuffer(r.buffer,r.size,r.usage),r.buffer=null}t.resourceInfo=null}},n.prototype.refCount=function(e){return this.tensorMap.has(e)?this.tensorMap.get(e).refCount:0},n.prototype.incRef=function(e){this.tensorMap.get(e).refCount++},n.prototype.decRef=function(e){this.tensorMap.has(e)&&this.tensorMap.get(e).refCount--},n.prototype.write=function(e,t,n){if("complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");var r={id:this.nextDataId()};return this.tensorMap.set(r,{dtype:n,shape:t,values:e,refCount:1}),r},n.prototype.move=function(e,t,n,r,i){if("complex64"===r)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.tensorMap.set(e,{dtype:r,shape:n,values:t,refCount:i})},n.prototype.submitQueue=function(){var e=this;this.ensureComputePassEnded(),this.queue.submit([this.currentCommandEncoder.finish()]),this.currentCommandEncoder=null,this.dispatchNumberInEncoder=0,this.commandQueueOwnedIds=new WeakSet,this.tensorDataPendingDisposal.forEach((function(t){e.releaseResource(t),e.tensorMap.delete(t)})),this.uniformPendingDisposal.forEach((function(t){return e.bufferManager.releaseBuffer(t.buffer,t.size,t.usage)})),this.stagingPendingDisposal.forEach((function(t){return e.bufferManager.releaseUploadBuffer(t.buffer,t.size,t.usage)})),this.tensorDataPendingDisposal=[],this.uniformPendingDisposal=[],this.stagingPendingDisposal=[]},n.prototype.ensureCommandEncoderReady=function(){this.currentCommandEncoder||(this.currentCommandEncoder=this.device.createCommandEncoder())},n.prototype.ensureComputePassEnded=function(){this.currentComputePass&&(this.currentComputePass.end(),this.currentComputePass=null)},n.prototype.getComputePass=function(){return this.currentComputePass||(this.currentComputePass=this.currentCommandEncoder.beginComputePass()),this.currentComputePass},n.prototype.getBufferData=function(e,n){return a(this,void 0,void 0,(function(){var r,i;return o(this,(function(a){switch(a.label){case 0:return r=this.bufferManager.acquireBuffer(n,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ),this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.copyBufferToBuffer(e,0,r,0,n),this.submitQueue(),[4,r.mapAsync(GPUMapMode.READ)];case 1:return a.sent(),i=r.getMappedRange().slice(0),r.unmap(),null!=r&&this.bufferManager.releaseBuffer(r,n,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ),t.env().getBool("WEBGPU_USE_PROFILE_TOOL")&&(t.util.assert(void 0!==this.dummyContext,(function(){return"Fail to get context for profiling tool"})),this.dummyContext.getCurrentTexture()),[2,i]}}))}))},n.prototype.convertAndCacheOnCPU=function(e,t){var n=this.tensorMap.get(e);return this.releaseResource(e),n.values=t,n.values},n.prototype.readSync=function(e){var t=this.tensorMap.get(e).values;if(null==t)throw new Error("WebGPU readSync is only available for CPU-resident tensors.");return t},n.prototype.read=function(e){return a(this,void 0,void 0,(function(){var n,r,i,a,s,u,l,d;return o(this,(function(o){switch(o.label){case 0:if(!this.tensorMap.has(e))throw new Error("Tensor "+e+" was not registered!");return n=this.tensorMap.get(e),null!=(r=n.values)?[2,this.convertAndCacheOnCPU(e,r)]:"complex64"!==n.dtype?[3,2]:[4,Promise.all([this.read(n.complexTensorInfos.real.dataId),this.read(n.complexTensorInfos.imag.dataId)])];case 1:return a=o.sent(),s=a[0],u=a[1],i=t.backend_util.mergeRealAndImagArrays(s,u),[3,4];case 2:return l=n.resourceInfo,[4,this.getBufferData(l.buffer,l.size)];case 3:d=o.sent(),i=F(d,n.dtype),o.label=4;case 4:return this.convertAndCacheOnCPU(e,i),[2,i]}}))}))},n.prototype.readToGPU=function(e){var n=this.tensorMap.get(e),r=n.values,i=n.dtype,a=n.shape,o=n.resourceInfo;if("complex64"===i)throw new Error("Does not support reading buffer for complex64 dtype.");if(null==o)throw null!=r?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");var s=o.size,u=this.bufferManager.acquireBuffer(s,o.usage);this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.copyBufferToBuffer(o.buffer,0,u,0,s),this.submitQueue();var l=this.makeTensorInfo(a,i),d=t.engine().makeTensorFromTensorInfo(l);return this.tensorMap.get(l.dataId).resourceInfo={size:s,usage:this.defaultGpuBufferUsage(),buffer:u},{tensorRef:d,buffer:u,bufSize:s}},n.prototype.bufferSync=function(e){var n=this.readSync(e.dataId);if("string"===e.dtype)try{var r=n.map((function(e){return t.util.decodeString(e)}));return t.buffer(e.shape,e.dtype,r)}catch(e){throw new Error("Failed to decode encoded string bytes into utf-8")}return t.buffer(e.shape,e.dtype,n)},n.prototype.time=function(e){return a(this,void 0,void 0,(function(){var n,r,i,a,s,u,l;return o(this,(function(o){switch(o.label){case 0:return this.supportTimeQuery||console.warn("This device doesn't support timestamp-query extension. Start Chrome browser with flag --disable-dawn-features=disallow_unsafe_apis then try again. Otherwise, zero will be shown for the kernel time when profiling mode is enabled. Using performance.now is not workable for webgpu since it doesn't support synchronous data read from GPU."),n=this.activeTimers,r=[],i=!1,null==this.programTimersStack?(this.programTimersStack=r,i=!0):this.activeTimers.push(r),this.activeTimers=r,e(),a=t.util.flatten(this.activeTimers.map((function(e){return e.query}))).filter((function(e){return null!=e})),s=t.util.flatten(this.activeTimers.map((function(e){return e.name}))).filter((function(e){return null!=e})),this.activeTimers=n,i&&(this.programTimersStack=null),u={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null},[4,Promise.all(a)];case 1:return l=o.sent(),u.kernelMs=t.util.sum(l),u.getExtraProfileInfo=function(){return l.map((function(e,t){return{name:s[t],ms:e}})).map((function(e){return e.name+": "+e.ms})).join(", ")},this.uploadWaitMs=0,this.downloadWaitMs=0,[2,u]}}))}))},n.prototype.makeTensorInfo=function(e,n,r){return"string"===n&&null!=r&&r.length>0&&t.util.isString(r[0])&&(r=r.map((function(e){return t.util.encodeString(e)}))),{dataId:this.write(r,e,n),shape:e,dtype:n}},n.prototype.tensorToBinding=function(e){if(!e)return null;var t=this.tensorMap.get(e.dataId);if("texture"in t.resourceInfo){var n=t.resourceInfo;return n.texture instanceof GPUExternalTexture?n.texture:n.texture.createView()}var r=t.resourceInfo;return{offset:0,size:r.size,buffer:r.buffer}},n.prototype.getQueryTime=function(e){return a(this,void 0,void 0,(function(){return o(this,(function(t){return this.supportTimeQuery?[2,this.getTimeFromQuerySet(e)]:[2,0]}))}))},n.prototype.uploadToGPU=function(e){var n=this.tensorMap.get(e);if(!n.resourceInfo){var r=E(n.dtype)*t.util.sizeFromShape(n.shape),i=this.bufferManager.acquireBuffer(r,this.defaultGpuBufferUsage());if(n.resourceInfo={size:r,usage:this.defaultGpuBufferUsage(),buffer:i},n.values){var a=this.bufferManager.acquireUploadBuffer(r,GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC),o=a.getMappedRange();"int32"===n.dtype||"bool"===n.dtype?new Int32Array(o).set(n.values):new Float32Array(o).set(n.values),a.unmap(),this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.copyBufferToBuffer(a,0,i,0,r);var s={size:r,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC,buffer:a};this.stagingPendingDisposal.push(s)}}},n.prototype.makeUniforms=function(e){var n=0,r=0,i=[];e.forEach((function(e){var a;switch(0===e.data.length&&(e.data=[1]),e.data.length){case 1:a=4;break;case 2:a=8;break;case 3:case 4:case 5:case 6:a=16;break;default:t.util.assert(!1,(function(){return"Unsupported "+e.data.length+"D shape"}))}5!==r&&6!==r||(a=16),n=Math.ceil(n/a)*a,r=e.data.length,i.push(n),n+=4*e.data.length}));var a=new ArrayBuffer(n);e.forEach((function(e,t){var n=i[t];"int32"===e.type?new Int32Array(a,n,e.data.length).set(e.data):"uint32"===e.type?new Uint32Array(a,n,e.data.length).set(e.data):new Float32Array(a,n,e.data.length).set(e.data)}));var o=this.bufferManager.acquireBuffer(n,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.queue.writeBuffer(o,0,a,0,n);var s={size:n,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM,buffer:o};return this.uniformPendingDisposal.push(s),{offset:0,size:n,buffer:o}},n.prototype.runWebGPUProgram=function(e,n,r,i,a){var o=this;if(a||(a=this.makeTensorInfo(e.outputShape,r)),0===t.util.sizeFromShape(a.shape))return this.tensorMap.get(a.dataId).values=t.util.getTypedArrayFromDType(a.dtype,0),a;this.uploadToGPU(a.dataId),e.dispatch=function(e,n){var r=e.limits.maxComputeWorkgroupsPerDimension,i=n.dispatchLayout,a=n.dispatch;if(a.every((function(e){return e<=r})))return a;t.util.assert(a[0]>r&&void 0===i.y&&void 0===i.z,(function(){return"Dispatch size exceeds WebGPU limits in Y or Z dimension."}));var o=Math.ceil(Math.sqrt(a[0]));return o>r?(o=Math.ceil(Math.cbrt(a[0])),t.util.assert(o<=r,(function(){return"Total dispatch size exceeds WebGPU maximum."})),[o,o,o]):[o,o,1]}(this.device,e);var s=[],u=[];if(!e.isFromPixels){s.push({type:"float32",data:[NaN]}),u=n.concat(a).map((function(e){return e.shape}));var d="int32";u.map((function(e){s.push({type:d,data:e})}));var h=t.util.computeStrides(a.shape);if(s.push({type:d,data:h}),e.size){var p=t.util.sizeFromShape(e.outputShape);s.push({type:d,data:[e.isVec4?p/4:p]})}}var c,f=n.map((function(t,n){if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");return o.uploadToGPU(t.dataId),{dtype:o.tensorMap.get(t.dataId).dtype,shape:t.shape,name:e.variableNames[n]}})),m=function(e,n,r,i){var a=e.shaderKey;if(e.isFromPixels)return a;var o=r.map((function(e){return e.dtype})).concat(i.dtype),s=r.map((function(e){return t.backend_util.getBroadcastDims(e.shape,i.shape)})),u=r.map((function(e){return t.util.arraysEqual(e.shape,i.shape)})).join("_"),l=s.map((function(e){return e.join("_")})).join(";"),d=C(e)?"flatDispatch":"";return a+"_"+(e.workGroupSize?e.workGroupSize.join(","):"")+n.map((function(e){return e.length})).join(",")+o.join(",")+e.variableNames.join(",")+l+u+d}(e,u,f,a);m in this.pipelineCache?c=this.pipelineCache[m]:(c=b(this.device,e,f,a),this.pipelineCache[m]=c),i&&(s=l(s,i));var v=l([this.tensorToBinding(a)],n.map((function(e){return o.tensorToBinding(e)})),[this.makeUniforms(s)]),g=this.device.createBindGroup({layout:c.getBindGroupLayout(0),entries:v.map((function(e,t){return{binding:t,resource:e}}))});this.ensureCommandEncoderReady();var x=this.getComputePass(),y=null!=this.activeTimers;return y&&this.supportTimeQuery&&x.writeTimestamp(this.querySet,0),x.setPipeline(c),x.setBindGroup(0,g),x.dispatchWorkgroups(e.dispatch[0],e.dispatch[1],e.dispatch[2]),y&&this.supportTimeQuery&&x.writeTimestamp(this.querySet,1),this.dispatchNumberInEncoder++,n.forEach((function(e){o.commandQueueOwnedIds.add(e.dataId)})),this.commandQueueOwnedIds.add(a.dataId),t.env().get("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE")<=this.dispatchNumberInEncoder&&this.submitQueue(),y&&this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(this.querySet)}),a},n.prototype.getTimeFromQuerySet=function(e){return a(this,void 0,void 0,(function(){var t,n,r,i;return o(this,(function(a){switch(a.label){case 0:return t=this.bufferManager.acquireBuffer(16,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE),n=this.bufferManager.acquireBuffer(16,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST),this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.resolveQuerySet(e,0,2,t,0),this.currentCommandEncoder.copyBufferToBuffer(t,0,n,0,16),this.submitQueue(),[4,n.mapAsync(GPUMapMode.READ)];case 1:return a.sent(),r=new BigUint64Array(n.getMappedRange()),i=Number(r[1]-r[0]),n.unmap(),this.bufferManager.releaseBuffer(n,16,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST),this.bufferManager.releaseBuffer(t,16,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE),[2,i/1e6]}}))}))},n.prototype.shouldExecuteOnCPU=function(e,n){var r=this;return void 0===n&&(n=O),t.env().getBool("WEBGPU_CPU_FORWARD")&&e.every((function(e){return null==r.tensorMap.get(e.dataId).resourceInfo&&t.util.sizeFromShape(e.shape)<n}))},n.prototype.numDataIds=function(){return this.tensorMap.numDataIds()-this.tensorDataPendingDisposal.length},n.prototype.dispose=function(){this.disposed||(this.bufferManager.dispose(),this.textureManager.dispose(),this.disposed=!0)},n}(t.KernelBackend);U.nextDataId=0;var D;G()&&t.registerBackend("webgpu",(function(){return a(undefined,void 0,void 0,(function(){var e,n,r,i,a,s,u;return o(this,(function(o){switch(o.label){case 0:return t.env().set("CHECK_COMPUTATION_FOR_ERRORS",!1),e={powerPreference:t.env().get("WEBGPU_USE_LOW_POWER_GPU")?"low-power":"high-performance"},[4,navigator.gpu.requestAdapter(e)];case 1:return n=o.sent(),r=n.limits,i={},a=n.features.has("timestamp-query"),i.requiredLimits={maxComputeWorkgroupStorageSize:r.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:r.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:r.maxStorageBufferBindingSize},a&&(i.requiredFeatures=["timestamp-query"]),[4,n.requestDevice(i)];case 2:return s=o.sent(),[4,n.requestAdapterInfo()];case 3:return u=o.sent(),[2,new U(s,u)]}}))}))}),3),function(e){e[e.MUL=0]="MUL",e[e.ADD=1]="ADD",e[e.ATAN2=2]="ATAN2",e[e.SUB=3]="SUB",e[e.DIV=4]="DIV",e[e.EQUAL=5]="EQUAL",e[e.GREATER=6]="GREATER",e[e.GREATER_EQUAL=7]="GREATER_EQUAL",e[e.LESS=8]="LESS",e[e.LESS_EQUAL=9]="LESS_EQUAL",e[e.LOGICAL_AND=10]="LOGICAL_AND",e[e.NOT_EQUAL=11]="NOT_EQUAL",e[e.SQUARED_DIFFERENCE=12]="SQUARED_DIFFERENCE",e[e.INT_DIV=13]="INT_DIV",e[e.POW=14]="POW",e[e.PRELU=15]="PRELU",e[e.MAX=16]="MAX",e[e.MIN=17]="MIN",e[e.COMPLEX_MULTIPLY_REAL=18]="COMPLEX_MULTIPLY_REAL",e[e.COMPLEX_MULTIPLY_IMAG=19]="COMPLEX_MULTIPLY_IMAG"}(D||(D={}));var W,M="\n  if (isNaN.r) {\n    resultTemp.r = valueForNaN;\n  }\n  if (isNaN.g) {\n    resultTemp.g = valueForNaN;\n  }\n  if (isNaN.b) {\n    resultTemp.b = valueForNaN;\n  }\n  if (isNaN.a) {\n    resultTemp.a = valueForNaN;\n  }\n  ",V="\n  let isNaN = isnanVec4(a) | isnanVec4(b);\n  "+M+"\n  ";function H(e,t,n){void 0===n&&(n="uniforms.NAN");var r=t?V:"\n  if (isnan(a)) { return a; }\n  if (isnan(b)) { return b; }\n  ";return t?"\n    let valueForNaN = "+n+";\n    var resultTemp = vec4<f32>("+e+"(a, b));\n    "+r+"\n    return resultTemp;\n  ":r+"\n    return "+e+"(a, b);\n  "}function X(e,t){switch(e){case D.MUL:return"return a * b;";case D.ADD:return"return a + b;";case D.ATAN2:return H("atan2",t);case D.SUB:return"return a - b;";case D.DIV:return"return a / b;";case D.EQUAL:return t?"return vec4<f32>(a == b);":"return f32(a == b);";case D.GREATER:return t?"return vec4<f32>(a > b);":"return f32(a > b);";case D.GREATER_EQUAL:return t?"return vec4<f32>(a >= b);":"return f32(a >= b);";case D.LESS:return t?"return vec4<f32>(a < b);":"return f32(a < b);";case D.LESS_EQUAL:return t?"return vec4<f32>(a <= b);":"return f32(a <= b);";case D.LOGICAL_AND:return t?"return (vec4<f32>(a >= vec4<f32>(1.0)) *\n  vec4<f32>(b >= vec4<f32>(1.0)));":"return f32(f32(a) >= 1.0 && f32(b) >= 1.0);";case D.NOT_EQUAL:return t?"\n  var resultTemp = vec4<f32>(a != b);\n  let valueForNaN = 1.0;\n  \n  let isNaN = isnanVec4(a) | isnanVec4(b);\n  \n  if (isNaN.r) {\n    resultTemp.r = valueForNaN;\n  }\n  if (isNaN.g) {\n    resultTemp.g = valueForNaN;\n  }\n  if (isNaN.b) {\n    resultTemp.b = valueForNaN;\n  }\n  if (isNaN.a) {\n    resultTemp.a = valueForNaN;\n  }\n  \n  \n\n  return resultTemp;\n":"\n  if (isnan(a) || isnan(b)) {\n    return 1.0;\n  }\n  return f32(a != b);\n";case D.SQUARED_DIFFERENCE:return"return (a - b) * (a - b);";case D.INT_DIV:return t?"\n  let ia = vec4<i32>(round(a));\n  let ib = vec4<i32>(round(b));\n  let cond = ib != vec4<i32>(0);\n  var resultTemp = vec4<i32>(0);\n  let s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    resultTemp[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    resultTemp[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    resultTemp[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    resultTemp[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4<f32>(resultTemp);\n  ":"\n  let s = sign(a) * sign(b);\n  let ia = i32(round(a));\n  let ib = i32(round(b));\n  return f32(idiv(ia, ib, s));\n  ";case D.PRELU:return t?"\n  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));\n  return (aLessThanZero * (b * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);\n  ":"if (a < 0.0) { return b * a; }  return a;";case D.MAX:return H("max",t);case D.MIN:return H("min",t);case D.POW:return t?"\n  let isModRound1Bool = vec4<i32>(round(abs(b) % vec4<f32>(2.0))) == vec4<i32>(1);\n  let isModRound1 = vec4<f32>(isModRound1Bool);\n  let multiplier = sign(a) * isModRound1 + (vec4<f32>(1.0) - isModRound1);\n  var resultTemp = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  let isExpZero = b == vec4<f32>(0.0);\n  if (isExpZero.r) {\n    resultTemp.r = 1.0;\n  }\n  if (isExpZero.g) {\n    resultTemp.g = 1.0;\n  }\n  if (isExpZero.b) {\n    resultTemp.b = 1.0;\n  }\n  if (isExpZero.a) {\n    resultTemp.a = 1.0;\n  }\n  let isNaN = (a < vec4<f32>(0.0)) & (floor(b) < b);\n  let valueForNaN = uniforms.NAN;\n  \n  if (isNaN.r) {\n    resultTemp.r = valueForNaN;\n  }\n  if (isNaN.g) {\n    resultTemp.g = valueForNaN;\n  }\n  if (isNaN.b) {\n    resultTemp.b = valueForNaN;\n  }\n  if (isNaN.a) {\n    resultTemp.a = valueForNaN;\n  }\n  \n  return resultTemp;\n  ":"\n  if(a < 0.0 && floor(b) < b) {\n    return uniforms.NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  if (round(abs(b) % 2.0) != 1.0) {\n    return pow(abs(a), b);\n  }\n  return sign(a) * pow(abs(a), b);\n  ";case D.COMPLEX_MULTIPLY_REAL:return"return areal * breal - aimag * bimag;";case D.COMPLEX_MULTIPLY_IMAG:return"return areal * bimag + aimag * breal;";default:throw new Error("BinaryType "+e+" is not implemented!")}}!function(e){e[e.ABS=0]="ABS",e[e.CEIL=1]="CEIL",e[e.COS=2]="COS",e[e.COSH=3]="COSH",e[e.ELU=4]="ELU",e[e.EXP=5]="EXP",e[e.EXPM1=6]="EXPM1",e[e.FLOOR=7]="FLOOR",e[e.IS_NAN=8]="IS_NAN",e[e.LINEAR=9]="LINEAR",e[e.LOG=10]="LOG",e[e.LOGICAL_NOT=11]="LOGICAL_NOT",e[e.NEG=12]="NEG",e[e.RELU=13]="RELU",e[e.RELU6=14]="RELU6",e[e.LEAKYRELU=15]="LEAKYRELU",e[e.RECIPROCAL=16]="RECIPROCAL",e[e.RSQRT=17]="RSQRT",e[e.SIN=18]="SIN",e[e.SINH=19]="SINH",e[e.SIGMOID=20]="SIGMOID",e[e.SQRT=21]="SQRT",e[e.SQUARE=22]="SQUARE",e[e.TANH=23]="TANH",e[e.TO_INT=24]="TO_INT"}(W||(W={}));function q(e,t){switch(e){case W.ABS:return"return abs(a);";case W.COS:return"return cos(a);";case W.COSH:return"\n  let e2x = exp(-a);\n  return (e2x + 1.0 / e2x) / 2.0;\n";case W.CEIL:return"return ceil(a);";case W.ELU:return t?"\n  var resFloat = exp(a) - vec4<f32>(1.0);\n  if (a.r >= 0.0) {\n    resFloat.r = a.r;\n  }\n  if (a.g >= 0.0) {\n    resFloat.g = a.g;\n  }\n  if (a.b >= 0.0) {\n    resFloat.b = a.b;\n  }\n  if (a.a >= 0.0) {\n    resFloat.a = a.a;\n  }\n  return resFloat;\n":"if (a >= 0.0) { return a; }  return (exp(a) - 1.0);";case W.EXP:return"return exp(a);";case W.EXPM1:return"return exp(a) - 1.0;";case W.FLOOR:return"return floor(a);";case W.IS_NAN:return"return f32(isnan(a));";case W.LINEAR:return"return a;";case W.LOG:return"if (a < 0.0) { return uniforms.NAN; }\n  return log(a);";case W.LOGICAL_NOT:return"return f32(!(a >= 1.0));";case W.NEG:return"return -a;";case W.LEAKYRELU:return t?"\n  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));\n  return (aLessThanZero * (uniforms.alpha * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);\n":"if (a < 0.0) { return uniforms.alpha * a; } return a;";case W.RECIPROCAL:return"return 1.0 / a;";case W.RELU:return t?"\n  return select(a, vec4<f32>(0.0), a < vec4<f32>(0.0));\n":"return select(a, 0.0, a < 0.0);";case W.RELU6:return t?"return clamp(a, vec4<f32>(0.0, 0.0, 0.0, 0.0), vec4<f32>(6.0, 6.0, 6.0, 6.0));":"return clamp(a, 0.0, 6.0);";case W.RSQRT:return"return 1.0/sqrt(a);";case W.SIGMOID:return"return 1.0 / (1.0 + exp(-1.0 * a));";case W.SIN:return"return sin(a);";case W.SINH:return"\n  let e2x = exp(a);\n  return (e2x - 1.0 / e2x) / 2.0;\n";case W.SQRT:return"return sqrt(a);";case W.SQUARE:return"return a * a;";case W.TANH:return"\n  let e2x = exp(-2.0 * abs(a));\n  return sign(a) * (1.0 - e2x) / (1.0 + e2x);\n";case W.TO_INT:return"return f32(i32((a)));";default:throw new Error("BinaryType "+e+" is not implemented!")}}var K=function(e){switch(e){case 1:return"f32";case 2:return"vec2<f32>";case 3:return"vec3<f32>";case 4:return"vec4<f32>";default:throw new Error(e+"-component is not supported.")}};function j(e,t,n,r){if(void 0===t&&(t=!1),void 0===n&&(n=!1),void 0===r&&(r=3),null===e)return"";var i="";if("linear"===e)i=q(W.LINEAR);else if("relu"===e)i=q(W.RELU,n);else if("elu"===e)i=q(W.ELU,n);else if("relu6"===e)i=q(W.RELU6,n);else if("prelu"===e)i=X(D.PRELU,n);else if("sigmoid"===e)i=q(W.SIGMOID,n);else{if("leakyrelu"!==e)throw new Error("Activation "+e+" has not been implemented for the WebGPU backend.");i=q(W.LEAKYRELU,n)}var a=K(n?4:1);return t?"\n      fn activation(a : "+a+", coords : vec"+r+"<i32>) -> "+a+" {\n        let b = getPreluActivationWeightsByOutputCoords(coords);\n        "+i+"\n      }":"\n      fn activation(a : "+a+", coords : vec"+r+"<i32>) -> "+a+" {\n        "+i+"\n      }"}function Y(e,t){return"\n      "+(e?"value = value + getBiasByOutputCoords(coords);":"")+"\n      "+(t?"value = activation(value, coords);":"")+"\n      "}function Q(e,n,r,i,a,o,s,u){void 0===a&&(a=!1),void 0===s&&(s=!1),void 0===u&&(u=1),t.util.assert(r&&1===u||!r,(function(){return"transposeA "+r+" is not compatible with component size "+u}));var l="\n      let batch = "+(e?"0":"batchIn")+";\n      "+(r?"value = getA(batch, col, row);":"value = getA(batch, row, col);")+"\n\n    ",d=i?"value = getB(batch, col, row);":"value = getB(batch, row, col);";return"\n  fn mm_readA(batchIn: i32, row: i32, colIn: i32) -> "+K(u)+" {\n    var value = "+K(u)+"(0.0);\n    let col = colIn * "+u+";\n    "+(a&&s?l:"\n    "+(r?"if(row < uniforms.dimAOuter && col < uniforms.dimInner)":"if(row < uniforms.aShape[1] && col < uniforms.aShape[2])")+"\n    {\n      "+l+"\n    }\n    ")+"\n    return value;\n  }\n\n  fn mm_readB(batchIn: i32, row: i32, colIn: i32) -> "+K(u)+" {\n    let col = colIn * "+u+";\n    let batch = "+(n?"0":"batchIn")+";\n    var value = "+K(u)+"(0.0);\n    "+d+"\n    return value;\n  }\n  "}function Z(e,t,n,r,i,a,o,s,u,l){return void 0===o&&(o=!1),void 0===s&&(s=!1),void 0===u&&(u=!1),void 0===l&&(l=1),"\n  "+Q(n,r,i,a,o,0,u,l)+"\n  fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: "+K(l)+") {\n    let col = colIn * "+l+";\n    "+(o&&s?"":"if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)")+"\n    {\n      var value = valueIn;\n      let coords = vec3<i32>(batch, row, col);\n      "+Y(e,t)+"\n      setOutputAtCoords(coords[0], coords[1], coords[2], value);\n    }\n  }\n  "}function J(e,n,r,i,a,o,s){void 0===r&&(r=!1),void 0===i&&(i=32),void 0===a&&(a=!1),void 0===o&&(o=32),void 0===s&&(s=!1);var u=n[1]*e[1],l=n[0]*e[0],d=r?u:i,h=r?i:u,p=d/n[0],c=i/n[1];return t.util.assert((r&&4===p&&4===e[1]||!r&&(3===p||4===p))&&d%n[0]==0&&i%n[1]==0&&4===e[0],(function(){return"If transposeA "+r+" is true, innerElementSize "+p+" and workPerThread[1] "+e[1]+" must be 4.\n          Otherwise, innerElementSize "+p+" must be 3 or 4.\n      tileAWidth "+d+" must be divisible by workGroupSize[0]"+n[0]+". tileInner "+i+" must be divisible by workGroupSize[1] "+n[1]+". ColPerThread "+e[0]+" must be 4."})),"\n  var<workgroup> mm_Asub : array<array<vec"+p+"<f32>, "+d/p+">, "+h+">;\n  var<workgroup> mm_Bsub : array<array<vec4<f32>, "+l/e[0]+">, "+i+">;\n\n  const RowPerThread = "+e[1]+";\n  const ColPerThread = "+e[0]+";\n  const InnerElementSize = "+p+";\n  const TileInner = "+i+";\n\n  @compute @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n  fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,\n            @builtin(global_invocation_id) GlobalId : vec3<u32>,\n            @builtin(num_workgroups) NumWorkgroups: vec3<u32>,\n            @builtin(workgroup_id) workgroupId: vec3<u32>) {\n    localId = LocalId;\n    globalId = GlobalId;\n    numWorkgroups = NumWorkgroups;\n\n    let localRow = i32(localId.y);\n    let tileRow = "+(s?"0":"localRow * RowPerThread")+";\n    let tileCol = i32(localId.x);\n\n    let globalRow = "+(s?"0":"i32(globalId.y) * RowPerThread")+";\n    let globalCol = i32(globalId.x);\n    let batch = "+(a?"0":"i32(globalId.z)")+";\n    let globalRowStart = i32(workgroupId.y) * "+u+";\n\n    let numTiles = "+(a?""+Math.ceil(o/i):"(uniforms.dimInner - 1) / TileInner + 1")+";\n    var kStart = "+(a?"i32(globalId.z) * "+o:"0")+";\n\n    var acc: array<vec4<f32>, RowPerThread>;\n\n    // Loop over shared dimension.\n    let tileRowB = localRow * "+c+";\n    for (var t = 0; t < numTiles; t = t + 1) {\n        // Load one tile of A into local memory.\n        for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {\n            let inputRow = tileRow + innerRow;\n            let inputCol = tileCol;\n            "+function(e){return e?"\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          kStart + inputRow,\n          globalRowStart / InnerElementSize + inputCol);\n        ":"\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          globalRow + innerRow,\n          kStart / InnerElementSize + inputCol);\n        "}(r)+"\n        }\n\n        // Load one tile of B into local memory.\n        for (var innerRow = 0; innerRow < "+c+"; innerRow = innerRow + 1) {\n            let inputRow = tileRowB + innerRow;\n            let inputCol = tileCol;\n            mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol);\n        }\n        kStart = kStart + TileInner;\n        workgroupBarrier();\n\n        // Compute acc values for a single thread.\n        for (var k = 0; k < TileInner / InnerElementSize; k = k + 1) {\n            let BCached0 = mm_Bsub[k * InnerElementSize][tileCol];\n            let BCached1 = mm_Bsub[k * InnerElementSize + 1][tileCol];\n            let BCached2 = mm_Bsub[k * InnerElementSize + 2][tileCol];\n            "+(3===p?"":"let BCached3 = mm_Bsub[k * InnerElementSize + 3][tileCol];")+"\n\n            "+function(e,t){return e?"\n        let ACached0 = mm_Asub[k * InnerElementSize][localRow];\n        let ACached1 = mm_Asub[k * InnerElementSize + 1][localRow];\n        let ACached2 = mm_Asub[k * InnerElementSize + 2][localRow];\n        "+(3===t?"":"let ACached3 = mm_Asub[k * InnerElementSize + 3][localRow];")+"\n        for (var i = 0; i < RowPerThread; i = i + 1) {\n          acc[i] = BCached0 * ACached0[i] + acc[i];\n          acc[i] = BCached1 * ACached1[i] + acc[i];\n          acc[i] = BCached2 * ACached2[i] + acc[i];\n          "+(3===t?"":"acc[i] = BCached3 * ACached3[i] + acc[i];")+"\n        }":"\n        for (var i = 0; i < RowPerThread; i = i + 1) {\n          let ACached = mm_Asub[tileRow + i][k];\n          acc[i] = BCached0 * ACached.x + acc[i];\n          acc[i] = BCached1 * ACached.y + acc[i];\n          acc[i] = BCached2 * ACached.z + acc[i];\n          "+(3===t?"":"acc[i] = BCached3 * ACached.w + acc[i];")+"\n        }"}(r,p)+"\n        }\n\n        workgroupBarrier();\n    }\n\n    for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {\n        mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);\n    }\n  }"}var $=function(e){return e?"\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          kStart + inputRow,\n          globalRowStart + inputCol);\n        ":"\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          globalRowStart + inputRow,\n          kStart + inputCol);\n        "};function ee(e,n,r,i,a,o,s){void 0===r&&(r=!1),void 0===i&&(i=32),void 0===a&&(a=!1),void 0===o&&(o=32),void 0===s&&(s=!1);var u=e[1]*n[1],l=e[0]*n[0],d=r?u:i,h=r?i:u;t.util.assert(h%n[1]==0&&d%n[0]==0&&i%n[1]==0,(function(){return"tileAHight "+h+" must be divisible by workGroupSize[1]"+n[1]+", tileAWidth "+d+" must be divisible by workGroupSize[0]"+n[0]+", tileInner "+i+" must be divisible by workGroupSize[1]"+n[1]}));var p=h/n[1],c=d/n[0],f=i/n[1],m=s?"\n      let localRow = i32(localId.y);\n      let localCol = i32(localId.x);\n      let globalRowStart = i32(workgroupId.y) * "+u+";\n      let globalColStart = i32(workgroupId.x) * "+l+";\n\n      // Loop over shared dimension.\n      for (var t = 0; t < numTiles; t = t + 1) {\n        // Load one tile of A into local memory.\n        for (var inputRow = localRow; inputRow < "+h+"; inputRow = inputRow + "+n[1]+") {\n          for (var inputCol = localCol; inputCol < "+d+"; inputCol = inputCol + "+n[0]+") {\n            "+$(r)+"\n          }\n        }\n        // Load one tile of B into local memory.\n        for (var inputRow = localRow; inputRow < "+i+"; inputRow = inputRow + "+n[1]+") {\n              for (var inputCol = localCol; inputCol < "+l+"; inputCol = inputCol + "+n[0]+") {\n            mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n              kStart + inputRow,\n              globalColStart + inputCol);\n          }\n        }\n        kStart = kStart + TileInner;\n        workgroupBarrier();\n\n        // Compute acc values for a single thread.\n        var BCached : array<f32, ColPerThread>;\n        for (var k = 0; k < TileInner; k = k + 1) {\n          for (var inner = 0; inner < ColPerThread; inner = inner + 1) {\n            BCached[inner] = mm_Bsub[k][localCol + inner * "+n[0]+"];\n          }\n          for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {\n            let ACached = "+(r?"mm_Asub[k][localRow + innerRow * "+n[1]+"];":"mm_Asub[localRow + innerRow * "+n[1]+"][k];")+"\n            for (var innerCol = 0; innerCol < ColPerThread; innerCol = innerCol + 1) {\n              acc[innerRow][innerCol] = acc[innerRow][innerCol] +\n                  ACached * BCached[innerCol];\n            }\n          }\n        }\n        workgroupBarrier();\n      }\n      for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {\n        let gRow = globalRowStart + localRow + innerRow * "+n[1]+";\n        for (var innerCol = 0; innerCol < ColPerThread; innerCol = innerCol + 1) {\n          let gCol = globalColStart + localCol + innerCol * "+n[0]+";\n          mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);\n        }\n      }\n      ":"\n  let tileRow = i32(localId.y) * RowPerThread;\n  let tileCol = i32(localId.x) * ColPerThread;\n\n  let globalRow = i32(globalId.y) * RowPerThread;\n  let globalCol = i32(globalId.x) * ColPerThread;\n  let globalRowStart = i32(workgroupId.y) * "+u+";\n\n  let tileRowA = i32(localId.y) * "+p+";\n  let tileColA = i32(localId.x) * "+c+";\n  let tileRowB = i32(localId.y) * "+f+";\n  // Loop over shared dimension.\n  for (var t = 0; t < numTiles; t = t + 1) {\n    // Load one tile of A into local memory.\n    for (var innerRow = 0; innerRow < "+p+"; innerRow = innerRow + 1) {\n      for (var innerCol = 0; innerCol < "+c+"; innerCol = innerCol + 1) {\n        let inputRow = tileRowA + innerRow;\n        let inputCol = tileColA + innerCol;\n        "+$(r)+"\n      }\n    }\n\n    // Load one tile of B into local memory.\n    for (var innerRow = 0; innerRow < "+f+"; innerRow = innerRow + 1) {\n      for (var innerCol = 0; innerCol < ColPerThread; innerCol = innerCol + 1) {\n        let inputRow = tileRowB + innerRow;\n        let inputCol = tileCol + innerCol;\n        mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n          kStart + inputRow,\n          globalCol + innerCol);\n      }\n    }\n    kStart = kStart + TileInner;\n    workgroupBarrier();\n\n    // Compute acc values for a single thread.\n    var BCached : array<f32, ColPerThread>;\n    for (var k = 0; k < TileInner; k = k + 1) {\n      for (var inner = 0; inner < ColPerThread; inner = inner + 1) {\n        BCached[inner] = mm_Bsub[k][tileCol + inner];\n      }\n\n      for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {\n        "+function(e){return e?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];"}(r)+"\n        for (var innerCol = 0; innerCol < ColPerThread; innerCol = innerCol + 1) {\n          acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];\n        }\n      }\n    }\n\n    workgroupBarrier();\n  }\n\n  for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < ColPerThread; innerCol = innerCol + 1) {\n      mm_write(batch, globalRow + innerRow, globalCol + innerCol,\n          acc[innerRow][innerCol]);\n    }\n  }\n  ";return"\n    var<workgroup> mm_Asub : array<array<f32, "+d+">, "+h+">;\n    var<workgroup> mm_Bsub : array<array<f32, "+l+">, "+i+">;\n    const RowPerThread = "+e[1]+";\n    const ColPerThread = "+e[0]+";\n    const TileInner = "+i+";\n\n    @compute @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n    fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,\n              @builtin(global_invocation_id) GlobalId : vec3<u32>,\n              @builtin(num_workgroups) NumWorkgroups: vec3<u32>,\n              @builtin(workgroup_id) workgroupId: vec3<u32>) {\n      localId = LocalId;\n      globalId = GlobalId;\n      numWorkgroups = NumWorkgroups;\n\n      let batch = "+(a?"0":"i32(globalId.z)")+";\n      let numTiles = "+(a?""+Math.ceil(o/i):"(uniforms.dimInner - 1) / TileInner + 1")+";\n      var kStart = "+(a?"i32(globalId.z) * "+o:"0")+";\n\n      var acc : array<array<f32, ColPerThread>, RowPerThread>;\n\n      // Without this initialization strange values show up in acc.\n      for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {\n        for (var innerCol = 0; innerCol < ColPerThread; innerCol = innerCol + 1) {\n          acc[innerRow][innerCol] = 0.0;\n        }\n      }\n      "+m+"\n    }\n  "}var te=function(){function e(e,t,n,r,i,a,o,s,l,d){var h;void 0===i&&(i=!1),void 0===a&&(a=!1),void 0===o&&(o=null),void 0===s&&(s=null),void 0===l&&(l=null),void 0===d&&(d=!1),this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=t,this.dispatchLayout={x:[2],y:[1],z:[0]};var p=i?e[1]:e[2];if(this.isVec4=(p%4==0&&!i||t[1]%4==0&&i)&&t[2]%4==0&&!a,this.isVectorA=1===t[1]&&!i,!this.isVec4&&this.isVectorA)this.elementsPerThread=[1,1,1],this.workGroupSize=[32,1,1];else{var c=P(t[1],p,t[2],i);this.workGroupSize=c.workGroupSize,this.elementsPerThread=c.elementsPerThread}this.dispatch=z(this.dispatchLayout,this.outputShape,this.workGroupSize,this.elementsPerThread);var f=null!=o,m=null!=l;f&&this.variableNames.push("bias"),m&&this.variableNames.push("preluActivationWeights"),this.sequentialAccessByThreads=d,this.transposeA=i,this.transposeB=a,this.addBias=f,this.activation=s,this.hasPreluActivationWeights=m,this.batchAEqualOne=n,this.batchBEqualOne=r,h=u(this.getShapeFit(t[1],t[2],p),3),this.fitAOuter=h[0],this.fitBOuter=h[1],this.fitInner=h[2],this.shaderKey="matMulPacked_"+this.elementsPerThread+"_"+i+"_"+a+"_"+this.activation+"_"+this.fitAOuter+"_"+this.fitBOuter+"_"+this.fitInner+"_"+this.isVec4+"_"+this.isVectorA+"_"+this.batchAEqualOne+"_"+this.batchBEqualOne+"_"+this.sequentialAccessByThreads}return e.prototype.getShapeFit=function(e,t,n){var r=this.workGroupSize[1]*this.elementsPerThread[1],i=this.workGroupSize[0]*this.elementsPerThread[0];return!this.isVec4&&this.isVectorA?this.tileInner=4*this.workGroupSize[0]:this.tileInner=i,[e%r==0,t%i==0,n%this.tileInner==0]},e.prototype.getUserCode=function(){var e,n,r="\n      "+j(this.activation,this.hasPreluActivationWeights,this.isVec4)+"\n      "+Z(this.addBias,this.activation,this.batchAEqualOne,this.batchBEqualOne,!1,this.transposeB,this.fitAOuter,this.fitBOuter,this.fitInner,this.isVec4?4:1)+"\n      "+(this.isVec4?J(this.elementsPerThread,this.workGroupSize,this.transposeA,this.tileInner,!1,null,this.isVectorA):this.isVectorA?(e=this.workGroupSize,void 0===(n=this.transposeA)&&(n=!1),t.util.assert(1===e[1]&&1===e[2],(function(){return"A linear work group size is required. But got "+e+"."})),"\n    const TileSize = "+4*e[0]+";\n    var<workgroup> mm_Asub : array<vec4<f32>, "+e[0]+">;\n\n    "+w()+" {\n      let tileCol = i32(localId.x);\n      let globalCol = i32(globalId.x);\n      let globalRow = i32(globalId.y);\n\n      let numTiles = (uniforms.dimInner - 1) / TileSize + 1;\n      let batch = i32(globalId.z);\n      // Without this initialization strange values show up in acc.\n      var acc = 0.0;\n\n      // Loop over shared dimension.\n      for (var t = 0; t < numTiles; t = t + 1) {\n        // Load one tile of A into local memory.\n        let colA = t * TileSize + tileCol * 4;\n        mm_Asub[tileCol] = vec4<f32>("+function(e){return e?"\n      mm_readA(batch, colA, globalRow),\n      mm_readA(batch, colA + 1, globalRow),\n      mm_readA(batch, colA + 2, globalRow),\n      mm_readA(batch, colA + 3, globalRow)\n  ":"\n      mm_readA(batch, globalRow, colA),\n      mm_readA(batch, globalRow, colA + 1),\n      mm_readA(batch, globalRow, colA + 2),\n      mm_readA(batch, globalRow, colA + 3)\n  "}(n)+");\n        workgroupBarrier();\n\n        // Compute acc values for a single thread.\n        for (var k = 0; k < TileSize / 4; k = k + 1) {\n          let rowB = t * TileSize + k * 4;\n          let BCached = vec4<f32>(mm_readB(batch, rowB, globalCol),\n                              mm_readB(batch, rowB + 1, globalCol),\n                              mm_readB(batch, rowB + 2, globalCol),\n                              mm_readB(batch, rowB + 3, globalCol));\n\n          let ACached = mm_Asub[k];\n          acc = acc + dot(ACached, BCached);\n        }\n\n        workgroupBarrier();\n      }\n\n      mm_write(batch, globalRow, globalCol, acc);\n    }\n  "):ee(this.elementsPerThread,this.workGroupSize,this.transposeA,this.tileInner,!1,null,this.sequentialAccessByThreads))+"\n    ";return r},e}();var ne=function(){function e(e,t,n,r,i,a,o,s){void 0===r&&(r=!1),void 0===i&&(i=!1),void 0===a&&(a=null),void 0===o&&(o=null),void 0===s&&(s=null),this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workGroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout={x:[],y:[1,2],z:[0]},this.dispatch=z(this.dispatchLayout,this.outputShape,this.workGroupSize);var u=null!=a,l=null!=s;u&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),this.transposeA=r,this.transposeB=i,this.addBias=u,this.activation=o,this.hasPreluActivationWeights=l,this.batchAEqualOne=t,this.batchBEqualOne=n,this.shaderKey="matMulReduce_"+this.activation+"_"+r+"_"+i+"_"+this.batchAEqualOne+"_"+this.batchBEqualOne}return e.prototype.getUserCode=function(){return"\n      "+j(this.activation,this.hasPreluActivationWeights)+"\n      "+Z(this.addBias,this.activation,this.batchAEqualOne,this.batchBEqualOne,this.transposeA,this.transposeB)+"\n      \n    var<workgroup> sumValues : array<f32, workGroupSizeX>;\n    "+w()+" {\n      let coords = getOutputCoords();\n      let batch = coords[0];\n      let row = coords[1];\n      let col = coords[2];\n      var sum = 0.0;\n      let Length = uniforms.dimInner;\n      for (var k = i32(localId.x); k < Length; k = k + i32(workGroupSizeX)) {\n        let dataA = mm_readA(batch, row, k);\n        let dataB = mm_readB(batch, k, col);\n        sum = sum + dataA * dataB;\n      }\n      sumValues[localId.x] = sum;\n      workgroupBarrier();\n\n      for(var currentSize = workGroupSizeX / 2u; currentSize > 1u;\n          currentSize = currentSize / 2u) {\n        if (localId.x < currentSize)\n        {\n          sumValues[localId.x] = sumValues[localId.x] + sumValues[localId.x + currentSize];\n        }\n        workgroupBarrier();\n      }\n\n      if (localId.x == 0u) {\n        sum = sumValues[0] + sumValues[1];\n        mm_write(batch, row, col, sum);\n      }\n    }\n  \n    "},e}();var re=function(){function e(e,t,n,r,i,a,o,s){void 0===r&&(r=!1),void 0===i&&(i=!1),void 0===a&&(a=null),void 0===o&&(o=null),void 0===s&&(s=null),this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workGroupSize=[16,8,1],this.outputShape=n,this.dispatchLayout={x:[2],y:[1],z:[0]},this.dispatch=[Math.ceil(n[2]/this.workGroupSize[0]),Math.ceil(n[1]/this.workGroupSize[1]),n[0]];var u=null!=a;u&&this.variableNames.push("bias");var l=null!=s;l&&this.variableNames.push("preluActivationWeights"),this.transposeA=r,this.transposeB=i,this.addBias=u,this.activation=o,this.hasPreluActivationWeights=l,this.batchAEqualOne=1===e[0],this.batchBEqualOne=1===t[0],this.shaderKey="matMulSmallOutputSize_"+this.activation+"_"+r+"_"+i+"_"+this.batchAEqualOne+"_"+this.batchBEqualOne}return e.prototype.getUserCode=function(){var e,t,n,r;return"\n      "+j(this.activation,this.hasPreluActivationWeights)+"\n      "+Z(this.addBias,this.activation,this.batchAEqualOne,this.batchBEqualOne,this.transposeA,this.transposeB)+"\n      "+(e=this.workGroupSize,t=e[1],n=e[0],"\n  var<workgroup> mm_Asub : array<array<f32, "+(r=t>n?t:n)+">, "+t+">;\n  var<workgroup> mm_Bsub : array<array<f32, "+n+">, "+r+">;\n\n  // If the output size is small for matrix multiplication, avoid to use vec4\n  // and handle some elements per thread to optimally utilize the ALU.\n  // Read data from global memory to registers firstly, then store them into\n  // shared memory, so it is instruction-Level parallelism for arithmetic\n  // operations and others handle IO operations between barrier api, makes ALU\n  // and load/store units work simultaneously, could improves the performance.\n  "+w()+" {\n    let tileRow = i32(localId.y);\n    let tileCol = i32(localId.x);\n    let globalRow = i32(globalId.y);\n    let globalCol = i32(globalId.x);\n    let batch = i32(globalId.z);\n\n    // uniforms.dimInner should be greater than 0.\n    let numTiles = (uniforms.dimInner - 1) / "+r+" + 1;\n    var acc = 0.0;\n\n    var globalColA = tileCol;\n    var globalRowB = 0;\n    var regA = mm_readA(batch, globalRow, globalColA);\n    var regB0 = mm_readB(batch, globalRowB + 2 * tileRow, globalCol);\n    var regB1 = mm_readB(batch, globalRowB + 2 * tileRow + 1, globalCol);\n    globalColA = globalColA + "+r+";\n    globalRowB = globalRowB + "+r+";\n\n    for (var t = 0; t < numTiles; t = t + 1) {\n      mm_Asub[tileRow][tileCol] = regA;\n      mm_Bsub[2 * tileRow][tileCol] = regB0;\n      mm_Bsub[2 * tileRow + 1][tileCol] = regB1;\n\n      workgroupBarrier();\n\n      regA = mm_readA(batch, globalRow, globalColA);\n      regB0 = mm_readB(batch, globalRowB + 2 * tileRow, globalCol);\n      regB1 = mm_readB(batch, globalRowB + 2 * tileRow + 1, globalCol);\n      globalColA = globalColA + "+r+";\n      globalRowB = globalRowB + "+r+";\n\n      for (var k = 0; k < "+r+"; k = k + 1) {\n        acc = acc + mm_Asub[tileRow][k] * mm_Bsub[k][tileCol];\n      }\n      workgroupBarrier();\n    }\n\n    mm_write(batch, globalRow, globalCol, acc);\n  }\n  \n    ")},e}(),ie=function(){function e(e,n,r,i,a,o){void 0===a&&(a=!1),void 0===o&&(o=!1),this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workGroupSize=[8,8,1],this.atomic=!0,this.isVec4=!1,this.splitedDimInner=128,t.util.assert(1===e[0],(function(){return"MatMulSplitKProgram only supports batch = 1."})),this.outputShape=e,this.dispatchLayout={x:[2],y:[1],z:[0,3]},this.isVec4=(a&&this.outputShape[1]%4==0||!a&&n%4==0)&&this.outputShape[2]%4==0,this.elementsPerThread=[4,4,this.splitedDimInner],this.isVec4||(this.outputShape[1]<16&&(this.elementsPerThread[1]=1),this.outputShape[2]<16&&(this.elementsPerThread[0]=1)),this.dispatch=z(this.dispatchLayout,[this.outputShape[0],this.outputShape[1],this.outputShape[2],n],this.workGroupSize,this.elementsPerThread),this.transposeA=a,this.transposeB=o,this.batchAEqualOne=r,this.batchBEqualOne=i,this.shaderKey="matMulSplitK_"+a+"_"+o+"_"+r+"_"+i+"_"+this.elementsPerThread+"_"+this.isVec4}return e.prototype.getUserCode=function(){var e=this.isVec4?4:1,t="\n      "+Q(this.batchAEqualOne,this.batchBEqualOne,!1,this.transposeB,!1,0,!1,e)+"\n      fn mm_write(batch: i32, row : i32, colIn : i32, value : "+K(e)+") {\n        let col = colIn * "+e+";\n        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {\n          let coords = vec3<i32>(batch, row, col);\n          let flatIndex = getOutputIndexFromCoords(coords);\n          // The problem is that we should initialize output to zero before using.\n          // Otherwise, the original value will be added to the result.\n          "+function(e){return"\n      for (var i = 0; i < "+e+"; i = i + 1)\n      {\n        var oldValue = atomicLoad(&(result[flatIndex + i]));\n        var exchanged = false;\n        for (; !exchanged;) {\n          let newValueF32 = bitcast<f32>(oldValue) + "+(e>1?"value[i]":"value")+";\n          let newValue = bitcast<i32>(newValueF32);\n          let res = atomicCompareExchangeWeak(&(result[flatIndex + i]), oldValue, newValue);\n          oldValue = res.old_value;\n          exchanged = res.exchanged;\n        }\n      }\n      "}(e)+"\n        }\n      }\n      "+(this.isVec4?J(this.elementsPerThread,this.workGroupSize,this.transposeA,32,!0,this.splitedDimInner):ee(this.elementsPerThread,this.workGroupSize,this.transposeA,32,!0,this.splitedDimInner))+"\n    ";return t},e}(),ae=function(){function e(e,t,n,r){void 0===t&&(t=null),void 0===n&&(n=null),void 0===r&&(r=null),this.uniforms="",this.variableNames=["x"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=B(this.outputShape),this.dispatch=z(this.dispatchLayout,this.outputShape,this.workGroupSize),this.addBias=null!=t,this.hasPreluActivationWeights=null!=r,this.activation=n,this.addBias&&this.variableNames.push("bias"),this.hasPreluActivationWeights&&this.variableNames.push("preluActivationWeights"),this.shaderKey="biasActivation_"+n}return e.prototype.getUserCode=function(){return"\n    "+j(this.activation,this.hasPreluActivationWeights)+"\n    "+w("index")+" {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        var value = getXByOutputIndex(index);\n        "+Y(this.addBias,this.activation)+"\n        setOutputAtIndex(index, value);\n      }\n    }\n    "},e}(),oe=function(){function e(e){this.variableNames=[],this.outputShape=[],this.uniforms="value : f32,",this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=B(this.outputShape),this.dispatch=z(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="fill"}return e.prototype.getUserCode=function(){return"\n    "+w("index")+" {\n      if (index < uniforms.size) {\n        setOutputAtIndex(index, uniforms.value);\n      }\n    }\n  "},e}();function se(e){var n=e.backend,r=e.attrs,i=r.shape,a=r.value,o=r.dtype;if("string"===(o=o||t.util.inferDtype(a))){var s=t.util.getArrayFromDType(o,t.util.sizeFromShape(i));return s.fill(a),n.makeTensorInfo(i,o,s)}var u=new oe(i),l=[{type:"float32",data:[a]}];return n.runWebGPUProgram(u,[],o,l)}var ue={kernelName:t.Fill,backendName:"webgpu",kernelFunc:se};function le(e){var n=e.inputs,r=e.attrs,i=n.x,a=r.shape,o=t.util.sizeFromShape(i.shape),s=t.util.inferFromImplicitShape(a,o),u=t.util.sizeFromShape(s);return t.util.assert(o===u,(function(){return"The new shape ("+s+") has "+u+" elements and the old shape ("+i.shape+") has "+o+" elements. The new shape and old shape must have the same number of elements."})),e.backend.incRef(i.dataId),{dataId:i.dataId,shape:s,dtype:i.dtype}}var de={kernelName:t.Reshape,backendName:"webgpu",kernelFunc:le};function he(e){var n,r,i,a,o=e.a,u=e.b,l=e.transposeA,d=e.transposeB,h=e.backend,p=e.bias,c=void 0===p?null:p,f=e.preluActivationWeights,m=void 0===f?null:f,v=e.leakyreluAlpha,g=void 0===v?0:v,b=e.activation,x=void 0===b?null:b,y=o.shape.length,w=u.shape.length,k=l?o.shape[y-2]:o.shape[y-1],I=d?u.shape[w-1]:u.shape[w-2],S=l?o.shape[y-1]:o.shape[y-2],C=d?u.shape[w-2]:u.shape[w-1],R=o.shape.slice(0,-2),T=u.shape.slice(0,-2),z=t.util.sizeFromShape(R),P=t.util.sizeFromShape(T),_=t.broadcast_util.assertAndGetBroadcastShape(o.shape.slice(0,-2),u.shape.slice(0,-2)).concat([S,C]);t.util.assert(k===I,(function(){return"Error in matMul: inner shapes ("+k+") and ("+I+") of Tensors with shapes "+o.shape+" and "+u.shape+" and transposeA="+l+" and transposeB="+d+" must match."}));var N,B,E=l?[z,k,S]:[z,S,k],F=d?[P,C,I]:[P,I,C],G=le({inputs:{x:o},backend:h,attrs:{shape:E}}),L=le({inputs:{x:u},backend:h,attrs:{shape:F}}),O=[G,L],U=Math.max(z,P),D=1===z,W=1===P,M=[G,L],V=[{type:"int32",data:[S]},{type:"int32",data:[C]},{type:"int32",data:[k]}],H=[U,S,C],X=t.env().get("WEBGPU_MATMUL_PROGRAM_TYPE");switch(X<0&&(X=S*C<=128?A.MatMulReduceProgram:1===U&&S<=128&&C<=48&&I>=2e3?A.MatMulSplitKProgram:S<=16&&(C<=512||I>=2*C)||C<=16&&(S<=512||k>=2*S)?A.MatMulSmallOutputSizeProgram:A.MatMulPackedProgram),X){case A.MatMulReduceProgram:N=new ne(H,D,W,l,d,c,x,m);break;case A.MatMulSplitKProgram:if(B=se({backend:h,attrs:{shape:H,value:0,dtype:o.dtype}}),N=new ie(H,I,D,W,l,d),c||x){B=h.runWebGPUProgram(N,M,o.dtype,V,B);var q=new ae(B.shape,c,x,m),K=null,j=[B];c&&j.push(c),m&&j.push(m),"leakyrelu"===x&&(K=[{type:"float32",data:[g]}],q.uniforms+=" alpha : f32,");var Y=h.runWebGPUProgram(q,j,B.dtype,K);O.push(B);var Q=le({inputs:{x:Y},backend:h,attrs:{shape:_}});O.push(Y);try{for(var Z=s(O),J=Z.next();!J.done;J=Z.next()){var $=J.value;h.disposeData($.dataId)}}catch(e){n={error:e}}finally{try{J&&!J.done&&(r=Z.return)&&r.call(Z)}finally{if(n)throw n.error}}return Q}break;case A.MatMulSmallOutputSizeProgram:N=new re(E,F,H,l,d,c,x,m);break;case A.MatMulPackedProgram:var ee=h.adapterInfo.isIntel();N=new te(E,H,D,W,l,d,c,x,m,ee);break;default:throw new Error("Unsupported MatMulProgramType "+X+".")}c&&M.push(c),m&&M.push(m),"leakyrelu"===x&&(V.push({type:"float32",data:[g]}),N.uniforms+=" alpha : f32,");var oe=le({inputs:{x:B=h.runWebGPUProgram(N,M,o.dtype,V,B)},backend:h,attrs:{shape:_}});O.push(B);try{for(var ue=s(O),de=ue.next();!de.done;de=ue.next()){$=de.value;h.disposeData($.dataId)}}catch(e){i={error:e}}finally{try{de&&!de.done&&(a=ue.return)&&a.call(ue)}finally{if(i)throw i.error}}return oe}var pe={kernelName:t._FusedMatMul,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.a,a=t.b,o=t.bias,s=t.preluActivationWeights,u=r.transposeA,l=r.transposeB,d=r.activation;return he({a:i,b:a,transposeA:u,transposeB:l,backend:n,bias:o,preluActivationWeights:s,leakyreluAlpha:r.leakyreluAlpha,activation:d})}},ce=function(){function e(e,n,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.workGroupSize=[128,1,1],this.size=!0,this.outputShape=t.backend_util.assertAndGetBroadcastShape(n,r),this.dispatchLayout=B(this.outputShape),this.dispatch=z(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="binaryOpComplex_"+e,this.op=e}return e.prototype.getUserCode=function(){return"\n      fn binaryOpComplex(\n          areal : f32, aimag : f32, breal : f32, bimag : f32) -> f32 {\n        "+X(this.op,!1)+"\n      }\n\n      "+w("index")+" {\n        if(index < uniforms.size) {\n          let areal = getARealByOutputIndex(index);\n          let aimag = getAImagByOutputIndex(index);\n          let breal = getBRealByOutputIndex(index);\n          let bimag = getBImagByOutputIndex(index);\n          setOutputAtIndex(index, binaryOpComplex(areal, aimag, breal, bimag));\n        }\n      }\n    "},e}(),fe=function(){function e(e,n,r){this.size=!0,this.variableNames=["A","B"],this.outputShape=t.backend_util.assertAndGetBroadcastShape(n,r),this.dispatchLayout=B(this.outputShape),this.op=e,this.useSharedMemoryWithA=n.length<=1&&r.length>1&&n[0]<128,this.useSharedMemoryWithB=r.length<=1&&n.length>1&&r[0]<128,this.useSharedMemoryWithA||this.useSharedMemoryWithB?(this.isVec4=!1,this.lastDimensionSize=this.useSharedMemoryWithB?r[0]:n[0],this.shaderKey="binary_"+this.type+"_"+e+"_"+this.lastDimensionSize+"_"+this.useSharedMemoryWithB,this.type="shared",this.workGroupSize=[256,1,1],this.workPerThread=1):(t.util.arraysEqual(n,r)&&t.util.sizeFromShape(n)%4==0?(this.isVec4=!0,this.type="vec4",this.workPerThread=4):(this.isVec4=!1,this.type="plain",this.workPerThread=1),this.shaderKey="binary_"+this.type+"_"+e,this.workGroupSize=[128,1,1]),this.dispatch=z(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1])}return e.prototype.getUserCode=function(){var e,t=this.isVec4?"vec4<f32>":"f32",n="\n    fn binaryOperation(a : "+t+", b : "+t+") -> "+t+" {\n      "+X(this.op,this.isVec4)+"\n    };\n    ";if("shared"===this.type){var r=this.lastDimensionSize>1?"coords["+(this.outputShape.length-1)+"]":"0",i=this.useSharedMemoryWithB?"let a = getAByOutputIndex(index);\n          let b = sharedBuf["+r+"];":"let a = sharedBuf["+r+"];\n          let b = getBByOutputIndex(index);";e="\n        "+n+"\n        var<workgroup> sharedBuf : array<f32, "+this.lastDimensionSize+">;\n        "+w("index")+" {\n          // Fill in the shared memory buffer.\n          let localIndex = i32(localId.x);\n          if(localIndex < "+this.lastDimensionSize+") {\n            sharedBuf[localIndex] = f32("+(this.useSharedMemoryWithB?"B":"A")+"[localIndex]);\n          }\n          workgroupBarrier();\n\n          if(index < uniforms.size) {\n            let coords = getCoordsFromIndex(index);\n            "+i+"\n            setOutputAtIndex(index, binaryOperation(a, b));\n          }\n        }\n        "}else e="\n       "+n+"\n       "+w("index")+" {\n         if (index < uniforms.size) {\n           let a = getAByOutputIndex(index);\n           let b = getBByOutputIndex(index);\n           setOutputAtIndex(index, binaryOperation(a, b));\n         }\n       }\n       ";return e},e}();function me(e){var t=e.inputs.x;return e.backend.incRef(t.dataId),{dataId:t.dataId,shape:t.shape,dtype:t.dtype}}var ve={kernelName:t.Identity,backendName:"webgpu",kernelFunc:me};function ge(e){var t=e.inputs,n=e.backend,r=t.real,i=t.imag,a=n.makeTensorInfo(r.shape,"complex64"),o=n.tensorMap.get(a.dataId),s=me({inputs:{x:r},backend:n}),u=me({inputs:{x:i},backend:n});return o.complexTensorInfos={real:s,imag:u},a}var be={kernelName:t.Complex,backendName:"webgpu",kernelFunc:ge},xe=function(){function e(e,t){this.variableNames=["A"],this.size=!0;this.workGroupSize=[128,1,1],this.outputShape=e,this.dispatchLayout=B(this.outputShape),this.dispatch=z(this.dispatchLayout,this.outputShape,this.workGroupSize),this.op=t,this.shaderKey="unary_"+t}return e.prototype.getUserCode=function(){return"\n      fn unaryOperation(a : f32) -> f32 {\n        "+q(this.op,!1)+"\n      }\n      "+w("index")+" {\n        if (index < uniforms.size) {\n          let a = getAByOutputIndex(index);\n          setOutputAtIndex(index, unaryOperation(a));\n        }\n      }\n      "},e}();function ye(e){var t=e.opType,n=e.cpuKernelImpl,r=e.dtype;return function(e){var i=e.inputs,a=e.backend,o=i.x,s=a,u=r||o.dtype;if(s.shouldExecuteOnCPU([o])&&null!=n){var l=s.tensorMap.get(o.dataId),d=n(l.values,u);return s.makeTensorInfo(o.shape,u,d)}var h=new xe(o.shape,t);return s.runWebGPUProgram(h,[o],u)}}function we(e){var n=e.opType,r=e.cpuKernelImpl,i=e.supportsComplex,a=void 0!==i&&i,o=e.dtype;return function(e){var i,s=e.inputs,l=e.backend,d=s.a,h=s.b,p=l;if(a&&"complex64"===d.dtype){var c=p.tensorMap.get(d.dataId),f=p.tensorMap.get(h.dataId),m=void 0,v=void 0;if(n!==D.MUL)i=u([[c.complexTensorInfos.real,f.complexTensorInfos.real],[c.complexTensorInfos.imag,f.complexTensorInfos.imag]].map((function(e){var r=u(e,2),i=r[0],a=r[1],o={dataId:i.dataId,dtype:i.dtype,shape:d.shape},s={dataId:a.dataId,dtype:a.dtype,shape:h.shape},l=new fe(n,d.shape,h.shape);return p.runWebGPUProgram(l,[o,s],t.upcastType(i.dtype,a.dtype))})),2),m=i[0],v=i[1];else{var g=new ce(D.COMPLEX_MULTIPLY_REAL,d.shape,h.shape),b=new ce(D.COMPLEX_MULTIPLY_IMAG,d.shape,h.shape),x=[{dataId:c.complexTensorInfos.real.dataId,dtype:c.complexTensorInfos.real.dtype,shape:d.shape},{dataId:c.complexTensorInfos.imag.dataId,dtype:c.complexTensorInfos.imag.dtype,shape:d.shape},{dataId:f.complexTensorInfos.real.dataId,dtype:f.complexTensorInfos.real.dtype,shape:h.shape},{dataId:f.complexTensorInfos.imag.dataId,dtype:f.complexTensorInfos.imag.dtype,shape:h.shape}];m=p.runWebGPUProgram(g,x,"float32"),v=p.runWebGPUProgram(b,x,"float32")}var y=ge({inputs:{real:m,imag:v},backend:p});return p.disposeData(m.dataId),p.disposeData(v.dataId),y}var w=o||t.upcastType(d.dtype,h.dtype);if(("string"===d.dtype||"string"===h.dtype||p.shouldExecuteOnCPU([d,h]))&&null!=r){c=p.tensorMap.get(d.dataId).values,f=p.tensorMap.get(h.dataId).values;var k="string"===d.dtype?t.backend_util.fromUint8ToStringArray(c):c,I="string"===d.dtype?t.backend_util.fromUint8ToStringArray(f):f,S=u(r(d.shape,h.shape,k,I,w),2),C=S[0],R=S[1];return p.makeTensorInfo(R,w,C)}var A=new fe(n,d.shape,h.shape);return p.runWebGPUProgram(A,[d,h],w)}}function ke(e){return function(n,r,i,a,o){var s=t.backend_util.assertAndGetBroadcastShape(n,r),u=s.length,l=t.util.computeStrides(s),d=t.util.sizeFromShape(s),h=t.util.getTypedArrayFromDType(o,d),p=n.length,c=r.length,f=t.util.computeStrides(n),m=t.util.computeStrides(r),v=t.backend_util.getBroadcastDims(n,s),g=t.backend_util.getBroadcastDims(r,s);if(v.length+g.length===0)for(var b=0;b<h.length;++b)h[b]=e(i[b%i.length],a[b%a.length]);else{var x=function(n){var r=t.util.indexToLoc(n,u,l),o=r.slice(-p);v.forEach((function(e){return o[e]=0}));var s=t.util.locToIndex(o,p,f),d=r.slice(-c);g.forEach((function(e){return d[e]=0}));var b=t.util.locToIndex(d,c,m);h[n]=e(i[s],a[b])};for(b=0;b<h.length;++b)x(b)}return[h,s]}}var Ie=ke((function(e,t){return e+t}));function Se(e){return function(n,r,i){for(var a=t.util.getTypedArrayFromDType(r,n.length),o=0;o<n.length;++o)a[o]=e(n[o],i);return a}}var Ce=Se((function(e){return Math.ceil(e)}));var Re=ke((function(e,t){return e===t?1:0})),Ae=Se((function(e){return Math.exp(e)})),Te=Se((function(e){return Math.expm1(e)})),ze=Se((function(e){return Math.floor(e)}));var Pe=ke((function(e,t){return e>t?1:0})),_e=ke((function(e,t){return e>=t?1:0})),Ne=ke((function(e,t){return e<t?1:0})),Be=ke((function(e,t){return e<=t?1:0})),Ee=Se((function(e){return Math.log(e)}));var Fe=ke((function(e,t){return Math.max(e,t)})),Ge=ke((function(e,t){return Math.min(e,t)})),Le=ke((function(e,t){return e*t}));var Oe=ke((function(e,t){return e!==t?1:0}));t.backend_util.RowPartitionType;var Ue=Se((function(e){return 1/Math.sqrt(e)}));var De=function(){function e(e,n,r,i,a,o){this.separator=t.util.encodeString(e),this.nGramWidths=n,this.leftPad=t.util.encodeString(r),this.rightPad=t.util.encodeString(i),this.padWidth=a,this.preserveShort=o}return e.prototype.getPadWidth=function(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)},e.prototype.getNumNGrams=function(e,t){var n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)},e.prototype.createNGrams=function(e,t,n,r,i,a){for(var o=function(o){var u=s.getPadWidth(a),l=Math.max(0,u-o),d=Math.max(0,u-(i-(o+1))),h=a-(l+d),p=t+(l>0?0:o-u),c=0;c+=l*s.leftPad.length;for(var f=0;f<h;++f)c+=e[p+f].length;c+=d*s.rightPad.length,c+=(l+d+h-1)*s.separator.length,n[r+o]=new Uint8Array(c);var m=n[r+o],v=0,g=function(e){return e.forEach((function(e){return m[v++]=e}))};for(f=0;f<l;++f)g(s.leftPad),g(s.separator);for(f=0;f<h-1;++f)g(e[p+f]),g(s.separator);if(h>0){g(e[p+h-1]);for(f=0;f<d;++f)g(s.separator),g(s.rightPad)}else{for(f=0;f<d-1;++f)g(s.rightPad),g(s.separator);g(s.rightPad)}},s=this,u=0;u<i;++u)o(u)},e.prototype.compute=function(e,n){var r=this,i=e.length,a=n.length;if(a>0){var o=n[0];if(0!==o)throw new Error("First split value must be 0, got "+o);for(var s=1;s<a;++s){var u=n[s]>=o;if(!(u=u&&n[s]<=i))throw new Error("Invalid split value "+n[s]+", must be in ["+o+", "+i+"]");o=n[s]}if(o!==i)throw new Error("Last split value must be data size. Expected "+i+", got "+o)}var l=a-1,d=t.util.getArrayFromDType("int32",a);if(0===i||0===a){var h=new Array(i);for(s=0;s<=l;++s)d[s]=0;return[h,d]}d[0]=0;var p=function(e){var t=n[e]-n[e-1],i=0;c.nGramWidths.forEach((function(e){i+=r.getNumNGrams(t,e)})),c.preserveShort&&t>0&&0===i&&(i=1),d[e]=d[e-1]+i},c=this;for(s=1;s<=l;++s)p(s);var f=new Array(d[l]),m=function(t){var i=n[t],a=d[t];if(v.nGramWidths.forEach((function(o){var s=n[t+1]-n[t],u=r.getNumNGrams(s,o);r.createNGrams(e,i,f,a,u,o),a+=u})),v.preserveShort&&a===d[t]){var o=n[t+1]-n[t];if(0===o)return"continue";var s=o+2*v.padWidth;v.createNGrams(e,i,f,a,1,s)}},v=this;for(s=0;s<l;++s)m(s);return[f,d]},e}();var We=ke((function(e,t){return e-t}));var Me=function(e,t){var n=t.value-e.value;return 0===n?e.index-t.index:n};function Ve(e,n,r,i){for(void 0===r&&(r=0),void 0===i&&(i=e.length-1);i>r;){if(i-r>600){var a=i-r+1,o=n-r+1,s=Math.log(a),u=.5*Math.exp(2*s/3),l=.5*Math.sqrt(s*u*(a-u)/a)*Math.sign(o-a/2);Ve(e,n,Math.max(r,Math.floor(n-o*u/a+l)),Math.min(i,Math.floor(n+(a-o)*u/a+l)))}var d=e[n],h=r,p=i;for(t.util.swap(e,r,n),Me(e[i],d)>0&&t.util.swap(e,r,i);h<p;){for(t.util.swap(e,h,p),h++,p--;Me(e[h],d)<0;)h+=1;for(;Me(e[p],d)>0;)p-=1}0===Me(e[r],d)?t.util.swap(e,r,p):(p+=1,t.util.swap(e,p,i)),p<=n&&(r=p+1),n<=p&&(i=p-1)}}var He=Ie,Xe=function(e,n,r,i){if("int32"===i)return[n,"int32",Int32Array.from(e)];if("bool"===i){var a=t.util.toTypedArray([0],r),o=u(ke((function(e,t){return e!==t?1:0}))(n,[],e,a,"bool"),2),s=o[0];return[o[1],"bool",s]}throw new Error("Error in Cast: failed to cast "+r+" to "+i)},qe=Ce,Ke=function(e,n,r,i){var a=t.util.getArrayFromDType(r,t.util.sizeFromShape(n));if(i&&"string"!==r){var o=0;e.forEach((function(e){var n=t.util.sizeFromShape(e.shape);a.set(e.vals,o),o+=n}))}else{var s=0;e.forEach((function(e){for(var i="string"===r?t.backend_util.fromUint8ToStringArray(e.vals):e.vals,o=0,u=0;u<e.shape[0];++u)for(var l=u*n[1]+s,d=0;d<e.shape[1];++d)a[l+d]=i[o++];s+=e.shape[1]}))}return a},je=Re,Ye=Ae,Qe=Te,Ze=ze,Je=function(e,n,r,i,a,o,s,u,d){for(var h=t.buffer([i,o],r),p=0;p<i;p++){for(var c=[],f=0,m=0;m<a;m++){var v=e[p*a+m];f+=v*s[m],c.push(v)}if(f<0||f>=d/o)throw new Error("Invalid indices: "+c+" does not index into "+u);for(var g=0;g<o;g++)h.values[p*o+g]=n.get.apply(n,l(n.indexToLoc(f*o+g)))}return h},$e=function(e,n,r){for(var i=t.buffer(r,e.dtype),a=0;a<i.size;++a){var o=i.indexToLoc(a).slice(),s=o[0],u=o[2],l=n.locToIndex([s,u]);o[2]=n.values[l];var d=e.locToIndex(o);0<=d&&d<e.values.length&&(i.values[a]=e.values[d])}return i},et=_e,tt=Pe,nt=Be,rt=Ne,it=Ee,at=function(e,n,r,i){for(var a=t.util.getTypedArrayFromDType(i,t.util.sizeFromShape(r)),o=0;o<a.length;++o){for(var s=o*n,u=e[s],l=0;l<n;++l){var d=e[s+l];(Number.isNaN(d)||d>u)&&(u=d)}a[o]=u}return a},ot=Fe,st=Ge,ut=Le,lt=function(e,n,r){var i=t.util.createScalarValue(-1,r);return Le([],n,i,e,r)},dt=Oe,ht=function(e,n,r,i){for(var a=u(t.backend_util.computeOutAndReduceShapes(e,i),2),o=a[0],s=a[1],l=t.upcastType(n,"int32"),d=t.util.makeZerosTypedArray(t.util.sizeFromShape(o),l),h=t.util.sizeFromShape(s),p=0;p<d.length;++p){for(var c=p*h,f=1,m=0;m<h;++m)f*=r[c+m];d[p]=f}return{outVals:d,outShape:o,outDtype:l}},pt=function(e,n,r,i){if(e===n||e<n&&r<0||n<e&&r>1)return t.util.makeZerosTypedArray(0,i);var a=Math.abs(Math.ceil((n-e)/r)),o=t.util.makeZerosTypedArray(a,i);n<e&&1===r&&(r=-1),o[0]=e;for(var s=1;s<o.length;s++)o[s]=o[s-1]+r;return o},ct=Ue,ft=function(e,n,r,i,a,o,s,u,l,d){var h=[i/a,a],p=e.values,c=n.values;if(0===i)return t.buffer(r,n.dtype);var f=t.buffer(h,n.dtype);"string"==typeof l||"number"==typeof l?f.values.fill(l):"boolean"==typeof l&&f.values.fill(+l);for(var m=0;m<o;m++){for(var v=[],g=0,b=0;b<s;b++){var x=p[m*s+b];v.push(x),g+=x*u[b]}if(g<0||g>=i/a)throw new Error("Invalid indices: "+v+" does not index into "+r);for(var y=0;y<a;y++)d?f.values[g*a+y]+=c[m*a+y]:f.values[g*a+y]=0===n.rank?c[0]:c[m*a+y]}return f},mt=function(e){for(var t=new Float32Array(e.length),n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t},vt=function(e,n,r,i,a){var o=t.slice_util.isSliceContinous(i,n,r),s=t.util.sizeFromShape(r),u=t.util.computeStrides(i);if(o){var d=t.slice_util.computeFlatOffset(n,u);return"string"===a?e.slice(d,d+s):e.subarray(d,d+s)}for(var h="string"===a?t.backend_util.fromUint8ToStringArray(e):e,p=t.buffer(i,a,h),c=t.buffer(r,a),f=0;f<c.size;++f){var m=c.indexToLoc(f),v=m.map((function(e,t){return e+n[t]}));c.set.apply(c,l([p.get.apply(p,l(v))],m))}return"string"===a?t.backend_util.fromStringArrayToUint8(c.values):c.values},gt=function(e,n,r,i){for(var a=t.buffer(e,n.dtype),o=0;o<a.size;o++){for(var s=a.indexToLoc(o),u=new Array(s.length),d=0;d<u.length;d++)u[d]=s[d]*r[d]+i[d];a.set.apply(a,l([n.get.apply(n,l(u))],s))}return a},bt=function(e,t,n,r,i,a,o,s){return new De(n,r,i,a,o,s).compute(e,t)},xt=We,yt=function(e,n){for(var r=new Array(e.rank),i=0;i<r.length;i++)r[i]=e.shape[i]*n[i];var a=t.buffer(r,e.dtype);for(i=0;i<a.values.length;++i){for(var o=a.indexToLoc(i),s=new Array(e.rank),u=0;u<s.length;u++)s[u]=o[u]%e.shape[u];var l=e.locToIndex(s);a.values[i]=e.values[l]}return a},wt=function(e,n,r,i,a){for(var o=n[n.length-1],s=u([e.length/o,o],2),l=s[0],d=s[1],h=t.util.getTypedArrayFromDType(r,l*i),p=t.util.getTypedArrayFromDType("int32",l*i),c=function(t){var n=t*d,r=e.subarray(n,n+d),o=new Array(r.length);r.forEach((function(e,t){return o[t]={value:e,index:t}})),i<o.length&&(Ve(o,i),o=o.slice(0,i)),a&&o.sort(Me);for(var s=t*i,u=h.subarray(s,s+i),l=p.subarray(s,s+i),c=0;c<i;c++)u[c]=o[c].value,l[c]=o[c].index},f=0;f<l;f++)c(f);var m=n.slice();return m[m.length-1]=i,[t.buffer(m,r,h),t.buffer(m,"int32",p)]},kt=function(e,n,r,i,a){for(var o=n.length,s=t.util.sizeFromShape(n),u=t.util.computeStrides(n),l=t.util.computeStrides(a),d=t.util.getTypedArrayFromDType(r,t.util.sizeFromShape(a)),h=0;h<s;++h){for(var p=t.util.indexToLoc(h,o,u),c=new Array(p.length),f=0;f<c.length;f++)c[f]=p[i[f]];d[t.util.locToIndex(c,o,l)]=e[h]}return d},It=ye({opType:W.ABS,cpuKernelImpl:mt}),St={kernelName:t.Abs,backendName:"webgpu",kernelFunc:It},Ct=we({opType:D.ADD,cpuKernelImpl:He,supportsComplex:!0}),Rt={kernelName:t.Add,backendName:"webgpu",kernelFunc:Ct},At=function(){function e(e){this.workPerThread=1,this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e[0],this.variableNames=e.map((function(e,t){return"T"+t})),this.dispatchLayout=B(this.outputShape),this.dispatch=z(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.shaderKey="addN"}return e.prototype.getUserCode=function(){var e=[];this.variableNames.forEach((function(t){e.push("let v"+t+" = get"+t+"ByOutputCoords(coords);")}));var t=this.variableNames.map((function(e){return"v"+e})).join(" + ");return"\n      "+w("index")+" {\n        for (var i = 0; i < "+this.workPerThread+"; i = i + 1) {\n          let flatIndex = index * "+this.workPerThread+" + i;\n          if (flatIndex < uniforms.size) {\n            let coords = getCoordsFromIndex(flatIndex);\n            "+e.join("\n        ")+"\n            setOutputAtIndex(flatIndex, "+t+");\n          }\n        }\n      }\n    "},e}();var Tt={kernelName:t.AddN,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,r=e.backend,i=n;if(1===i.length)return me({inputs:{x:i[0]},backend:r});var a=i.map((function(e){return e.dtype})).reduce((function(e,n){return t.upcastType(e,n)})),o=i.map((function(e){return e.shape})),s=new At(o);return r.runWebGPUProgram(s,i,a)}},zt=function(){function e(e,n,r){this.workGroupSize=[64,1,1],this.variableNames=["x"],this.uniforms="infinityValue : f32,",this.size=!0;var i=[n];this.op="min"===r?"<":">";var a=u(t.backend_util.computeOutAndReduceShapes(e,i),2),o=a[0],s=a[1];this.outputShape=0===o.length?[1]:o,this.dispatchLayout=B(this.outputShape),t.util.sizeFromShape(s)<32||t.util.sizeFromShape(o)>1e3?(this.type="plain",this.dispatch=z(this.dispatchLayout,this.outputShape,this.workGroupSize)):(this.type="shared",this.dispatch=z(this.dispatchLayout,this.outputShape,[1,1,1])),this.inputShape=e,this.shaderKey="argMinMax_"+this.op+"_"+this.type}return e.prototype.getUserCode=function(){var e=this,t=function(){return 1===e.inputShape.length?"uniforms.xShape":"uniforms.xShape."+y(e.inputShape.length-1)},n=function(){var t="";if(1===e.outputShape.length)1!==e.inputShape.length&&(t+="outputCoords,");else for(var n=0;n<e.outputShape.length;n++)t+="outputCoords."+y(n)+",";return t};return"shared"===this.type?"\n      fn DIV_CEIL(a : u32, b : u32) -> u32 {\n        return ((a - 1u) / b + 1u);\n      }\n\n      "+("\n      var<workgroup> xBestIndices : array<i32, "+this.workGroupSize[0]+">;\n      var<workgroup> xBestValues : array<f32, "+this.workGroupSize[0]+">;\n    ")+"\n\n      "+w("index")+" {\n        let outputIndex = index / i32(workGroupSizeX);\n        let reduceLength = "+t()+";\n\n        var bestIndex = i32(localId.x);\n        var bestValue = uniforms.infinityValue;\n        let outputCoords = getCoordsFromIndex(outputIndex);\n        for (var k = i32(localId.x); k < reduceLength && outputIndex < uniforms.size;\n            k = k + i32(workGroupSizeX)) {\n          let candidate = getX("+n()+" k);\n          if (!isnan(candidate) && candidate "+this.op+" bestValue) {\n            bestValue = candidate;\n            bestIndex = k;\n          }\n        }\n        xBestValues[localId.x] = bestValue;\n        xBestIndices[localId.x] = bestIndex;\n        workgroupBarrier();\n\n        var reduceSize = min(u32(reduceLength), workGroupSizeX);\n        for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n            currentSize = reduceSize / 2u) {\n          let interval = DIV_CEIL(reduceSize, 2u);\n          if (localId.x < currentSize) {\n            let candidate = xBestValues[localId.x + interval];\n            if (candidate "+this.op+" bestValue) {\n              bestValue = candidate;\n              xBestValues[localId.x] = bestValue;\n              xBestIndices[localId.x] = xBestIndices[localId.x + interval];\n            }\n          }\n          reduceSize = interval;\n          workgroupBarrier();\n        }\n\n        if (localId.x == 0u && outputIndex < uniforms.size) {\n          setOutputAtIndexI32(outputIndex, xBestIndices[localId.x]);\n        }\n      }\n    ":"\n      "+w("index")+" {\n        if (index < uniforms.size) {\n          let outputCoords = getCoordsFromIndex(index);\n          var bestIndex = 0;\n          var bestValue = getX("+n()+" 0);\n          let reduceLength = "+t()+";\n          for (var i = 1; i < reduceLength; i++) {\n            let candidate = getX("+n()+" i);\n            if (candidate "+this.op+" bestValue) {\n              bestValue = candidate;\n              bestIndex = i;\n            }\n          }\n          setOutputAtIndexI32(index, bestIndex);\n        }\n      }\n      "},e}(),Pt=function(){function e(e,t){this.variableNames=["A"],this.workGroupSize=[16,16,1];for(var n=new Array(e.length),r=0;r<n.length;r++)n[r]=e[t[r]];this.outputShape=n,this.dispatchLayout={x:[0],y:[1]},this.dispatch=z(this.dispatchLayout,this.outputShape,this.workGroupSize,[1,1,1]),this.shaderKey="transposeShared"}return e.prototype.getUserCode=function(){return"\n      const TILE_DIM = "+this.workGroupSize[0]+";\n      var<workgroup> tile : array<array<f32, "+(this.workGroupSize[0]+1)+">, "+this.workGroupSize[0]+">;\n      \n  @compute @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n\n      fn _start(@builtin(local_invocation_id) localId : vec3<u32>,\n                @builtin(workgroup_id) workgroupId : vec3<u32>) {\n        var x = i32(workgroupId.x) * TILE_DIM + i32(localId.x);\n        var y = i32(workgroupId.y) * TILE_DIM + i32(localId.y);\n        let width = uniforms.outShape[0];\n        let height = uniforms.outShape[1];\n        if (x < width && y < height) {\n          tile[localId.y][localId.x] = A[y * width + x];\n        }\n        workgroupBarrier();\n\n        x = i32(workgroupId.y) * TILE_DIM + i32(localId.x);\n        y = i32(workgroupId.x) * TILE_DIM + i32(localId.y);\n        if (x < height && y < width) {\n          setOutputAtIndex((y * height + x), tile[localId.x]\n            [localId.y]);\n        }\n      }\n    "},e}(),_t=function(){function e(e,t){this.variableNames=["A"],this.workPerThread=1,this.workGroupSize=[64,1,1],this.size=!0;for(var n=new Array(e.length),r=0;r<n.length;r++)n[r]=e[t[r]];this.outputShape=n,this.dispatchLayout=B(this.outputShape),this.dispatch=z(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.newDim=t,this.shaderKey="transpose_"+t}return e.prototype.getUserCode=function(){var e=x(this.outputShape.length),t=function(e){var t=e.length;if(t>6)throw Error("Transpose for rank "+t+" is not yet supported");for(var n=new Array(t),r=0;r<e.length;r++)n[e[r]]="resRC."+y(r);return n.join()}(this.newDim);return"\n      "+w("index")+" {\n        for(var i = 0; i < "+this.workPerThread+"; i = i + 1) {\n          let flatIndex = index * "+this.workPerThread+" + i;\n          if(flatIndex < uniforms.size) {\n            let resRC = getCoordsFromIndex(flatIndex);\n            setOutputAtIndex(flatIndex, A[getIndexFromCoords"+this.outputShape.length+"D(\n              "+e+"("+t+"), uniforms.aShape)]);\n          }\n        }\n      }\n    "},e}();function Nt(e){for(var n=e.inputs,r=e.backend,i=e.attrs,a=n.x,o=i.perm,s=r,u=a.shape.length,l=new Array(u),d=0;d<l.length;d++)l[d]=a.shape[o[d]];if(r.shouldExecuteOnCPU([a])){var h=s.tensorMap.get(a.dataId).values,p=kt(h,a.shape,a.dtype,o,l);return r.makeTensorInfo(l,a.dtype,p)}if(2===a.shape.length&&t.util.arraysEqual(o,[1,0])){var c=new Pt(a.shape,o);return s.runWebGPUProgram(c,[a],a.dtype)}var f=new _t(a.shape,o);return s.runWebGPUProgram(f,[a],a.dtype)}var Bt={kernelName:t.Transpose,backendName:"webgpu",kernelFunc:Nt};var Et={kernelName:t.ArgMax,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,r=e.backend,i=e.attrs,a=n.x,o=i.axis,s=t.util.parseAxisParam(o,a.shape),u=t.backend_util.getAxesPermutation(s,a.shape.length),l=a,d=[];null!=u&&(l=Nt({inputs:{x:a},backend:r,attrs:{perm:u}}),d.push(l),s=t.backend_util.getInnerMostAxes(s.length,l.shape.length)),t.backend_util.assertAxesAreInnerMostDims("argMax",[s[0]],l.shape.length);var h=new zt(l.shape,s[0],"max"),p=[{type:"float32",data:[Number.NEGATIVE_INFINITY]}],c=r.runWebGPUProgram(h,[l],"int32",p);return d.forEach((function(e){return r.disposeData(e.dataId)})),c}};var Ft={kernelName:t.ArgMin,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,r=e.backend,i=e.attrs,a=n.x,o=i.axis,s=t.util.parseAxisParam(o,a.shape),u=t.backend_util.getAxesPermutation(s,a.shape.length),l=a,d=[];null!=u&&(l=Nt({inputs:{x:a},backend:r,attrs:{perm:u}}),d.push(l),s=t.backend_util.getInnerMostAxes(s.length,l.shape.length)),t.backend_util.assertAxesAreInnerMostDims("argMin",[s[0]],l.shape.length);var h=new zt(l.shape,s[0],"min"),p=[{type:"float32",data:[Number.POSITIVE_INFINITY]}],c=r.runWebGPUProgram(h,[l],"int32",p);return d.forEach((function(e){return r.disposeData(e.dataId)})),c}},Gt=we({opType:D.ATAN2}),Lt={kernelName:t.Atan2,backendName:"webgpu",kernelFunc:Gt},Ot=function(){function e(e,t){this.variableNames=["x"],this.uniforms="stride : vec2<i32>, pad : vec2<i32>, dilation : vec2<i32>, convDims : vec2<i32>, filterDims : vec2<i32>,",this.workGroupSize=[128,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=B(this.outputShape),this.dispatch=z(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="pool2D_"+t,this.poolType=t}return e.prototype.getUserCode=function(){var e="resultValue = max(value, resultValue);";"avg"===this.poolType&&(e="resultValue = resultValue + value; count = count + 1.0;");var t="resultValue";return"avg"===this.poolType&&(t="resultValue / count"),"\n      "+w("index")+" {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n          let batch = coords[0];\n          let xRCCorner = vec2<i32>(coords.yz) * uniforms.stride - uniforms.pad;\n          let xRCorner = xRCCorner.x;\n          let xCCorner = xRCCorner.y;\n\n          var resultValue = "+("avg"===this.poolType?"0.0":"-1.0 / pow(10.0, -20.0)")+";\n          var count = 0.0;\n\n          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilation.x) {\n            let xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= uniforms.convDims.x) {\n              continue;\n            }\n\n            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilation.y) {\n              let xC = xCCorner + wC;\n              if (xC < 0 || xC >= uniforms.convDims.y) {\n                continue;\n              }\n\n              let value = getX(batch, xR, xC, coords[3]);\n              "+e+"\n            }\n          }\n\n          setOutputAtIndex(index, "+t+");\n        }\n      }\n    "},e}(),Ut=function(){function e(e){this.variableNames=["x"],this.uniforms="stride : vec2<i32>,",this.workGroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=B(this.outputShape),this.dispatch=z(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="poolWithFilterSizeEqualsOne"}return e.prototype.getUserCode=function(){return"\n      "+w("index")+" {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let batch = coords[0];\n          let d = coords[3];\n\n          let xRCCorner = coords.yz * uniforms.stride;\n          let xRCorner = xRCCorner.x;\n          let xCCorner = xRCCorner.y;\n\n          let value = getX(batch, xRCorner, xCCorner, d);\n          setOutputAtIndex(index, value);\n        }\n      }\n    "},e}(),Dt=function(){function e(e,n){this.workGroupSize=[64,1,1],this.variableNames=["x"],this.uniforms="reduceSize : i32,",this.size=!0,this.inputShape=[e.batchSize,e.inSize];var r=u(t.backend_util.computeOutAndReduceShapes(this.inputShape,[1]),1)[0];this.outputShape=0===r.length?[1]:r,this.dispatchLayout=B(this.outputShape),this.dispatch=z(this.dispatchLayout,this.outputShape,[1,1,1]),this.reduceType=n,this.shaderKey="reduce_"+n}return e.prototype.getUserCode=function(){var e="",t="0.0";"min"===this.reduceType||"max"===this.reduceType?(e="\n         if (isnan(candidate)) {\n          bestValue = uniforms.NAN;\n         } else if (!isnan(bestValue) && candidate "+("min"===this.reduceType?"<":">")+" bestValue)\n           {  bestValue = candidate; }",t="f32(x[offset])"):"sum"===this.reduceType||"mean"===this.reduceType?e=" bestValue = bestValue + candidate; ":"prod"===this.reduceType&&(e=" bestValue = bestValue * candidate; ",t="1.0");var n="mean"===this.reduceType?"setOutputAtIndex(outputIndex, bestValue / f32(uniforms.reduceSize));":"setOutputAtIndex(outputIndex, bestValue);";return"\n       fn DIV_CEIL(a : u32, b : u32) -> u32 {\n        return ((a - 1u) / b + 1u);\n       }\n\n       "+("\n         var<workgroup> xBestValues : array<f32, "+this.workGroupSize[0]+">;\n       ")+"\n       fn getOffset(outputIndex : i32) -> i32 {\n         let outputCoords = getCoordsFromIndex(outputIndex);\n         let offset = "+(1===this.outputShape.length?"outputCoords":"outputCoords[0]")+" * uniforms.reduceSize;\n          return offset;\n       }\n       "+w("index")+" {\n         let outputIndex = index / i32(workGroupSizeX);\n         let offset = getOffset(outputIndex);\n         var bestValue = "+t+";\n         let Length = uniforms.reduceSize;\n         let WorkPerThread = DIV_CEIL(u32(Length), workGroupSizeX);\n         for (var k = i32(localId.x); k < Length && outputIndex < uniforms.size;\n             k = k + i32(workGroupSizeX)) {\n           let candidate = f32(x[offset + k]);\n           "+e+"\n         }\n         xBestValues[localId.x] = bestValue;\n         workgroupBarrier();\n\n         var reduceSize = min(u32(Length), workGroupSizeX);\n         for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n             currentSize = reduceSize / 2u) {\n           let interval = DIV_CEIL(reduceSize, 2u);\n           if (localId.x < currentSize) {\n            let candidate = xBestValues[localId.x + interval];\n            "+e+"\n            xBestValues[localId.x] = bestValue;\n           }\n           reduceSize = interval;\n           workgroupBarrier();\n         }\n\n         if (localId.x == 0u && outputIndex < uniforms.size) {\n          "+n+"\n        }\n       }\n     "},e}();function Wt(e,n,r,i,a){var o=e.shape.length,s=[],l=t.util.parseAxisParam(n,e.shape),d=l,h=t.backend_util.getAxesPermutation(d,o),p=e;null!=h&&(p=Nt({inputs:{x:e},attrs:{perm:h},backend:a}),d=t.backend_util.getInnerMostAxes(d.length,o),s.push(p)),t.backend_util.assertAxesAreInnerMostDims(i,d,o);var c,f=u(t.backend_util.computeOutAndReduceShapes(p.shape,d),2),m=f[0],v=f[1],g=m;if(r&&(g=t.backend_util.expandShapeToKeepDim(m,l)),"max"!==i&&"prod"!==i||!a.shouldExecuteOnCPU([p])){var b=t.util.sizeFromShape(v),x={windowSize:b,inSize:b,batchSize:t.util.sizeFromShape(p.shape)/b,outSize:1},y="mean"===i?"float32":t.sumOutType(e.dtype),w=[{type:"int32",data:[b]}],k=new Dt(x,i),I=a.runWebGPUProgram(k,[p],y,w);s.push(I),c=le({inputs:{x:I},attrs:{shape:g},backend:a})}else{var S=a.tensorMap.get(p.dataId).values;switch(i){case"max":var C=at(S,t.util.sizeFromShape(v),g,e.dtype);c=a.makeTensorInfo(g,e.dtype,C);break;case"prod":var R=ht(p.shape,p.dtype,S,d),A=R.outVals,T=R.outShape,z=R.outDtype;c=a.makeTensorInfo(T,z,A);break;default:throw new Error(i+" CPU implementation is not yet supported.")}}return s.forEach((function(e){return a.disposeData(e.dataId)})),c}function Mt(e){var t=e.inputs,n=e.backend,r=e.attrs;return Wt(t.x,r.reductionIndices,r.keepDims,"max",n)}var Vt={kernelName:t.Max,backendName:"webgpu",kernelFunc:Mt};function Ht(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,a=r.keepDims;return Wt(i,r.axis,a,"mean",n)}var Xt={kernelName:t.Mean,backendName:"webgpu",kernelFunc:Ht};function qt(e,n,r,i){if(1===n.filterWidth&&1===n.filterHeight&&t.util.arraysEqual(n.inShape,n.outShape))return me({inputs:{x:e},backend:i});if(n.filterWidth===n.inWidth&&n.filterHeight===n.inHeight&&1===n.batchSize&&"VALID"===n.padInfo.type){var a=e.shape.length,o=le({inputs:{x:e},backend:i,attrs:{shape:[e.shape[a-3]*e.shape[a-2],e.shape[a-1]]}}),s=void 0;"avg"===r?s=Ht({inputs:{x:o},backend:i,attrs:{axis:0,keepDims:!1}}):(t.util.assert("max"===r,(function(){return"Invalid pool type "+r})),s=Mt({inputs:{x:o},backend:i,attrs:{reductionIndices:0,keepDims:!1}}));var u=le({inputs:{x:s},backend:i,attrs:{shape:n.outShape}});return i.disposeData(o.dataId),i.disposeData(s.dataId),u}var l,d=[{type:"int32",data:[n.strideHeight,n.strideWidth]}];return 1===n.filterHeight&&1===n.filterWidth?l=new Ut(n):("avg"===r?l=new Ot(n,"avg"):(t.util.assert("max"===r,(function(){return"Invalid pool type "+r})),l=new Ot(n,"max")),d.push({type:"int32",data:[n.padInfo.top,n.padInfo.left]},{type:"int32",data:[n.dilationHeight,n.dilationWidth]},{type:"int32",data:[n.inHeight,n.inWidth]},{type:"int32",data:[n.effectiveFilterHeight,n.effectiveFilterWidth]})),i.runWebGPUProgram(l,[e],e.dtype,d)}var Kt={kernelName:t.AvgPool,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,r=e.backend,i=e.attrs,a=n.x,o=i.filterSize,s=i.strides,u=i.pad,l=i.dimRoundingMode;return qt(a,t.backend_util.computePool2DInfo(a.shape,o,s,1,u,l),"avg",r)}};var jt={kernelName:t.BatchMatMul,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs;return he({a:t.a,b:t.b,transposeA:r.transposeA,transposeB:r.transposeB,backend:n})}},Yt=function(){function e(e,t){this.variableNames=["source"],this.workPerThread=1,this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.rank=t.length,this.dispatchLayout=B(this.outputShape),this.dispatch=z(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.start=e,this.uniforms="start : "+x(e.length)+", ",this.shaderKey="slice"}return e.prototype.getUserCode=function(){var e,t=x(this.rank),n=function(e){if(1===e)return"sourceLoc";if(e<=6)return Qt.slice(0,e).map((function(e){return"sourceLoc."+e})).join(",");throw Error("Slicing for rank "+e+" is not yet supported")}(this.rank);return e=1===this.start.length?this.outputShape.map((function(e,t){return"sourceLoc = uniforms.start + coords;"})):this.outputShape.map((function(e,t){return"sourceLoc."+Qt[t]+" = uniforms.start."+y(t)+" + coords."+Qt[t]+";"})),"\n      "+w("index")+" {\n        if (index < uniforms.size) {\n          var sourceLoc : "+t+";\n          let coords = getCoordsFromIndex(index);\n          "+e.join("\n")+"\n          setOutputAtIndex(index, getSource("+n+"));\n        }\n      }\n    "},e}(),Qt=["x","y","z","w","u","v"];function Zt(e){var n=e.inputs,r=e.backend,i=e.attrs,a=n.x,o=i.begin,s=i.size,l=u(t.slice_util.parseSliceParams(a,o,s),2),d=l[0],h=l[1];if(t.slice_util.assertParamsValid(a,d,h),r.shouldExecuteOnCPU([a])||"string"===a.dtype){var p=r.tensorMap.get(a.dataId),c=vt(p.values,d,h,a.shape,a.dtype);return r.makeTensorInfo(h,a.dtype,c)}if(0===t.util.sizeFromShape(h))return r.makeTensorInfo(h,a.dtype,[]);var f=new Yt(d,h),m=[{type:"int32",data:d}];return r.runWebGPUProgram(f,[a],a.dtype,m)}var Jt={kernelName:t.Slice,backendName:"webgpu",kernelFunc:Zt},$t={kernelName:t.BatchToSpaceND,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,r=e.backend,i=e.attrs,a=n.x,o=i.blockShape,s=i.crops;t.util.assert(a.shape.length<=4,(function(){return"batchToSpaceND for rank > 4 with a WebGPU backend not implemented yet"}));var u=o.reduce((function(e,t){return e*t})),l=t.backend_util.getReshaped(a.shape,o,u),d=t.backend_util.getPermuted(l.length,o.length),h=t.backend_util.getReshapedPermuted(a.shape,o,u),p=t.backend_util.getSliceBeginCoords(s,o.length),c=t.backend_util.getSliceSize(h,s,o.length),f=[],m=le({inputs:{x:a},backend:r,attrs:{shape:l}}),v=Nt({inputs:{x:m},backend:r,attrs:{perm:d}}),g=le({inputs:{x:v},backend:r,attrs:{shape:h}}),b=Zt({inputs:{x:g},backend:r,attrs:{begin:p,size:c}});return f.push(m),f.push(v),f.push(g),f.forEach((function(e){return r.disposeData(e.dataId)})),b}},en=we({opType:D.NOT_EQUAL,dtype:"bool",cpuKernelImpl:dt}),tn={kernelName:t.NotEqual,backendName:"webgpu",kernelFunc:en};function nn(e){var t=e.inputs,n=e.backend,r=t.input;return me({inputs:{x:n.tensorMap.get(r.dataId).complexTensorInfos.real},backend:n})}var rn={kernelName:t.Real,backendName:"webgpu",kernelFunc:nn};var an={kernelName:t.Cast,backendName:"webgpu",kernelFunc:function e(n){var i=n.inputs,a=n.backend,o=n.attrs,s=i.x,l=o.dtype;if("complex64"===l){if("complex64"===s.dtype)return me({inputs:{x:s},backend:a});var d=r.zeros(s.shape),h=e({inputs:{x:s},backend:a,attrs:{dtype:"float32"}}),p=ge({inputs:{real:h,imag:d},backend:a});return d.dispose(),a.disposeData(h.dataId),p}if("complex64"===s.dtype){var c=nn({inputs:{input:s},backend:a}),p=e({inputs:{x:c},backend:a,attrs:{dtype:l}});return a.disposeData(c.dataId),p}if(!t.util.hasEncodingLoss(s.dtype,l))return{dataId:(p=me({inputs:{x:s},backend:a})).dataId,shape:p.shape,dtype:l};if(a.shouldExecuteOnCPU([s])){var f=a.tensorMap.get(s.dataId).values,m=u(Xe(f,s.shape,s.dtype,l),3),v=m[0],g=m[1],b=m[2];return a.makeTensorInfo(v,g,b)}if("int32"===l)return function(e,t){var n=new xe(e.shape,W.TO_INT),r=t.runWebGPUProgram(n,[e],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}(s,a);if("bool"===l){var x=a.makeTensorInfo([],"bool",t.util.getTypedArrayFromDType("bool",1));p=en({inputs:{a:s,b:x},backend:a});return a.disposeData(x.dataId),p}throw new Error("Error in Cast: failed to cast "+s.dtype+" to "+l)}},on=ye({opType:W.CEIL,cpuKernelImpl:qe}),sn={kernelName:t.Ceil,backendName:"webgpu",kernelFunc:on},un=function(){function e(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workPerThread=4,this.workGroupSize=[64,1,1],this.isVec4=!0,this.size=!0,this.outputShape=e,this.dispatchLayout=B(this.outputShape),this.dispatch=z(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.shaderKey="clipVec4"}return e.prototype.getUserCode=function(){return"\n      "+w("index")+" {\n        if(index < uniforms.size) {\n          let value = getAByOutputIndex(index);\n          var clampedValue : vec4<f32>;\n          for (var i = 0; i < 4; i = i + 1) {\n            if (isnan(value[i])) {\n              clampedValue[i] = value[i];\n            } else {\n              clampedValue[i] = clamp(value[i], uniforms.minVal, uniforms.maxVal);\n            }\n          }\n\n          setOutputAtIndex(index, clampedValue);\n        }\n      }\n    "},e}(),ln=function(){function e(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=B(this.outputShape),this.dispatch=z(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="clip"}return e.prototype.getUserCode=function(){return"\n      "+w("index")+" {\n        if(index < uniforms.size) {\n          let value = getAByOutputIndex(index);\n          if (isnan(value)) {\n            setOutputAtIndex(index, value);\n            return;\n          }\n          setOutputAtIndex(index, clamp(value, uniforms.minVal, uniforms.maxVal));\n        }\n      }\n    "},e}();var dn={kernelName:t.ClipByValue,backendName:"webgpu",kernelFunc:function(e){var n,r=e.inputs,i=e.backend,a=e.attrs,o=r.x,s=[{type:"float32",data:[a.clipValueMin]},{type:"float32",data:[a.clipValueMax]}];return n=t.util.sizeFromShape(o.shape)%4==0?new un(o.shape):new ln(o.shape),i.runWebGPUProgram(n,[o],o.dtype,s)}},hn=function(){function e(e){this.uniforms="",this.workPerThread=1,this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=t.backend_util.computeOutShape(e,1),this.variableNames=e.map((function(e,t){return"T"+t})),this.dispatchLayout=B(this.outputShape),this.dispatch=z(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.offsetLength=e.length-1;for(var n=0;n<this.offsetLength;n++)this.uniforms+="offset"+n+" : i32,";this.shaderKey="concat"}return e.prototype.getUserCode=function(){var e=[];if(this.offsetLength>0){e.push("if (yC < uniforms.offset0){ setOutputAtCoords(coords.x, coords.y, getT0(yR, yC)); }");for(var t=1;t<this.offsetLength;t++)e.push("else if (yC < uniforms.offset"+[t]+"){ setOutputAtCoords(coords.x, coords.y, getT"+t+"(yR, yC - uniforms.offset"+(t-1)+")); }");var n=this.offsetLength,r=this.offsetLength-1;e.push("else { setOutputAtCoords(coords.x, coords.y, getT"+n+"(yR, yC - uniforms.offset"+r+")); }")}else e.push("setOutputAtCoords(coords.x, coords.y, getT0(yR, yC));");return"\n      "+w("index")+" {\n        for(var i = 0; i < "+this.workPerThread+"; i = i + 1) {\n          let flatIndex = index * "+this.workPerThread+" + i;\n          if(flatIndex < uniforms.size) {\n            let coords = getCoordsFromIndex(flatIndex);\n            let yR = coords.x;\n            let yC = coords.y;\n\n            "+e.join("\n        ")+"\n          }\n        }\n      }\n    "},e}();function pn(e){var t=e.inputs,n=e.backend,r=t.input;return me({inputs:{x:n.tensorMap.get(r.dataId).complexTensorInfos.imag},backend:n})}var cn={kernelName:t.Imag,backendName:"webgpu",kernelFunc:pn};function fn(e,n,r){var i,a,o=e[0].dtype;if("complex64"===o){var u=e.map((function(e){return nn({inputs:{input:e},backend:r})})),l=e.map((function(e){return pn({inputs:{input:e},backend:r})})),d=fn(u,n,r),h=fn(l,n,r),p=ge({inputs:{real:d,imag:h},backend:r});return u.forEach((function(e){return r.disposeData(e.dataId)})),l.forEach((function(e){return r.disposeData(e.dataId)})),r.disposeData(d.dataId),r.disposeData(h.dataId),p}var c=r.shouldExecuteOnCPU(e);if("string"===o&&(c=!0),c){var f=e.map((function(e){var i=t.util.sizeFromShape(e.shape.slice(n));return le({inputs:{x:e},backend:r,attrs:{shape:[-1,i]}})})),m=f.map((function(e){return{vals:r.readSync(e.dataId),shape:e.shape}})),v=t.backend_util.computeOutShape(f.map((function(e){return e.shape})),1),g=1===f[0].shape[0],b=Ke(m,v,o,g),x=t.backend_util.computeOutShape(e.map((function(e){return e.shape})),n),y=r.makeTensorInfo(x,o,b);return f.forEach((function(e){return r.disposeData(e.dataId)})),y}var w=r.device.limits.maxStorageBuffersPerShaderStage-1;if(e.length>w){for(var k=[],I=0;I<e.length;I+=w){var S=e.slice(I,I+w);k.push(fn(S,n,r))}p=fn(k,n,r);try{for(var C=s(k),R=C.next();!R.done;R=C.next()){I=R.value;r.disposeData(I.dataId)}}catch(e){i={error:e}}finally{try{R&&!R.done&&(a=C.return)&&a.call(C)}finally{if(i)throw i.error}}return p}var A=function(e,n,r){var i=t.backend_util.computeOutShape(e.map((function(e){return e.shape})),n);return{tensors2D:e.map((function(e){return le({inputs:{x:e},backend:r,attrs:{shape:[t.util.sizeFromShape(e.shape.slice(0,n)),t.util.sizeFromShape(e.shape.slice(n))]}})})),outShape:i}}(e,n,r),T=A.tensors2D,z=A.outShape,P=T.map((function(e){return e.shape})),_=new hn(P),N=[],B=new Array(P.length-1);if(B.length>0){B[0]=P[0][1],N.push({type:"int32",data:[B[0]]});for(I=1;I<B.length;I++)B[I]=B[I-1]+P[I][1],N.push({type:"int32",data:[B[I]]})}var E=r.runWebGPUProgram(_,T,T[0].dtype,N);T.forEach((function(e){return r.disposeData(e.dataId)}));var F=le({inputs:{x:E},backend:r,attrs:{shape:z}});return r.disposeData(E.dataId),F}function mn(e){var n=e.inputs,r=e.backend,i=e.attrs.axis,a=t.util.parseAxisParam(i,n[0].shape)[0],o=n.map((function(e){return e.shape}));t.backend_util.assertParamsConsistent(o,a);var s=t.backend_util.computeOutShape(n.map((function(e){return e.shape})),a);if(0===t.util.sizeFromShape(s))return r.makeTensorInfo(s,n[0].dtype,[]);var u=n.filter((function(e){return t.util.sizeFromShape(e.shape)>0}));return 1===u.length?me({inputs:{x:u[0]},backend:r}):fn(u,a,r)}var vn={kernelName:t.Concat,backendName:"webgpu",kernelFunc:mn};var gn=function(){function e(e,t,n,r,i,a,o,s){void 0===i&&(i=!1),void 0===a&&(a=null),void 0===o&&(o=!1),void 0===s&&(s=!1),this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>, dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.outShape,this.isChannelsLast="channelsLast"===e.dataFormat,this.isVec4=((e.inChannels%4==0||e.inChannels%3==0)&&this.isChannelsLast||e.outWidth%4==0&&!this.isChannelsLast)&&e.outChannels%4==0,this.dispatchLayout=this.isChannelsLast?{x:[3],y:[1,2],z:[0]}:{x:[2,3],y:[1],z:[0]},this.workGroupSize=_(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=N(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=z(this.dispatchLayout,this.outputShape,this.workGroupSize,this.elementsPerThread),this.isVec4?(this.isChannelsLast&&e.inChannels%4!=0?(this.innerElementSize=3,this.variableTypes=["f32","vec4<f32>"]):(this.innerElementSize=4,this.variableTypes=["vec4<f32>","vec4<f32>"]),i&&(this.variableNames.push("bias"),this.variableTypes.push("vec4<f32>")),o&&(this.variableNames.push("preluActivationWeights"),this.variableTypes.push("vec4<f32>"))):(this.innerElementSize=this.elementsPerThread[0],i&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights")),this.sequentialAccessByThreads=s,this.addBias=i,this.activation=a,this.hasPreluActivationWeights=o,this.tileAOuter=this.workGroupSize[1]*this.elementsPerThread[1],this.tileBOuter=this.workGroupSize[0]*this.elementsPerThread[0],this.tileInner=Math.max(this.workGroupSize[0]*this.innerElementSize,this.workGroupSize[1]),this.fitAOuter=t%this.tileAOuter==0,this.fitBOuter=n%this.tileBOuter==0,this.fitInner=r%this.tileInner==0,this.shaderKey="conv2DMM_"+this.elementsPerThread+"_"+this.activation+"}_"+this.fitAOuter+"_"+this.fitBOuter+"_"+this.fitInner+"_"+this.isVec4+"_"+this.innerElementSize+"_"+this.isChannelsLast+"_"+this.sequentialAccessByThreads}return e.prototype.getUserCode=function(){var e=this.isVec4?J(this.elementsPerThread,this.workGroupSize,!this.isChannelsLast,this.tileInner):ee(this.elementsPerThread,this.workGroupSize,!this.isChannelsLast,this.tileInner,!1,null,this.sequentialAccessByThreads),t=this.isVec4?[this.innerElementSize,4,4]:[1,1,1];return"\n    "+function(e,t,n,r,i,a,o,s,u,l){void 0===i&&(i=!1),void 0===a&&(a=null),void 0===o&&(o=!1),void 0===s&&(s=4),void 0===u&&(u=4),void 0===l&&(l=4);var d=e?"\n      let coord = vec4<i32>(batch, xRow, xCol, xCh);\n      ":"\n      let coord = vec4<i32>(batch, xCh, xRow, xCol);\n      ",h=e?"\n      let coords = vec4<i32>(\n        batch,\n        row / outWidth,\n        row % outWidth,\n        col);\n      ":"\n      let coords = vec4<i32>(\n        batch,\n        row,\n        col / outWidth,\n        col % outWidth);\n      ",p=e?"uniforms.xShape[1]":"uniforms.xShape[2]",c=e?"uniforms.xShape[2]":"uniforms.xShape[3]",f=e?"row":"col",m=e?"col":"row",v="\n      let inChannels = uniforms.wShape[2];\n      let outWidth = "+(e?"uniforms.outShape[2]":"uniforms.outShape[3]")+";\n      let outRow = "+f+" / outWidth;\n      let outCol = "+f+" % outWidth;\n\n      let WRow = "+m+" / (uniforms.filterDims[1] * inChannels);\n      let WCol = "+m+" / inChannels % uniforms.filterDims[1];\n      let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];\n      let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];\n      let xCh = "+m+" % inChannels;\n      var resData = "+K(s)+"(0.0);\n      // The bounds checking is always needed since we use it to pad zero for\n      // the 'same' padding type.\n      if (xRow >= 0 && xRow < "+p+" && xCol >= 0 && xCol < "+c+") {\n        "+d+"\n        let xIndex = getIndexFromCoords4D(coord, uniforms.xShape);\n        "+function(e){switch(e){case 1:return"resData = x[xIndex];";case 3:return"resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";case 4:return"resData = x[xIndex / 4];";default:throw new Error("innerElementSize "+e+" is not supported.")}}(s)+"\n      }\n      return resData;",g=e?t&&r?"\n      let col = colIn * "+s+";\n      "+v:"\n      let col = colIn * "+s+";\n      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {\n        "+v+"\n      }\n      return "+K(s)+"(0.0);":r&&n?"\n      let col = colIn * "+s+";\n      "+v:"\n      let col = colIn * "+s+";\n      if (row < uniforms.dimInner && col < uniforms.dimBOuter) {\n        "+v+"\n      }\n      return "+K(s)+"(0.0);",b=""+function(e){switch(e){case 1:return"return W[row * uniforms.wShape[3] + colIn];";case 4:return"return W[row * uniforms.wShape[3] / 4 + colIn];";default:throw new Error("innerElementSize "+e+" is not supported.")}}(u),x=K(l),y=K(e?s:u),w=K(e?u:s);return"\n      "+j(a,o,4===l,4)+"\n      fn mm_readA(batch: i32, row : i32, colIn : i32) -> "+y+" {\n        "+(e?g:b)+"\n      }\n\n      fn mm_readB(batch: i32, row : i32, colIn : i32) -> "+w+" {\n        "+(e?b:g)+"\n      }\n\n      fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : "+x+") {\n        let col = colIn * "+l+";\n        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)\n        {\n        var value = valueIn;\n        let outWidth = "+(e?"uniforms.outShape[2]":"uniforms.outShape[3]")+";\n        "+h+"\n        "+Y(i,a)+"\n        setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n        }\n      }"}(this.isChannelsLast,this.fitAOuter,this.fitBOuter,this.fitInner,this.addBias,this.activation,this.hasPreluActivationWeights,t[0],t[1],t[2])+"\n    "+e+"\n  "},e}(),bn=function(){function e(e,t,n,r){void 0===t&&(t=!1),void 0===n&&(n=null),void 0===r&&(r=!1),this.variableNames=["x","W"],this.uniforms="filterDims: vec2<i32>, pad: vec2<i32>, stride: vec2<i32>, dilation: vec2<i32>,",this.workGroupSize=[4,4,8],this.outputShape=e.outShape,this.isChannelsLast="channelsLast"===e.dataFormat,this.dispatchLayout=this.isChannelsLast?{x:[2],y:[1],z:[0,3]}:{x:[3],y:[2],z:[0,1]},this.dispatch=z(this.dispatchLayout,this.outputShape,this.workGroupSize),this.addBias=t,this.activation=n,this.hasPreluActivationWeights=r,t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.shaderKey="conv2dnaive_"+this.activation+"_"+this.isChannelsLast}return e.prototype.getUserCode=function(){return"\n       "+j(this.activation,this.hasPreluActivationWeights,!1,4)+"\n       fn readInp(batch : i32, row : i32, col : i32, chan : i32) -> f32{\n         let coords = vec4<i32>(batch, row, col, chan);\n         if (coordsInBounds4D(coords, uniforms.xShape)) {\n           return  getX(batch, row, col, chan);\n         } else {\n          return 0.0;\n         }\n       }\n       fn readFilt(row : i32, col : i32, xChannel : i32, outChannel : i32) -> f32{\n         let coords = vec4<i32>(row, col, xChannel, outChannel);\n         if(coordsInBounds4D(coords, uniforms.wShape)) {\n           return getW(row, col, xChannel, outChannel);\n          } else {\n            return 0.0;\n          }\n       }\n       fn writeResult(batch : i32, row : i32, col : i32, chan : i32, valueIn : f32) {\n         let coords = "+(this.isChannelsLast?"vec4<i32>(batch, row, col, chan);":"vec4<i32>(batch, chan, row, col);")+"\n         if (coordsInBounds4D(coords, uniforms.outShape)) {\n           var value = valueIn;\n           "+Y(this.addBias,this.activation)+"\n           setOutputAtCoords(coords.x, coords.y, coords.z, coords.w, value);\n         }\n       }\n       "+w("index")+" {\n         let coords = getOutputCoords();\n         let batch = coords[0];\n         let outChannel = "+(this.isChannelsLast?"coords[3];":"coords[1];")+"\n         let outRow = "+(this.isChannelsLast?"coords[1];":"coords[2];")+"\n         let outCol = "+(this.isChannelsLast?"coords[2];":"coords[3];")+"\n         var acc : f32 = 0.0;\n         for (var row = 0; row < uniforms.filterDims[0]; row = row + 1) {\n           for (var col = 0; col < uniforms.filterDims[1]; col = col + 1) {\n             let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * row - uniforms.pad[0];\n             let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * col - uniforms.pad[1];\n             for (var xChannel = 0; xChannel < "+(this.isChannelsLast?"uniforms.xShape[3];":"uniforms.xShape[1];")+" xChannel = xChannel + 1) {\n               "+(this.isChannelsLast?"let v = readInp(batch, xRow, xCol, xChannel);":"let v = readInp(batch, xChannel, xRow, xCol);")+"\n               let f = readFilt(row, col, xChannel, outChannel);\n               acc = acc + v * f;\n             }\n           }\n         }\n         writeResult(batch, outRow, outCol, outChannel, acc);\n       }\n     "},e}();function xn(e,t){var n=e.length;return n>=3?l(e.slice(0,-3),t?[e[n-3]*e[n-2],e[n-1]]:[e[n-3],e[n-2]*e[n-1]]):!t&&1===n&&e[0]>1?[e[0],1]:null}function yn(e){var n,r,i,a=e.x,o=e.filter,u=e.convInfo,d=e.backend,h=e.bias,p=void 0===h?null:h,c=e.preluActivationWeights,f=void 0===c?null:c,m=e.leakyreluAlpha,v=void 0===m?0:m,g=e.activation,b=void 0===g?null:g,x=null!=p,y=null!=f,w="channelsLast"===u.dataFormat,k=w&&u.filterHeight===u.inHeight&&u.filterWidth===u.inWidth&&"VALID"===u.padInfo.type,I=t.env().getBool("WEBGPU_USE_NAIVE_CONV2D_DEBUG");if(!I&&(k||1===u.filterHeight&&1===u.filterWidth&&1===u.dilationHeight&&1===u.dilationWidth&&1===u.strideHeight&&1===u.strideWidth&&("SAME"===u.padInfo.type||"VALID"===u.padInfo.type)))return function(e){var t,n,r,i,a,o=e.x,u=e.filter,l=e.convInfo,d=e.backend,h=e.bias,p=void 0===h?null:h,c=e.preluActivationWeights,f=void 0===c?null:c,m=e.leakyreluAlpha,v=void 0===m?0:m,g=e.activation,b=void 0===g?null:g,x="channelsLast"===l.dataFormat,y=!x,w=[];if(x&&l.filterHeight===l.inHeight&&l.filterWidth===l.inWidth&&"VALID"===l.padInfo.type){var k=l.inHeight*l.inWidth*l.inChannels;r=le({inputs:{x:o},backend:d,attrs:{shape:[1,l.batchSize,k]}}),i=le({inputs:{x:u},backend:d,attrs:{shape:[1,k,l.outChannels]}})}else r=le({inputs:{x:o},backend:d,attrs:{shape:x?[l.batchSize,l.inHeight*l.inWidth,l.inChannels]:[l.batchSize,l.inChannels,l.inHeight*l.inWidth]}}),i=le({inputs:{x:u},backend:d,attrs:{shape:[1,l.inChannels,l.outChannels]}});w.push(r),w.push(i),null!=f&&null!=(a=xn(f.shape,x))&&(f=le({inputs:{x:f},backend:d,attrs:{shape:a}}),w.push(f)),null!=p&&null!=(a=xn(p.shape,x))&&(p=le({inputs:{x:p},backend:d,attrs:{shape:a}}),w.push(p));var I=he({a:x?r:i,b:x?i:r,transposeA:y,transposeB:!1,backend:d,bias:p,activation:b,preluActivationWeights:f,leakyreluAlpha:v}),S=le({inputs:{x:I},backend:d,attrs:{shape:l.outShape}});w.push(I);try{for(var C=s(w),R=C.next();!R.done;R=C.next()){var A=R.value;d.disposeData(A.dataId)}}catch(e){t={error:e}}finally{try{R&&!R.done&&(n=C.return)&&n.call(C)}finally{if(t)throw t.error}}return S}({x:a,filter:o,convInfo:u,backend:d,bias:p,activation:b,preluActivationWeights:f,leakyreluAlpha:v});var S=[u.padInfo.top,u.padInfo.left],C=[{type:"int32",data:[u.filterHeight,u.filterWidth]},{type:"int32",data:l(S)},{type:"int32",data:[u.strideHeight,u.strideWidth]},{type:"int32",data:[u.dilationHeight,u.dilationWidth]}];if(I)i=new bn(u,x,b,y);else{var R=w?u.outHeight*u.outWidth:u.outChannels,A=w?u.outChannels:u.outHeight*u.outWidth,T=u.filterHeight*u.filterWidth*u.inChannels;C.push({type:"int32",data:[R]},{type:"int32",data:[A]},{type:"int32",data:[T]});var z=d.adapterInfo.isIntel();i=new gn(u,R,A,T,x,b,y,z)}var P=[],_=[a,o];x&&(w||1!==p.shape.length||(p=le({inputs:{x:p},backend:d,attrs:{shape:[p.shape[0],1,1]}}),P.push(p)),_.push(p)),y&&(w||1!==f.shape.length||(f=le({inputs:{x:f},backend:d,attrs:{shape:[f.shape[0],1,1]}}),P.push(f)),_.push(f)),"leakyrelu"===b&&(C.push({type:"float32",data:[v]}),i.uniforms+=" alpha : f32,");var N=d.runWebGPUProgram(i,_,a.dtype,C);try{for(var B=s(P),E=B.next();!E.done;E=B.next()){var F=E.value;d.disposeData(F.dataId)}}catch(e){n={error:e}}finally{try{E&&!E.done&&(r=B.return)&&r.call(B)}finally{if(n)throw n.error}}return N}var wn={kernelName:t.Conv2D,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,r=e.attrs,i=e.backend,a=n.x,o=n.filter,s=r.strides,u=r.pad,l=r.dataFormat,d=r.dilations,h=r.dimRoundingMode,p=t.backend_util.convertConv2DDataFormat(l);return yn({x:a,filter:o,convInfo:t.backend_util.computeConv2DInfo(a.shape,o.shape,s,d,u,h,!1,p),backend:i})}};var kn=function(){function e(e){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, stride : vec2<i32>, outBackprop : vec4<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.inShape,t.util.assert("channelsLast"===e.dataFormat,(function(){return"TODO: NCHW is unimplemented"})),this.isVec4=e.inChannels%4==0&&e.outChannels%4==0,this.dispatchLayout={x:[3],y:[1,2],z:[0]},this.workGroupSize=_(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=N(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=z(this.dispatchLayout,this.outputShape,this.workGroupSize,this.elementsPerThread),this.isVec4&&(this.variableTypes=["vec4<f32>","f32"]),this.shaderKey="conv2DDerInputMM_"+this.isVec4+"_"+this.elementsPerThread}return e.prototype.getUserCode=function(){var e=this.isVec4?J(this.elementsPerThread,this.workGroupSize):ee(this.elementsPerThread,this.workGroupSize);return"\n    "+function(e){void 0===e&&(e=4);var t="if (row < uniforms.dimAOuter && col < uniforms.dimInner) {\n        \n      let outRow = row / uniforms.outShape[2];\n      let outCol = row % uniforms.outShape[2];\n\n      let WRow = col / (uniforms.filterDims[1] * uniforms.outBackprop[3]);\n      let WCol = col / uniforms.outBackprop[3] % uniforms.filterDims[1];\n      let xR = f32(outRow - uniforms.pads[0] + WRow) / f32(uniforms.stride[0]);\n      let xC = f32(outCol - uniforms.pads[1] + WCol) / f32(uniforms.stride[1]);\n      if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {\n        return "+K(e)+"(0.0);\n      }\n      if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {\n        return "+K(e)+"(0.0);\n      }\n      let coord = vec4<i32>(\n          batch,\n          i32(xR),\n          i32(xC),\n          col % uniforms.outBackprop[3]);\n      return x[getIndexFromCoords4D(coord, uniforms.xShape)/"+e+"];\n      }\n      return "+K(e)+"(0.0);";return"\n  fn mm_readA(batch: i32, row : i32, colIn : i32) -> "+K(e)+" {\n    let col = colIn * "+e+";\n    "+t+"\n  }\n\n  fn mm_readB(batch: i32, row : i32, colIn : i32) -> "+K(e)+" {\n    let col = colIn * "+e+";\n    let coordX = uniforms.filterDims.x - 1 -\n        row / (uniforms.filterDims[1] * uniforms.outBackprop[3]);\n    let coordY = uniforms.filterDims.y - 1 -\n        (row / uniforms.outBackprop[3]) % uniforms.filterDims[1];\n    if (row < uniforms.dimInner && col < uniforms.dimBOuter &&\n        coordX >= 0 && coordY >= 0) {\n      let rowInner = row % uniforms.outBackprop[3];\n      let coord = vec4<i32>(coordX, coordY, col, rowInner);\n      "+function(e){switch(e){case 1:return"return W[getIndexFromCoords4D(coord, uniforms.wShape)];";case 4:return"\n            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);\n            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);\n            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);\n            let v0 = W[getIndexFromCoords4D(coord, uniforms.wShape)];\n            let v1 = W[getIndexFromCoords4D(coord1, uniforms.wShape)];\n            let v2 = W[getIndexFromCoords4D(coord2, uniforms.wShape)];\n            let v3 = W[getIndexFromCoords4D(coord3, uniforms.wShape)];\n            return vec4<f32>(v0, v1, v2, v3);\n            ";default:throw new Error("innerElementSize "+e+" is not supported.")}}(e)+"\n    }\n    return "+K(e)+"(0.0);\n  }\n\n  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : "+K(e)+") {\n    let col = colIn * "+e+";\n    if (row < uniforms.dimAOuter && (col + "+(e-1)+") < uniforms.dimBOuter) {\n      var value = valueInput;\n      let outCoord = vec4<i32>(\n          batch,\n          row / uniforms.outShape[2],\n          row % uniforms.outShape[2],\n          col);\n      result[getIndexFromCoords4D(outCoord, uniforms.outShape)/"+e+"] = value;\n    }\n  }"}(this.isVec4?4:1)+"\n    "+e+"\n    "},e}(),In=function(){function e(e){this.variableNames=["dy","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, stride : vec2<i32>, outBackprop : vec4<i32>,",this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=B(this.outputShape),this.dispatch=z(this.dispatchLayout,this.outputShape,this.workGroupSize),this.isChannelsLast="channelsLast"===e.dataFormat,this.shaderKey="conv2DDerInput_"+this.isChannelsLast}return e.prototype.getUserCode=function(){var e=this.isChannelsLast?1:2,t=this.isChannelsLast?2:3,n=this.isChannelsLast?3:1;return"\n    "+w("index")+" {\n      if(index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords[0];\n        let d1 = coords["+n+"];\n\n        let dyCorner = vec2<i32>(coords["+e+"], coords["+t+"]) - uniforms.pads;\n        let dyRCorner = dyCorner.x;\n        let dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {\n          let dyR = (f32(dyRCorner) + f32(wR)) / f32(uniforms.stride.x);\n          let wRPerm = uniforms.filterDims.x - 1 - wR;\n          if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) || fract(dyR) > 0.0 ||\n              wRPerm < 0) {\n            continue;\n          }\n          let idyR = i32(dyR);\n\n          for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {\n            let dyC = (f32(dyCCorner) + f32(wC)) / f32(uniforms.stride.y);\n            let wCPerm = uniforms.filterDims.y - 1 - wC;\n            if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||\n                fract(dyC) > 0.0 || wCPerm < 0) {\n              continue;\n            }\n            let idyC = i32(dyC);\n\n            for (var d2 = 0; d2 < uniforms.outBackprop[3]; d2 = d2 + 1) {\n              if ("+this.isChannelsLast+") {\n                let xValue = getDy(batch, idyR, idyC, d2);\n                let wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd = dotProd + xValue * wValue;\n              } else {\n                let xValue = getDy(batch, d2, idyR, idyC);\n                let wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd = dotProd + xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n  "},e}();var Sn,Cn={kernelName:t.Conv2DBackpropInput,backendName:"webgpu",kernelFunc:function(e){var n,r=e.inputs,i=e.backend,a=e.attrs,o=r.dy,s=r.filter,u=a.inputShape,l=a.strides,d=a.pad,h=a.dataFormat,p=a.dimRoundingMode,c=t.backend_util.convertConv2DDataFormat(h),f=t.backend_util.computeConv2DInfo(u,s.shape,l,1,d,p,!1,c),m=[{type:"int32",data:[f.filterHeight,f.filterWidth]},{type:"int32",data:[f.filterHeight-1-f.padInfo.top,f.filterWidth-1-f.padInfo.left]},{type:"int32",data:[f.strideHeight,f.strideWidth]},{type:"int32",data:[f.batchSize,f.outHeight,f.outWidth,f.outChannels]}];if(t.env().getBool("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE")||f.filterHeight<=2&&f.filterWidth<=2&&f.outChannels<=16&&1===f.inChannels)n=new In(f);else{n=new kn(f);var v=f.inHeight*f.inWidth,g=f.inChannels,b=f.filterHeight*f.filterWidth*f.outChannels;m.push({type:"uint32",data:[v]},{type:"uint32",data:[g]},{type:"uint32",data:[b]})}return i.runWebGPUProgram(n,[o,s],"float32",m)}},Rn=ye({opType:W.COS}),An={kernelName:t.Cos,backendName:"webgpu",kernelFunc:Rn},Tn=ye({opType:W.COSH}),zn={kernelName:t.Cosh,backendName:"webgpu",kernelFunc:Tn},Pn=function(){function e(e,t,n,r){this.variableNames=["Image","Boxes","BoxInd"],this.uniforms="extrapolationValue : f32,",this.workGroupSize=[64,1,1],this.size=!0;var i=u(t,1)[0];this.outputShape=[i,n[0],n[1],e],this.dispatchLayout=B(this.outputShape),this.dispatch=z(this.dispatchLayout,this.outputShape,this.workGroupSize),this.methodId="bilinear"===r?1:0,this.cropHeightBiggerThan1=this.outputShape[1]>1,this.cropWidthBiggerThan1=this.outputShape[2]>1,this.shaderKey="cropAndResize_"+this.methodId+"_"+this.cropHeightBiggerThan1+"_"+this.cropWidthBiggerThan1}return e.prototype.getUserCode=function(){var e=u(["f32(uniforms.imageShape[1] - 1)","f32(uniforms.imageShape[2] - 1)"],2),t=e[0],n=e[1],r=u(this.cropHeightBiggerThan1?["("+t+" / f32(uniforms.outShape[1] - 1))","(y2-y1) * height_ratio","y1*"+t+" + f32(y)*(height_scale)"]:["0.0","0.0","0.5 * (y1+y2) * "+t],3),i=r[0],a=r[1],o=r[2],s=u(this.cropWidthBiggerThan1?["("+n+" / f32(uniforms.outShape[2] - 1))","(x2-x1) * width_ratio","x1*"+n+" + f32(x)*(width_scale)"]:["0.0","0.0","0.5 * (x1+x2) * "+n],3),l=s[0],d=s[1],h=s[2];return"\n    "+w("index")+" {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let height_ratio = f32("+i+");\n        let width_ratio = f32("+l+");\n        let b = coords[0];\n        let y = coords[1];\n        let x = coords[2];\n        let d = coords[3];\n        // get box vals\n        let y1 = getBoxes(b, 0);\n        let x1 = getBoxes(b, 1);\n        let y2 = getBoxes(b, 2);\n        let x2 = getBoxes(b, 3);\n        // get image in batch index\n        let bInd = i32(round(getBoxInd(b)));\n        if(bInd < 0 || bInd >= uniforms.outShape[0]) {\n          return;\n        }\n        let height_scale = "+a+";\n        let width_scale = "+d+";\n        let in_y = "+o+";\n        if( in_y < 0.0 || in_y > "+t+" ) {\n          setOutputAtIndex(index, uniforms.extrapolationValue);\n          return;\n        }\n        let in_x = "+h+";\n        if( in_x < 0.0 || in_x > "+n+" ) {\n          setOutputAtIndex(index, uniforms.extrapolationValue);\n          return;\n        }\n        let sourceFracIndexCR = vec2<f32>(in_x,in_y);\n        if("+this.methodId+" == 1) {\n          // Compute the four integer indices.\n          let sourceFloorCR = vec2<i32>(sourceFracIndexCR);\n          let sourceCeilCR = vec2<i32>(ceil(sourceFracIndexCR));\n          let topLeft = getImage(bInd, sourceFloorCR.y, sourceFloorCR.x, d);\n          let bottomLeft = getImage(bInd, sourceCeilCR.y, sourceFloorCR.x, d);\n          let topRight = getImage(bInd, sourceFloorCR.y, sourceCeilCR.x, d);\n          let bottomRight = getImage(bInd, sourceCeilCR.y, sourceCeilCR.x, d);\n          let fracCR = sourceFracIndexCR - vec2<f32>(sourceFloorCR);\n          let top = topLeft + (topRight - topLeft) * fracCR.x;\n          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          let newValue = top + (bottom - top) * fracCR.y;\n          setOutputAtIndex(index, newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          let sourceNearestCR = vec2<i32>(floor(\n            sourceFracIndexCR + vec2<f32>(0.5,0.5)));\n          let newValue = getImage(\n            bInd, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutputAtIndex(index, newValue);\n        }\n      }\n    }\n    "},e}(),_n={kernelName:t.CropAndResize,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.image,a=t.boxes,o=t.boxInd,s=r.cropSize,u=r.method,l=r.extrapolationValue,d=new Pn(i.shape[3],a.shape,s,u),h=[{type:"float32",data:[l]}];return n.runWebGPUProgram(d,[i,a,o],"float32",h)}};!function(e){e.Prod="*",e.Sum="+"}(Sn||(Sn={}));var Nn=function(){function e(e,t,n,r){this.variableNames=["x"],this.uniforms="index : f32,",this.size=!0;this.workGroupSize=[128,1,1],this.outputShape=t,this.dispatchLayout=B(this.outputShape),this.dispatch=z(this.dispatchLayout,this.outputShape,this.workGroupSize),this.exclusive=n,this.reverse=r,this.op=e,this.shaderKey="cum_"+this.op+"_"+this.exclusive+"_"+this.reverse}return e.prototype.getUserCode=function(){var e=this.outputShape.length,t=this.op===Sn.Prod?"1.0":"0.0",n=this.exclusive?t:"getX("+Bn(e,"coords",this.op)+")",r=this.outputShape[this.outputShape.length-1],i="",a="";return this.exclusive?(i=this.reverse?"end != "+(r-1):"end != 0",a=this.reverse?"end + 1":"end - 1"):(i=this.reverse?"end + pow2 < "+r:"end >= pow2",a=this.reverse?"end + pow2":"end - pow2"),"\n      "+w("index")+" {\n       if (index < uniforms.size) {\n         var coords = getCoordsFromIndex(index);\n\n         let end = "+En(e,"coords",this.op)+";\n         var val = "+n+";\n         let pow2 = i32(pow(2.0, uniforms.index));\n         if ("+i+") {\n           let idx = "+a+";\n           "+En(e,"coords",this.op)+" = idx;\n           val "+this.op+"= getX("+Bn(e,"coords",this.op)+");\n         }\n         setOutputAtIndex(index, val);\n       }\n      }\n    "},e}();function Bn(e,t,n){if(1===e)return""+t;if(2===e)return t+".x, "+t+".y";if(3===e)return t+".x, "+t+".y, "+t+".z";if(4===e)return t+".x, "+t+".y, "+t+".z, "+t+".w";throw Error("Cumulative "+n+" for rank "+e+" is not yet supported")}function En(e,t,n){if(1===e)return""+t;if(2===e)return t+".y";if(3===e)return t+".z";if(4===e)return t+".w";throw Error("Cumulative "+n+" for rank "+e+" is not yet supported")}function Fn(e,n,r,i,a,o){var s=n.shape.length,u=t.backend_util.getAxesPermutation([i],s),l=n;null!=u&&(l=Nt({inputs:{x:n},backend:r,attrs:{perm:u}}));var d=t.backend_util.getInnerMostAxes(1,s)[0];if(d!==s-1)throw new Error("WebGPU cumprod shader expects an inner-most axis="+(n.shape.length-1)+" but got axis="+i);for(var h=l.shape[d],p=me({inputs:{x:l},backend:r}),c=0;c<=Math.ceil(Math.log2(h))-1;c++){var f=new Nn(e,l.shape,!1,o),m=p,v=[{type:"float32",data:[c]}];p=r.runWebGPUProgram(f,[p],p.dtype,v),r.disposeData(m.dataId)}if(a){f=new Nn(e,l.shape,a,o),m=p,v=[{type:"float32",data:[0]}];p=r.runWebGPUProgram(f,[p],p.dtype,v),r.disposeData(m.dataId)}if(null!=u){var g=Nt({inputs:{x:p},backend:r,attrs:{perm:t.backend_util.getUndoAxesPermutation(u)}});return r.disposeData(p.dataId),r.disposeData(l.dataId),g}return p}var Gn={kernelName:t.Cumprod,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,a=r.axis,o=r.exclusive,s=r.reverse;return Fn(Sn.Prod,i,n,a,o,s)}};var Ln={kernelName:t.Cumsum,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,a=r.axis,o=r.exclusive,s=r.reverse;return Fn(Sn.Sum,i,n,a,o,s)}},On=function(){function e(e,t){this.variableNames=["x"],this.workGroupSize=[64,1,1],this.size=!0,this.uniforms="blockSize : i32,",this.outputShape=e,this.dispatchLayout=B(this.outputShape),this.dispatch=z(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="depthToSpace_"+t,this.dataFormat=t}return e.prototype.getUserCode=function(){return"\n      "+w("index")+" {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let b = coords[0];\n          let h = "+this.getHeightCoordString()+";\n          let w = "+this.getWidthCoordString()+";\n          let d = "+this.getDepthCoordString()+";\n\n          let in_h = h / uniforms.blockSize;\n          let offset_h = h % uniforms.blockSize;\n          let in_w = w / uniforms.blockSize;\n          let offset_w = w % uniforms.blockSize;\n          let offset_d = (offset_h * uniforms.blockSize + offset_w) *\n            "+this.getOutputDepthSize()+";\n          let in_d = d + offset_d;\n\n          let rlt = "+this.getInputSamplingString()+";\n          setOutputAtIndex(index, rlt);\n        }\n      }"},e.prototype.getHeightCoordString=function(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"},e.prototype.getWidthCoordString=function(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"},e.prototype.getDepthCoordString=function(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"},e.prototype.getOutputDepthSize=function(){return"NHWC"===this.dataFormat?"uniforms.outShape[3]":"uniforms.outShape[1]"},e.prototype.getInputSamplingString=function(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"},e}();var Un={kernelName:t.DepthToSpace,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,a=r.blockSize,o=r.dataFormat,s=i.shape[0],u=("NHWC"===o?i.shape[1]:i.shape[2])*a,l=("NHWC"===o?i.shape[2]:i.shape[3])*a,d=("NHWC"===o?i.shape[3]:i.shape[1])/(a*a),h=[{type:"int32",data:[a]}],p=new On("NHWC"===o?[s,u,l,d]:[s,d,u,l],o);return n.runWebGPUProgram(p,[i],i.dtype,h)}},Dn=function(){function e(e,t,n,r,i,a){void 0===r&&(r=!1),void 0===i&&(i=null),void 0===a&&(a=!1),this.variableNames=["x","W"],this.uniforms="pad : vec2<i32>, inDims : vec2<i32>,",this.workGroupSize=[16,16,1],this.outputShape=e,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=z(this.dispatchLayout,this.outputShape,this.workGroupSize),r&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),this.addBias=r,this.activation=i,this.hasPreluActivation=a,this.filterHeight=t,this.filterWidth=n,this.shaderKey="depthwiseNCHW_"+this.activation+"_"+this.filterHeight+"_"+this.filterWidth}return e.prototype.getUserCode=function(){var e=this.filterWidth*this.filterHeight,t=this.workGroupSize[0]*this.workGroupSize[1]*this.workGroupSize[2],n=this.workGroupSize[1]+this.filterHeight-1,r=this.workGroupSize[0]+this.filterWidth-1;return"\n      "+j(this.activation,this.hasPreluActivation,!1,4)+"\n\n      var<workgroup> mm_Asub : array<array<f32, "+r+">, "+n+">;\n      var<workgroup> mm_Bsub : array<array<f32, "+this.filterWidth+">, "+this.filterHeight+">;\n      fn readX(batch : i32, channel : i32, row : i32, col : i32) -> f32 {\n        var value = 0.0;\n        if (row >=0 && row < uniforms.inDims[0] && col >=0 && col < uniforms.inDims[1])\n        {\n          value = getX(batch, channel, row, col);\n        }\n        return value;\n      }\n\n      \n  @compute @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n\n      fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,\n                @builtin(global_invocation_id) GlobalId : vec3<u32>,\n                @builtin(local_invocation_index) LocalIndex: u32,\n                @builtin(num_workgroups) NumWorkgroups: vec3<u32>) {\n        localId = LocalId;\n        globalId = GlobalId;\n        let localIndex = i32(LocalIndex);\n        numWorkgroups = NumWorkgroups;\n        let coords = getOutputCoords();\n        let batch = coords[0];\n        let xRCCorner = vec2<i32>(coords.zw) - uniforms.pad;\n        let channelMul = uniforms.wShape[3];\n        let d1 = coords[1] / channelMul;\n        let q = coords[1] % channelMul;\n\n        let inputRowStart = xRCCorner.x;\n        let inputColStart = xRCCorner.y;\n\n        let localRow = i32(localId.y);\n        let localCol = i32(localId.x);\n\n        // Load one tile of X into local memory.\n        for (var inputRow = localRow; inputRow < "+n+"; inputRow = inputRow + "+this.workGroupSize[1]+") {\n          for (var inputCol = localCol; inputCol < "+r+"; inputCol = inputCol + "+this.workGroupSize[0]+") {\n            let rowOffset = inputRow - localRow;\n            let colOffset = inputCol - localCol;\n            mm_Asub[inputRow][inputCol] = readX(batch, d1, inputRowStart + rowOffset, inputColStart + colOffset);\n          }\n        }\n\n        // Load one tile of W into local memory.\n        var wIndex = localIndex;\n        "+(e<t?"if (wIndex < "+e+")":"for(; wIndex < "+e+"; wIndex = wIndex + "+t+")")+"\n\n        {\n          let wRow = wIndex / "+this.filterWidth+";\n          let wCol = wIndex % "+this.filterWidth+";\n          mm_Bsub[wRow][wCol] = getW(wRow, wCol, d1, q);\n        }\n\n        workgroupBarrier();\n\n        var value = 0.0;\n        for (var wR = 0; wR < "+this.filterHeight+"; wR = wR + 1) {\n          for (var wC = 0; wC < "+this.filterWidth+"; wC = wC + 1) {\n            let xVal = mm_Asub[localRow + wR][localCol + wC];\n            let wVal = mm_Bsub[wR][wC];\n            value = fma(xVal, wVal, value);\n          }\n        }\n        "+Y(this.addBias,this.activation)+"\n        if (coordsInBounds4D(coords, uniforms.outShape)) {\n          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n        }\n      }\n    "},e}(),Wn=function(){function e(e,n,r,i){void 0===n&&(n=!1),void 0===r&&(r=null),void 0===i&&(i=!1),this.variableNames=["x","W"],this.uniforms="pad : vec2<i32>, inDims : vec2<i32>,",this.workGroupSize=[4,4,4],this.workPerThread=4,this.isVec4=!0,this.outputShape=e.outShape,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=z(this.dispatchLayout,this.outputShape,this.workGroupSize,[4,this.workPerThread,1]),t.util.assert("channelsLast"===e.dataFormat,(function(){return"TODO: NCHW is unimplemented"})),n&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=n,this.activation=r,this.hasPreluActivation=i,this.shaderKey="depthwiseVec4_"+r+"_"+this.convInfo.filterHeight+"_"+this.convInfo.filterWidth+"_"+this.convInfo.strideHeight+"_"+this.convInfo.strideWidth+"_"+this.workPerThread}return e.prototype.getUserCode=function(){var e=(this.workPerThread-1)*this.convInfo.strideWidth+this.convInfo.filterWidth;return"\n      "+j(this.activation,this.hasPreluActivation,!0,4)+"\n      fn readX(batch : i32, row : i32, col : i32, channel : i32) -> vec4<f32> {\n        var value = vec4<f32>(0.0);\n        if (col >=0 && col < uniforms.inDims[1]) {\n          value = getX(batch, row, col, channel);\n        }\n        return value;\n      }\n\n      const strideHeight = "+this.convInfo.strideHeight+";\n      const strideWidth = "+this.convInfo.strideWidth+";\n      \n  @compute @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n\n      fn _start(@builtin(global_invocation_id) globalId: vec3<u32>) {\n        let batch = i32(globalId.z) / uniforms.outShape[1];\n        let r = i32(globalId.z) % uniforms.outShape[1];\n        let c = i32(globalId.y) * "+this.workPerThread+";\n        let d1 = i32(globalId.x) * 4;\n        let xRCCorner = vec2<i32>(r, c) * vec2<i32>(strideHeight, strideWidth) - uniforms.pad;\n\n        let xRCorner = xRCCorner.x;\n        let xCCorner = xRCCorner.y;\n        var xVals : array<vec4<f32>, "+e+">;\n        var dotProd : array<vec4<f32>, "+this.workPerThread+">;\n        for (var i = 0; i < "+this.workPerThread+"; i++) {\n          dotProd[i] = vec4<f32>(0.0);\n        }\n\n        // Use constant instead of uniform can give better performance.\n        for (var wR = 0; wR < "+this.convInfo.filterHeight+"; wR = wR + 1) {\n          let xR = xRCorner + wR;\n          if (xR >=0 && xR < uniforms.inDims[0]) {\n            for (var i = 0; i < "+e+"; i++) {\n              xVals[i] = readX(batch, xR, xCCorner + i, d1);\n            }\n            for (var wC = 0; wC < "+this.convInfo.filterWidth+"; wC = wC + 1) {\n              let wValue = getW(wR, wC, d1, 0);\n              for (var i = 0; i < "+this.workPerThread+"; i++) {\n                dotProd[i] = fma(xVals[i * strideWidth + wC], wValue, dotProd[i]);\n              }\n            }\n          }\n        }\n\n        for (var i = 0; i < "+this.workPerThread+"; i = i + 1) {\n          let coords = vec4<i32>(batch, r, c + i, d1);\n          if (coordsInBounds4D(coords, uniforms.outShape)) {\n            var value = dotProd[i];\n            "+Y(this.addBias,this.activation)+"\n            setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n          }\n        }\n      }\n    "},e}(),Mn=function(){function e(e,t,n,r){void 0===t&&(t=!1),void 0===n&&(n=null),void 0===r&&(r=!1),this.variableNames=["x","W"],this.uniforms="pad : vec2<i32>, inDims : vec2<i32>, filterHeight : i32,\n      filterWidth : i32, stride : vec2<i32>, dilation : vec2<i32>,",this.workGroupSize=[256,1,1],this.outputShape=e.outShape,this.dispatchLayout=B(this.outputShape),this.dispatch=z(this.dispatchLayout,this.outputShape,this.workGroupSize),this.isChannelsLast="channelsLast"===e.dataFormat,t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=n,this.hasPreluActivation=r,this.shaderKey="depthwise_"+this.activation+"_"+this.isChannelsLast}return e.prototype.getUserCode=function(){var e=this.isChannelsLast?"getX(batch, xR, xC, d1);":"getX(batch, d1, xR, xC);";return"\n      "+j(this.activation,this.hasPreluActivation,!1,4)+"\n\n      "+w()+" {\n        let coords = getOutputCoords();\n        let batch = coords[0];\n        let xRCCorner = vec2<i32>(coords."+(this.isChannelsLast?"yz":"zw")+") * uniforms.stride - uniforms.pad;\n        let d2 = coords["+(this.isChannelsLast?3:1)+"];\n        let channelMul = uniforms.wShape[3];\n        let d1 = d2 / channelMul;\n        let q = d2 % channelMul;\n\n        let inputRowStart = xRCCorner.x;\n        let inputColStart = xRCCorner.y;\n        let inputRowEnd = inputRowStart + uniforms.filterHeight *\n            uniforms.dilation[0];\n        let inputColEnd = inputColStart + uniforms.filterWidth *\n            uniforms.dilation[1];\n\n        // Convolve x(?, ?, d1)|x(d1, ?, ?) with w(:, :, d1, q) to get\n        // y(yR, yC, d2)|y(d2, yR, yC). ? = to be determined. : = across all\n        // values in that axis. x(?, ?, d1) and y(yR, yC, d2) is for NHWC.\n        // x(d1, ?, ?) and y(d2, yR, yC) is for NCHW.\n        var value = 0.0;\n\n        // Extract if checking out of for loop for performance.\n        if (inputRowStart >= 0 && inputColStart >= 0 &&\n          inputRowEnd < uniforms.inDims[0] &&\n              inputColEnd < uniforms.inDims[1]) {\n            for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {\n              let xR = inputRowStart + wR * uniforms.dilation[0];\n\n              for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {\n                let xC = inputColStart + wC * uniforms.dilation[1];\n\n                let xVal = "+e+";\n                let wVal = getW(wR, wC, d1, q);\n                value = value + xVal * wVal;\n              }\n            }\n          } else {\n            for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {\n              let xR = inputRowStart + wR * uniforms.dilation[0];\n\n              if (xR < 0 || xR >= uniforms.inDims[0]) {\n                continue;\n              }\n\n              for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {\n                let xC = inputColStart + wC * uniforms.dilation[1];\n\n                if (xC < 0 || xC >= uniforms.inDims[1]) {\n                  continue;\n                }\n\n                let xVal = "+e+";\n                let wVal = getW(wR, wC, d1, q);\n                value = value + xVal * wVal;\n              }\n            }\n          }\n          "+Y(this.addBias,this.activation)+"\n        if (coordsInBounds4D(coords, uniforms.outShape)) {\n          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n        }\n      }\n    "},e}();var Vn={kernelName:t.DepthwiseConv2dNative,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,r=e.backend,i=e.attrs,a=n.x,o=n.filter,s=i.strides,u=i.pad,l=i.dataFormat,d=i.dilations,h=i.dimRoundingMode,p=t.backend_util.convertConv2DDataFormat(l),c=d;null==c&&(c=[1,1]);var f,m=t.backend_util.computeConv2DInfo(a.shape,o.shape,s,c,u,h,!0,p),v=[{type:"int32",data:[m.padInfo.top,m.padInfo.left]},{type:"int32",data:[m.inHeight,m.inWidth]}],g="channelsLast"===m.dataFormat;return!g&&m.inHeight>16&&m.inWidth>16&&1===m.strideHeight&&1===m.strideWidth&&1===m.dilationWidth&&1===m.dilationHeight&&m.inChannels===m.outChannels?f=new Dn(m.outShape,m.filterHeight,m.filterWidth):g&&m.inHeight>4&&m.inWidth>4&&m.strideWidth<=2&&m.inChannels===m.outChannels&&1===m.dilationHeight&&1===m.dilationWidth&&m.inChannels%4==0?f=new Wn(m):(f=new Mn(m),v.push({type:"int32",data:[m.filterHeight]},{type:"int32",data:[m.filterWidth]},{type:"int32",data:[m.strideHeight,m.strideWidth]},{type:"int32",data:[m.dilationHeight,m.dilationWidth]})),r.runWebGPUProgram(f,[a,o],a.dtype,v)}},Hn=we({opType:D.MUL,cpuKernelImpl:ut,supportsComplex:!0}),Xn={kernelName:t.Multiply,backendName:"webgpu",kernelFunc:Hn};function qn(e){var t=e.inputs,n=e.backend,r=e.attrs;return Wt(t.x,r.axis,r.keepDims,"sum",n)}var Kn={kernelName:t.Sum,backendName:"webgpu",kernelFunc:qn};var jn={kernelName:t.Einsum,backendName:"webgpu",kernelFunc:function(e){var n,r,i,a,o=e.inputs,u=e.backend,l=e.attrs.equation,d=o,h=t.backend_util.decodeEinsumEquation(l,d.length),p=h.allDims,c=h.summedDims,f=h.idDims;t.backend_util.checkEinsumDimSizes(p.length,f,d);for(var m=t.backend_util.getEinsumComputePath(c,f),v=m.path,g=m.steps,b=g.length,x=null,y=p.length,w=[],k=0;k<b;++k){try{for(var I=(n=void 0,s(g[k])),S=I.next();!S.done;S=I.next()){var C=S.value,R=t.backend_util.getEinsumPermutation(y,f[C]),A=R.permutationIndices,T=R.expandDims,z=void 0;t.backend_util.isIdentityPermutation(A)?z=d[C]:(z=Nt({inputs:{x:d[C]},backend:u,attrs:{perm:A}}),w.push(z));for(var P=z.shape.slice(),_=0;_<T.length;++_)P.splice(T[_],0,1);t.util.arraysEqual(z.shape,P)||(z=le({inputs:{x:z},backend:u,attrs:{shape:P}}),w.push(z)),null===x?x=z:(x=Hn({inputs:{a:z,b:x},backend:u}),w.push(x))}}catch(e){n={error:e}}finally{try{S&&!S.done&&(r=I.return)&&r.call(I)}finally{if(n)throw n.error}}k<b-1&&(v[k]>=0&&(x=qn({inputs:{x:x},backend:u,attrs:{axis:v[k]-(p.length-y),keepDims:!1}}),w.push(x)),y--)}try{for(var N=s(w),B=N.next();!B.done;B=N.next()){var E=B.value;E!==x&&u.disposeData(E.dataId)}}catch(e){i={error:e}}finally{try{B&&!B.done&&(a=N.return)&&a.call(N)}finally{if(i)throw i.error}}return x}},Yn=ye({opType:W.ELU}),Qn={kernelName:t.Elu,backendName:"webgpu",kernelFunc:Yn},Zn=we({opType:D.EQUAL,dtype:"bool",cpuKernelImpl:je}),Jn={kernelName:t.Equal,backendName:"webgpu",kernelFunc:Zn},$n=ye({opType:W.EXP,cpuKernelImpl:Ye,dtype:"float32"}),er={kernelName:t.Exp,backendName:"webgpu",kernelFunc:$n};function tr(e){var n=e.inputs,r=e.attrs,i=e.backend,a=r.dim,o=n.input,s=o.shape.length,u=o.shape.slice(),l=a;return a<0&&(t.util.assert(-(s+1)<=a,(function(){return"Axis must be in the interval ["+-(s+1)+", "+s+"]"})),l=s+a+1),u.splice(l,0,1),le({inputs:{x:o},backend:i,attrs:{shape:u}})}var nr,rr={kernelName:t.ExpandDims,backendName:"webgpu",kernelFunc:tr},ir=ye({opType:W.EXPM1,cpuKernelImpl:Qe}),ar={kernelName:t.Expm1,backendName:"webgpu",kernelFunc:ir},or=function(){function e(e){this.outputShape=[],this.variableNames=["x"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=B(this.outputShape),this.dispatch=z(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="flipLeftRight"}return e.prototype.getUserCode=function(){return"\n      "+w("index")+" {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let coordX = uniforms.xShape[2] - coords[2] - 1;\n          let outputValue = getX(coords[0], coords[1], coordX, coords[3]);\n          setOutputAtIndex(index, outputValue);\n        }\n      }\n    "},e}(),sr={kernelName:t.FlipLeftRight,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=t.image,i=n,a=new or(r.shape);return i.runWebGPUProgram(a,[r],r.dtype)}},ur=ye({opType:W.FLOOR,cpuKernelImpl:Ze}),lr={kernelName:t.Floor,backendName:"webgpu",kernelFunc:ur},dr=we({opType:D.INT_DIV,dtype:"int32"}),hr={kernelName:t.FloorDiv,backendName:"webgpu",kernelFunc:dr},pr=function(){function e(e,t,n){void 0===n&&(n=!1),this.isFromPixels=!0,this.outputShape=[0],this.variableNames=[],this.workGroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout=B(this.outputShape),this.dispatch=z(this.dispatchLayout,this.outputShape,this.workGroupSize,[t,1,1]),this.importVideo=n,this.shaderKey="fromPixels_"+this.importVideo}return e.prototype.getUserCode=function(){var e=this.importVideo?"textureLoad(src, vec2<i32>(coords.yx));":"textureLoad(src, vec2<i32>(coords.yx), 0)";return"\n      @binding(1) @group(0) var src: "+(this.importVideo?"texture_external":"texture_2d<f32>")+";\n      "+w("index")+" {\n        let flatIndex = index * uniforms.numChannels;\n        if (flatIndex < uniforms.size) {\n          let coords = getCoordsFromIndex(flatIndex);\n          let values = "+e+";\n          for (var i = 0; i < uniforms.numChannels; i = i + 1) {\n            result[flatIndex + i] = i32(floor(255.0 * values[i]));\n          }\n        }\n      }\n  "},e}(),cr={kernelName:t.FromPixels,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,r=e.backend,i=e.attrs,a=n.pixels,o=i.numChannels;if(null==a)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");var s="undefined"!=typeof HTMLVideoElement&&a instanceof HTMLVideoElement,d="undefined"!=typeof HTMLImageElement&&a instanceof HTMLImageElement,h="undefined"!=typeof HTMLCanvasElement&&a instanceof HTMLCanvasElement||"undefined"!=typeof OffscreenCanvas&&a instanceof OffscreenCanvas,p="undefined"!=typeof ImageBitmap&&a instanceof ImageBitmap,c=u(s?[a.videoWidth,a.videoHeight]:[a.width,a.height],2),f=c[0],m=c[1],v=[m,f,o],g=s||d;if(p||h||g){var b;if(g){var x=t.env().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");null!=nr&&x===fr||(fr=x,nr=document.createElement("canvas").getContext("2d",{willReadFrequently:fr})),nr.canvas.width=f,nr.canvas.height=m,nr.drawImage(a,0,0,f,m),a=nr.canvas}var y=GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,w="rgba8unorm",k=r.textureManager.acquireTexture(v[1],v[0],w,y);r.queue.copyExternalImageToTexture({source:a},{texture:k},[v[1],v[0]]),b={width:f,height:m,format:w,usage:y,texture:k};var I=t.util.sizeFromShape(v),S=t.util.computeStrides(v),C=new pr(v,o,!1),R=[{type:"uint32",data:[I]},{type:"uint32",data:[o]},{type:"uint32",data:l(S)}],A=r.makeTensorInfo([m,f],"int32");r.tensorMap.get(A.dataId).resourceInfo=b;var T=r.runWebGPUProgram(C,[A],"int32",R);return r.disposeData(A.dataId),T}var z=a.data,P=z;if(null!=o&&4!==o){P=new Uint8Array(a.width*a.height*o);for(var _=z.length,N=0,B=0;B<_;B++)B%4<o&&(P[N++]=z[B])}var E=r.makeTensorInfo(v,"int32",new Int32Array(P));return r.uploadToGPU(E.dataId),E}},fr=t.env().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");var mr=function(){function e(e,n,r,i,a){this.uniforms="varianceEpsilon : f32,",this.workGroupSize=[128,1,1],this.size=!0,this.variableNames=["x","mean","variance"],t.backend_util.assertAndGetBroadcastShape(e,n),t.backend_util.assertAndGetBroadcastShape(e,r),this.outputShape=e,this.dispatchLayout=B(this.outputShape),this.dispatch=z(this.dispatchLayout,this.outputShape,this.workGroupSize),null!=i&&(t.backend_util.assertAndGetBroadcastShape(e,i),this.variableNames.push("offset")),null!=a&&(t.backend_util.assertAndGetBroadcastShape(e,a),this.variableNames.push("scale")),this.offsetShape=i,this.scaleShape=a,this.shaderKey="batchNorm"}return e.prototype.getUserCode=function(){var e="0.0";null!=this.offsetShape&&(e="getOffsetByOutputIndex(index)");var t="1.0";return null!=this.scaleShape&&(t="getScaleByOutputIndex(index)"),"\n      "+w("index")+" {\n        if (index < uniforms.size)\n        {\n          let xValue = getXByOutputIndex(index);\n          let meanValue = getMeanByOutputIndex(index);\n          let varianValue = getVarianceByOutputIndex(index);\n          let offsetValue = "+e+";\n          let scaleValue = "+t+";\n          let inv = scaleValue * inverseSqrt(varianValue + f32(uniforms.varianceEpsilon));\n          setOutputAtIndex(index,dot(vec3<f32>(xValue, -meanValue, offsetValue), vec3<f32>(inv, inv, 1.0)));\n        }\n      }\n  "},e}(),vr={kernelName:t.FusedBatchNorm,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.attrs,r=e.backend,i=t.x,a=t.scale,o=t.offset,s=t.mean,u=t.variance,l=n.varianceEpsilon,d=r,h=[i,s,u],p=null;null!=o&&(p=o.shape,h.push(o));var c=null;null!=a&&(c=a.shape,h.push(a));var f=new mr(i.shape,s.shape,u.shape,p,c),m=[{type:"float32",data:[l]}];return d.runWebGPUProgram(f,h,i.dtype,m)}};var gr={kernelName:t.FusedConv2D,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,r=e.backend,i=e.attrs,a=n.x,o=n.filter,s=n.bias,u=n.preluActivationWeights,l=i.strides,d=i.pad,h=i.dataFormat,p=i.dilations,c=i.dimRoundingMode,f=i.activation,m=i.leakyreluAlpha,v=t.backend_util.convertConv2DDataFormat(h);return yn({x:a,filter:o,convInfo:t.backend_util.computeConv2DInfo(a.shape,o.shape,l,p,d,c,!1,v),backend:r,bias:s,preluActivationWeights:u,leakyreluAlpha:m,activation:f})}};var br={kernelName:t.FusedDepthwiseConv2D,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,r=e.backend,i=e.attrs,a=n.x,o=n.filter,s=n.bias,u=n.preluActivationWeights,l=i.strides,d=i.pad,h=i.dilations,p=i.dimRoundingMode,c=i.activation,f=i.leakyreluAlpha,m=h;null==m&&(m=[1,1]),t.util.assert(t.backend_util.eitherStridesOrDilationsAreOne(l,m),(function(){return"Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides "+l+" and dilations '"+m+"'"}));var v=t.backend_util.computeConv2DInfo(a.shape,o.shape,l,m,d,p,!0),g=[a,o],b=null!=s,x=null!=u;b&&g.push(s),x&&g.push(u);var y,w=[{type:"int32",data:[v.padInfo.top,v.padInfo.left]},{type:"int32",data:[v.inHeight,v.inWidth]}];return v.inHeight>4&&v.inWidth>4&&v.strideWidth<=2&&v.inChannels===v.outChannels&&1===v.dilationHeight&&1===v.dilationWidth&&v.inChannels%4==0?y=new Wn(v,b,c,x):(y=new Mn(v,b,c,x),w.push({type:"int32",data:[v.filterHeight]},{type:"int32",data:[v.filterWidth]},{type:"int32",data:[v.strideHeight,v.strideWidth]},{type:"int32",data:[v.dilationHeight,v.dilationWidth]})),"leakyrelu"===c&&(w.push({type:"float32",data:[f]}),y.uniforms+=" alpha : f32,"),r.runWebGPUProgram(y,g,"float32",w)}},xr=function(){function e(e,t){this.variableNames=["A","indices"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=B(this.outputShape),this.dispatch=z(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="gathernd_"+e,this.sliceDim=e,this.uniforms="sliceDim : i32, strides : "+x(e)+","}return e.prototype.getUserCode=function(){var e;return e=this.sliceDim>1?"uniforms.strides[j]":"uniforms.strides","\n      "+w("index")+" {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          var flattenIndex = 0;\n          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {\n            let indexTemp = i32(round(getIndices(coords[0], j)));\n            let strideNum = "+e+";\n            flattenIndex = flattenIndex + indexTemp * strideNum;\n          }\n\n          setOutputAtIndex(index, getA(flattenIndex, coords[1]));\n        }\n      }\n      "},e}();var yr={kernelName:t.GatherNd,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,r=e.backend,i=n.params,a=n.indices,o=a.shape,s=o[o.length-1],l=t.util.sizeFromShape(i.shape),d=u(t.backend_util.prepareAndValidate(i,a),4),h=d[0],p=d[1],c=d[2],f=d[3],m=le({inputs:{x:a},backend:r,attrs:{shape:[p,s]}}),v=le({inputs:{x:i},backend:r,attrs:{shape:[t.util.sizeFromShape(i.shape)/c,c]}});if(r.shouldExecuteOnCPU([i,a])||"string"===i.dtype){var g=r.readSync(a.dataId),b=r.bufferSync(i),x=Je(g,b,i.dtype,p,s,c,f,i.shape,l);return r.makeTensorInfo(h,i.dtype,x.values)}var y=new xr(s,[p,c]),w=[{type:"int32",data:[s]},{type:"int32",data:f}],k=r.runWebGPUProgram(y,[v,m],v.dtype,w),I=le({inputs:{x:k},backend:r,attrs:{shape:h}});return r.disposeData(m.dataId),r.disposeData(v.dataId),r.disposeData(k.dataId),I}},wr=function(){function e(e,t){this.variableNames=["A","indices"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e.slice(),this.aShape=e,this.outputShape=t,this.dispatchLayout=B(this.outputShape),this.dispatch=z(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="gather"}return e.prototype.getUserCode=function(){var e=function(e){for(var t=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[],r=0;r<e.length;r++)2===r?n.push("indexZ"):n.push(""+t[r]);return n.join()}(this.aShape);return"\n      "+w("index")+" {\n        if (index < uniforms.size) {\n          let resRC = getCoordsFromIndex(index);\n          let indexZ = i32(getIndices(resRC.x, resRC.z));\n          let inBounds = select(0.0, 1.0, indexZ >= 0 && indexZ < uniforms.aShape[2]);\n          setOutputAtIndex(index, inBounds * getA("+e+"));\n        }\n      }\n    "},e}();function kr(e){var n=e.inputs,r=e.backend,i=e.attrs,a=n.x,o=n.indices,s=i.axis,u=i.batchDims,l=t.util.parseAxisParam(s,a.shape)[0],d=t.backend_util.segment_util.collectGatherOpShapeInfo(a,o,l,u),h=t.util.sizeFromShape(o.shape),p=[],c=le({inputs:{x:a},backend:r,attrs:{shape:[d.batchSize,d.outerSize,d.dimSize,d.sliceSize]}}),f=le({inputs:{x:o},backend:r,attrs:{shape:[d.batchSize,h/d.batchSize]}});p.push(c),p.push(f);var m=[d.batchSize,d.outerSize,h/d.batchSize,d.sliceSize];if(r.shouldExecuteOnCPU([a,o])){var v=r.tensorMap.get(f.dataId).values,g=t.buffer(f.shape,f.dtype,v),b=r.tensorMap.get(c.dataId).values,x=t.buffer(c.shape,c.dtype,b),y=$e(x,g,m);return p.forEach((function(e){return r.disposeData(e.dataId)})),r.makeTensorInfo(d.outputShape,y.dtype,y.values)}var w=new wr(c.shape,m),k=r.runWebGPUProgram(w,[c,f],c.dtype);p.push(k);var I=le({inputs:{x:k},backend:r,attrs:{shape:d.outputShape}});return p.forEach((function(e){return r.disposeData(e.dataId)})),I}var Ir={kernelName:t.GatherV2,backendName:"webgpu",kernelFunc:kr},Sr=we({opType:D.GREATER,cpuKernelImpl:tt,dtype:"bool"}),Cr={kernelName:t.Greater,backendName:"webgpu",kernelFunc:Sr},Rr=we({opType:D.GREATER_EQUAL,dtype:"bool",cpuKernelImpl:et}),Ar={kernelName:t.GreaterEqual,backendName:"webgpu",kernelFunc:Rr},Tr=ye({opType:W.IS_NAN,dtype:"bool"}),zr={kernelName:t.IsNan,backendName:"webgpu",kernelFunc:Tr};var Pr={kernelName:t.LeakyRelu,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.x,a=[{type:"float32",data:[r.alpha]}],o=new xe(i.shape,W.LEAKYRELU);return o.uniforms="alpha : f32,",n.runWebGPUProgram(o,[i],"float32",a)}},_r=we({opType:D.LESS,dtype:"bool",cpuKernelImpl:rt}),Nr={kernelName:t.Less,backendName:"webgpu",kernelFunc:_r},Br=we({opType:D.LESS_EQUAL,dtype:"bool",cpuKernelImpl:nt}),Er={kernelName:t.LessEqual,backendName:"webgpu",kernelFunc:Br},Fr=ye({opType:W.LOG,cpuKernelImpl:it}),Gr={kernelName:t.Log,backendName:"webgpu",kernelFunc:Fr},Lr=we({opType:D.LOGICAL_AND,dtype:"bool"}),Or={kernelName:t.LogicalAnd,backendName:"webgpu",kernelFunc:Lr},Ur=ye({opType:W.LOGICAL_NOT}),Dr={kernelName:t.LogicalNot,backendName:"webgpu",kernelFunc:Ur},Wr=we({opType:D.MAX,cpuKernelImpl:ot}),Mr={kernelName:t.Maximum,backendName:"webgpu",kernelFunc:Wr};var Vr={kernelName:t.MaxPool,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,r=e.backend,i=e.attrs,a=n.x,o=i.filterSize,s=i.strides,u=i.pad,l=i.dimRoundingMode;return qt(a,t.backend_util.computePool2DInfo(a.shape,o,s,1,u,l),"max",r)}};var Hr={kernelName:t.Min,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs;return Wt(t.x,r.axis,r.keepDims,"min",n)}},Xr=we({opType:D.MIN,cpuKernelImpl:st}),qr={kernelName:t.Minimum,backendName:"webgpu",kernelFunc:Xr},Kr=function(){function e(e,t,n){var r=this;this.uniforms="",this.variableNames=["x"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=t.map((function(t,n){return t[0]+e[n]+t[1]})),this.dispatchLayout=B(this.outputShape),this.dispatch=z(this.dispatchLayout,this.outputShape,this.workGroupSize),this.xShape=e,t.map((function(e,t){r.uniforms+=" pad"+t+" : vec2<i32>,"})),this.offset="reflect"===n?0:1,this.shaderKey="mirrorPad_"+n}return e.prototype.getUserCode=function(){var e=this.xShape.length,t=this.xShape.map((function(e,t){return"uniforms.pad"+t+"[0]"})).join(","),n=this.xShape.map((function(t,n){return"uniforms.pad"+n+"[0] + uniforms.xShape"+(e>1?"["+n+"]":"")})).join(","),r=1===e?"start":"start[i]",i=1===e?"end":"end[i]",a=1===e?"outC":"outC[i]",o=x(e),s=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return"\n      "+w("index")+" {\n        if (index < uniforms.size) {\n          let start = "+o+"("+t+");\n          let end = "+o+"("+n+");\n          var outC = getCoordsFromIndex(index);\n          for (var i = 0; i < "+e+"; i = i + 1) {\n            if ("+a+" < "+r+") {\n              "+a+" = "+r+" * 2 - "+a+" - "+this.offset+";\n            } else if("+a+" >= "+i+") {\n              "+a+" = ("+i+" - 1) * 2 - "+a+" + "+this.offset+";\n            }\n          }\n          let coords = outC - start;\n          setOutputAtIndex(index, getX("+s+"));\n        }\n      }\n    "},e}(),jr={kernelName:t.MirrorPad,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.attrs,r=e.backend,i=t.x,a=n.paddings,o=n.mode,s=r,u=a.map((function(e){return{type:"int32",data:[e[0],e[1]]}})),l=new Kr(i.shape,a,o);return s.runWebGPUProgram(l,[i],i.dtype,u)}};var Yr={kernelName:t.Neg,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=t.x;if(n.shouldExecuteOnCPU([r])){var i=n.tensorMap.get(r.dataId),a=u(lt(i.values,r.shape,r.dtype),2),o=a[0],s=a[1];return n.makeTensorInfo(s,r.dtype,o)}var l=new xe(r.shape,W.NEG);return n.runWebGPUProgram(l,[r],r.dtype)}};var Qr={kernelName:t.NonMaxSuppressionV3,backendName:"webgpu",kernelFunc:function(e){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");var n=e.inputs,r=e.backend,i=e.attrs,a=n.boxes,o=n.scores,s=i.maxOutputSize,u=i.iouThreshold,l=i.scoreThreshold,d=r.readSync(a.dataId),h=r.readSync(o.dataId),p=t.kernel_impls.nonMaxSuppressionV3Impl(d,h,s,u,l).selectedIndices;return r.makeTensorInfo([p.length],"int32",new Int32Array(p))}};var Zr={kernelName:t.NonMaxSuppressionV5,backendName:"webgpu",kernelFunc:function(e){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");var n=e.inputs,r=e.backend,i=e.attrs,a=n.boxes,o=n.scores,s=i.maxOutputSize,u=i.iouThreshold,l=i.scoreThreshold,d=i.softNmsSigma,h=r.readSync(a.dataId),p=r.readSync(o.dataId),c=s,f=u,m=l,v=d,g=t.kernel_impls.nonMaxSuppressionV5Impl(h,p,c,f,m,v),b=g.selectedIndices,x=g.selectedScores;return[r.makeTensorInfo([b.length],"int32",new Int32Array(b)),r.makeTensorInfo([x.length],"float32",new Float32Array(x))]}};function Jr(e){var t=e.inputs,n=e.backend,r=t.x;if("complex64"===r.dtype){var i=nn({inputs:{input:r},backend:n}),a=Jr({inputs:{x:i},backend:n}),o=pn({inputs:{input:r},backend:n}),s=Jr({inputs:{x:o},backend:n}),u=ge({inputs:{real:a,imag:s},backend:n});return n.disposeData(i.dataId),n.disposeData(a.dataId),n.disposeData(o.dataId),n.disposeData(s.dataId),u}return se({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:n})}var $r={kernelName:t.ZerosLike,backendName:"webgpu",kernelFunc:Jr};var ei={kernelName:t.OnesLike,backendName:"webgpu",kernelFunc:function e(t){var n=t.inputs,r=t.backend,i=n.x;if("string"===i.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===i.dtype){var a=nn({inputs:{input:i},backend:r}),o=e({inputs:{x:a},backend:r}),s=pn({inputs:{input:i},backend:r}),u=Jr({inputs:{x:s},backend:r}),l=ge({inputs:{real:o,imag:u},backend:r});return r.disposeData(a.dataId),r.disposeData(o.dataId),r.disposeData(s.dataId),r.disposeData(u.dataId),l}return se({attrs:{shape:i.shape,dtype:i.dtype,value:1},backend:r})}};var ti={kernelName:t.Pack,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,r=e.backend,i=e.attrs.axis;if(1===n.length)return tr({inputs:{input:n[0]},backend:r,attrs:{dim:i}});var a=n[0].shape,o=n[0].dtype;n.forEach((function(e){t.util.assertShapesMatch(a,e.shape,"All tensors passed to stack must have matching shapes"),t.util.assert(o===e.dtype,(function(){return"All tensors passed to stack must have matching dtypes"}))}));var s=[],u=mn({inputs:n.map((function(e){var t=tr({inputs:{input:e},backend:r,attrs:{dim:i}});return s.push(t),t})),backend:r,attrs:{axis:i}});return s.forEach((function(e){return r.disposeData(e.dataId)})),u}},ni=function(){function e(e,t){var n=this;this.variableNames=["x"],this.uniforms="constantValue : f32,",this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=t.map((function(t,n){return t[0]+e[n]+t[1]})),this.dispatchLayout=B(this.outputShape),this.dispatch=z(this.dispatchLayout,this.outputShape,this.workGroupSize),t.map((function(e,t){n.uniforms+=" pad"+t+" : vec2<i32>,"})),this.xShape=e,this.shaderKey="pad"}return e.prototype.getUserCode=function(){var e=this.xShape.length,t=x(e),n=this.xShape.map((function(e,t){return"uniforms.pad"+t+"[0]"})).join(","),r=this.xShape.map((function(t,n){return"uniforms.pad"+n+"[0] + uniforms.xShape"+(e>1?"["+n+"]":"")})).join(","),i=e>1?t+"("+n+")":""+n,a=e>1?t+"("+r+")":""+r,o=e>1?"any(outC < start)":"outC < start",s=e>1?"any(outC >= end)":"outC >= end",u=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return"\n      "+w("index")+" {\n        if (index < uniforms.size) {\n          let start = "+i+";\n          let end = "+a+";\n          let outC = getCoordsFromIndex(index);\n\n          if ("+o+" || "+s+") {\n            setOutputAtIndex(index, uniforms.constantValue);\n          } else {\n            let coords = outC - start;\n            setOutputAtIndex(index, getX("+u+"));\n          }\n        }\n      }\n    "},e}(),ri=function(e){var n=e.inputs,r=e.backend,i=e.attrs,a=n.x,o=i.paddings,s=i.constantValue;if(o.every((function(e){return t.util.arraysEqual(e,[0,0])})))return me({inputs:{x:a},backend:r});if(0===t.util.sizeFromShape(a.shape))return se({backend:r,attrs:{shape:o.map((function(e,t){return e[0]+a.shape[t]+e[1]})),value:s,dtype:a.dtype}});var u=[{type:"float32",data:[s]}];o.map((function(e){return u.push({type:"int32",data:[e[0],e[1]]})}));var l=new ni(a.shape,o);return r.runWebGPUProgram(l,[a],a.dtype,u)},ii={kernelName:t.PadV2,backendName:"webgpu",kernelFunc:ri},ai=we({opType:D.POW}),oi={kernelName:t.Pow,backendName:"webgpu",kernelFunc:ai};var si={kernelName:t.Prelu,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=t.x,i=t.alpha,a=new fe(D.PRELU,r.shape,i.shape);return n.runWebGPUProgram(a,[r,i],"float32")}};var ui={kernelName:t.Prod,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs;return Wt(t.x,r.axis,r.keepDims,"prod",n)}},li={kernelName:t.Range,backendName:"webgpu",kernelFunc:function(e){var t=e.backend,n=e.attrs,r=n.start,i=n.stop,a=n.step,o=n.dtype,s=pt(r,i,a,o);return t.makeTensorInfo([s.length],o,s)}},di=we({opType:D.DIV}),hi={kernelName:t.RealDiv,backendName:"webgpu",kernelFunc:di},pi=ye({opType:W.RECIPROCAL}),ci={kernelName:t.Reciprocal,backendName:"webgpu",kernelFunc:pi},fi=ye({opType:W.RELU}),mi={kernelName:t.Relu,backendName:"webgpu",kernelFunc:fi},vi=ye({opType:W.RELU6}),gi={kernelName:t.Relu6,backendName:"webgpu",kernelFunc:vi},bi=function(){function e(e,t,n){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, halfPixelCenters : f32,",this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],t,n,e[3]],this.dispatchLayout=B(this.outputShape),this.dispatch=z(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="resizeBilinear"}return e.prototype.getUserCode=function(){return"\n      "+w("index")+" {\n        if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n          let b = coords[0];\n          let d = coords[3];\n          let rc = coords.yz;\n\n          let effectiveInSize = vec2<f32>(\n            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveOutSize = vec2<f32>(\n            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveInputOverOutputRatioRC =\n              effectiveInSize / effectiveOutSize;\n\n          // Fractional source index\n          let sourceFracIndexRC =\n            (vec2<f32>(rc) + vec2<f32>(uniforms.halfPixelCenters)) *\n            effectiveInputOverOutputRatioRC - vec2<f32>(uniforms.halfPixelCenters);\n\n          // Compute the four integer indices.\n          let sourceFloorRC = vec2<i32>(sourceFracIndexRC);\n          let sourceCeilRC = vec2<i32>(\n            min(vec2<f32>(uniforms.xShape.yz) - vec2<f32>(1.0), ceil(sourceFracIndexRC)));\n\n          let topLeft = getX(b, sourceFloorRC.x, sourceFloorRC.y, d);\n          let bottomLeft = getX(b, sourceCeilRC.x, sourceFloorRC.y, d);\n          let topRight = getX(b, sourceFloorRC.x, sourceCeilRC.y, d);\n          let bottomRight = getX(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n          let fracRC = sourceFracIndexRC - vec2<f32>(sourceFloorRC);\n\n          let top = topLeft + (topRight - topLeft) * fracRC.y;\n          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n          let newValue = top + (bottom - top) * fracRC.x;\n\n          setOutputAtIndex(index, newValue);\n        }\n      }\n    "},e}();var xi={kernelName:t.ResizeBilinear,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.images,a=r.alignCorners,o=r.size,s=r.halfPixelCenters,l=u(o,2),d=l[0],h=l[1],p=[{type:"float32",data:[a&&d>1?1:0,a&&h>1?1:0]},{type:"float32",data:[s?.5:0]}],c=new bi(i.shape,d,h);return n.runWebGPUProgram(c,[i],"float32",p)}},yi=function(){function e(e,t,n,r){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, roundBase : f32,",this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],t,n,e[3]],this.dispatchLayout=B(this.outputShape),this.dispatch=z(this.dispatchLayout,this.outputShape,this.workGroupSize),this.halfPixelCenters=r,this.shaderKey="resizeNearest_"+r}return e.prototype.getUserCode=function(){var e;return e=this.halfPixelCenters?"max((vec2<f32>(rc) + vec2<f32>(0.5)) * effectiveInputOverOutputRatioRC, vec2<f32>(0.0))":"vec2<f32>(rc) * effectiveInputOverOutputRatioRC","\n      "+w("index")+" {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let b = coords[0];\n          let d = coords[3];\n          let rc = coords.yz;\n\n          let effectiveInSize = vec2<f32>(\n            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveOutSize = vec2<f32>(\n            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveInputOverOutputRatioRC =\n              effectiveInSize / effectiveOutSize;\n\n          // Fractional source index\n          let sourceFracIndexRC = "+e+";\n\n          // Compute the coordinators of nearest neighbor point.\n          let inputShapeRC = vec2<f32>(f32(uniforms.xShape.y), f32(uniforms.xShape.z));\n          let sourceNearestRC = vec2<i32>(\n            min(inputShapeRC - 1.0, floor(sourceFracIndexRC + uniforms.roundBase)));\n          let newValue = getX(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n          setOutputAtIndex(index, newValue);\n        }\n      }\n    "},e}();var wi={kernelName:t.ResizeNearestNeighbor,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.images,a=r.alignCorners,o=r.halfPixelCenters,s=u(r.size,2),l=s[0],d=s[1],h=[{type:"float32",data:[a&&l>1?1:0,a&&d>1?1:0]},{type:"float32",data:[a?.5:0]}],p=new yi(i.shape,l,d,o);return n.runWebGPUProgram(p,[i],i.dtype,h)}},ki=function(){function e(e,t){this.outputShape=[],this.variableNames=["x"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=B(this.outputShape),this.dispatch=z(this.dispatchLayout,this.outputShape,this.workGroupSize),this.uniforms="centerX : f32, centerY : f32, sinRadians : f32,\n          cosRadians : f32,",this.shaderKey="rotate",this.outputShape=e,"number"==typeof t?(this.uniforms+=" fillValue : f32,",this.fillSnippet="var outputValue = uniforms.fillValue;",this.shaderKey+="_float"):(this.uniforms+=" fillValue : vec3<f32>,",this.fillSnippet="var outputValue = uniforms.fillValue[coords[3]];",this.shaderKey+="_vec3")}return e.prototype.getUserCode=function(){return"\n        "+w("index")+" {\n          if (index < uniforms.size) {\n            let coords = getCoordsFromIndex(index);\n            let coordXFloat = (f32(coords[2]) - uniforms.centerX) *\n                uniforms.cosRadians - (f32(coords[1]) - uniforms.centerY) *\n                uniforms.sinRadians;\n            let coordYFloat = (f32(coords[2]) - uniforms.centerX) *\n                uniforms.sinRadians + (f32(coords[1]) - uniforms.centerY) *\n                uniforms.cosRadians;\n            let coordX = i32(round(coordXFloat + uniforms.centerX));\n            let coordY = i32(round(coordYFloat + uniforms.centerY));\n            "+this.fillSnippet+"\n            if(coordX >= 0 && coordX < uniforms.xShape[2] && coordY >= 0 &&\n                coordY < uniforms.xShape[1]) {\n              outputValue = getX(coords[0], coordY, coordX, coords[3]);\n            }\n            setOutputAtIndex(index, outputValue);\n          }\n        }\n      "},e}(),Ii={kernelName:t.RotateWithOffset,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,r=e.attrs,i=e.backend,a=n.image,o=r.radians,s=r.fillValue,l=r.center,d=i,h=new ki(a.shape,s),p=u(t.backend_util.getImageCenter(l,a.shape[1],a.shape[2]),2),c=[{type:"float32",data:[p[0]]},{type:"float32",data:[p[1]]},{type:"float32",data:[Math.sin(o)]},{type:"float32",data:[Math.cos(o)]}];return"number"==typeof s?c.push({type:"float32",data:[Number.parseFloat(s.toFixed(2))]}):c.push({type:"float32",data:s}),d.runWebGPUProgram(h,[a],a.dtype,c)}},Si=ye({opType:W.RSQRT,cpuKernelImpl:ct}),Ci={kernelName:t.Rsqrt,backendName:"webgpu",kernelFunc:Si},Ri=function(){function e(e,t,n,r,i,a,o,s){void 0===s&&(s=!0),this.variableNames=["updates","indices"],this.workGroupSize=[64,1,1],this.atomic=!0,this.outputShape=a,this.type=o,this.sumDupeIndices=s,this.dispatchLayout=B(e),this.dispatch=z(this.dispatchLayout,e,this.workGroupSize),this.sliceDimGreaterThanOne=t>1,this.shaderKey="scatter_"+n+"_"+r+"_"+this.sliceDimGreaterThanOne+"_"+o+"_"+s;var u=x(i.length);this.uniforms="sliceDim : i32, strides: "+u+", size: i32,",this.updatesRank=r,this.indicesRank=n}return e.prototype.getUserCode=function(){var e=this,t="";1===this.indicesRank?t="coords[0]":2===this.indicesRank&&(t="coords[0], j");var n="getIndices("+t+")",r=this.sliceDimGreaterThanOne?"uniforms.strides[j]":"uniforms.strides",i="",a="";1===this.dispatchLayout.x.length?(i="flattenedIndex",a="\n      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {\n        return index;\n      }\n      "):2===this.dispatchLayout.x.length&&(i="vec2<i32>(flattenedIndex, coords[1])",a="\n      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {\n        // N.B. |updates| could be a scalar tensor, conceptually representing a\n        // 2D tensor with all values equal to that. By design, its size must be\n        // the same as |outShape[1]| in one dimension, and |indicesShape[0]|\n        // gives the other.\n        let sliceSize = uniforms.outShape[1];\n        let d0 = index / sliceSize;\n        let d1 = index - d0 * sliceSize;\n        return vec2<i32>(d0, d1);\n      }\n      ");var o="getUpdates("+Array.from({length:this.updatesRank},(function(e,t){return"coords["+t+"]"})).join(", ")+")";return"\n    "+a+"\n\n      "+w("index")+" {\n        if (index < uniforms.size) {\n          let coords = getUpdatesCoordsFromFlatIndex(index);\n          var flattenedIndex = 0;\n          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {\n            let indexInside = i32(round("+n+"));\n            flattenedIndex = flattenedIndex + indexInside * "+r+";\n          }\n          let updateValue =\n              "+R(this.type,!1)+"("+o+");\n          let flatIndex = getOutputIndexFromCoords("+i+");\n\n          "+function(t,n){var r="atomicAdd("+t+", bitcast<i32>("+n+"))";"float32"===e.type&&(r="\n          {\n            var oldBits = 0;\n            var newBits = bitcast<i32>("+n+");\n            loop {\n              let info = atomicCompareExchangeWeak("+t+", oldBits, newBits);\n              if (info.exchanged) {\n                break;\n              }\n              oldBits = info.old_value;\n              let oldValue = bitcast<f32>(oldBits);\n              let newValue = oldValue + ("+n+");\n              newBits = bitcast<i32>(newValue);\n            }\n          }\n        ");var i="atomicStore("+t+", bitcast<i32>("+n+"));";return e.sumDupeIndices?r:i}("&result[flatIndex]","updateValue")+";\n        }\n      }"},e}();var Ai={kernelName:t.ScatterNd,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,r=e.backend,i=e.attrs,a=n.indices,o=n.updates,s=i.shape,u=t.backend_util.calculateShapes(o,a,s),l=u.sliceRank,d=u.numUpdates,h=u.sliceSize,p=u.strides,c=u.outputSize,f=[c/h,h];if(0===c)return r.makeTensorInfo(s,a.dtype);var m=le({inputs:{x:a},backend:r,attrs:{shape:[d,l]}}),v=le({inputs:{x:o},backend:r,attrs:{shape:[d,h]}}),g=v.dtype,b=se({backend:r,attrs:{shape:f,value:0,dtype:g}}),x=[{type:"int32",data:[l]},{type:"int32",data:p},{type:"int32",data:[t.util.sizeFromShape(v.shape)]}],y=new Ri(v.shape,l,m.shape.length,v.shape.length,p,f,g),w=r.runWebGPUProgram(y,[v,m],g,x,b),k=le({inputs:{x:w},backend:r,attrs:{shape:s}});return r.disposeData(m.dataId),r.disposeData(v.dataId),r.disposeData(w.dataId),k}},Ti=function(){function e(e,t,n){this.variableNames=["c","a","b"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=B(this.outputShape),this.dispatch=z(this.dispatchLayout,this.outputShape,this.workGroupSize),this.cRank=e,this.rank=n,this.shaderKey="select"}return e.prototype.getUserCode=function(){var e,t;if(this.rank>4)throw Error("Where for rank "+this.rank+" is not yet supported");if(1===this.rank)t="resRC",e="resRC";else{for(var n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[],i=[],a=0;a<this.outputShape.length;a++)i.push(""+n[a]),a<this.cRank&&r.push(""+n[a]);e=r.join(),t=i.join()}return"\n      "+w("index")+" {\n        if (index < uniforms.size) {\n          let resRC = getCoordsFromIndex(index);\n          let cVal = getC("+e+");\n          if (cVal >= 1.0) {\n            setOutputAtIndex(index, getA("+t+"));\n          } else {\n            setOutputAtIndex(index, getB("+t+"));\n          }\n        }\n      }\n    "},e}();var zi={kernelName:t.Select,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,r=e.backend,i=n.condition,a=n.t,o=n.e,s=new Ti(i.shape.length,a.shape,a.shape.length);return r.runWebGPUProgram(s,[i,a,o],t.upcastType(a.dtype,o.dtype))}},Pi=ye({opType:W.SIGMOID}),_i={kernelName:t.Sigmoid,backendName:"webgpu",kernelFunc:Pi},Ni=ye({opType:W.SIN}),Bi={kernelName:t.Sin,backendName:"webgpu",kernelFunc:Ni},Ei=ye({opType:W.SINH}),Fi={kernelName:t.Sinh,backendName:"webgpu",kernelFunc:Ei},Gi=we({opType:D.SUB,cpuKernelImpl:xt,supportsComplex:!0}),Li={kernelName:t.Sub,backendName:"webgpu",kernelFunc:Gi};var Oi={kernelName:t.Softmax,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,r=e.backend,i=e.attrs,a=n.logits,o=i.dim,s=t.util.parseAxisParam([o],a.shape),u=Mt({inputs:{x:a},backend:r,attrs:{reductionIndices:s,keepDims:!1}}),l=t.backend_util.expandShapeToKeepDim(u.shape,s),d=le({inputs:{x:u},backend:r,attrs:{shape:l}}),h=Gi({inputs:{a:a,b:d},backend:r}),p=$n({inputs:{x:h},backend:r}),c=qn({inputs:{x:p},backend:r,attrs:{axis:s,keepDims:!1}}),f=le({inputs:{x:c},backend:r,attrs:{shape:l}}),m=di({inputs:{a:p,b:f},backend:r});return r.disposeData(u.dataId),r.disposeData(d.dataId),r.disposeData(h.dataId),r.disposeData(p.dataId),r.disposeData(c.dataId),r.disposeData(f.dataId),m}},Ui={kernelName:t.SpaceToBatchND,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,r=e.backend,i=e.attrs,a=n.x,o=i.blockShape,s=i.paddings;t.util.assert(a.shape.length<=4,(function(){return"spaceToBatchND for rank > 4 with a WebGPU backend not implemented yet"}));var u=o.reduce((function(e,t){return e*t})),d=[[0,0]];d.push.apply(d,l(s));for(var h=1+o.length;h<a.shape.length;++h)d.push([0,0]);var p=[],c=ri({inputs:{x:a},backend:r,attrs:{paddings:d,constantValue:0}}),f=t.backend_util.getReshaped(c.shape,o,u,!1),m=t.backend_util.getPermuted(f.length,o.length,!1),v=t.backend_util.getReshapedPermuted(c.shape,o,u,!1),g=le({inputs:{x:c},backend:r,attrs:{shape:f}}),b=Nt({inputs:{x:g},backend:r,attrs:{perm:m}}),x=le({inputs:{x:b},backend:r,attrs:{shape:v}});return p.push(c),p.push(g),p.push(b),p.forEach((function(e){return r.disposeData(e.dataId)})),x}},Di=function(){function e(e,t){this.variableNames=["A"],this.workGroupSize=[64,1,1],this.size=!0;for(var n=new Array(e.length),r=0;r<n.length;r++)n[r]=e[r]*t[r];this.outputShape=n,this.dispatchLayout=B(this.outputShape),this.dispatch=z(this.dispatchLayout,this.outputShape,this.workGroupSize),this.rank=this.outputShape.length,this.shaderKey="tile"}return e.prototype.getUserCode=function(){var e=function(e,t){void 0===t&&(t="");if(e>=5)throw Error("Tile for rank "+e+" is not yet supported");if(1===e)return"(resRC % "+t+"aShape)";for(var n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[],i=0;i<e;i++)r.push("("+n[i]+" % "+t+"aShape["+i+"])");return r.join()}(this.rank,"uniforms.");return"\n      "+w("index")+" {\n        if (index < uniforms.size) {\n          let resRC = getCoordsFromIndex(index);\n          setOutputAtIndex(index, getA("+e+"));\n        }\n      }\n    "},e}();function Wi(e){var n=e.inputs,r=e.backend,i=e.attrs,a=n.x,o=i.reps;if(r.shouldExecuteOnCPU([a])||"string"===a.dtype||a.shape.length>=5){var s=r.readSync(a.dataId),u="string"===a.dtype?s.map((function(e){return t.util.decodeString(e)})):s,l=t.buffer(a.shape,a.dtype,u),d=yt(l,o);return r.makeTensorInfo(d.shape,d.dtype,d.values)}var h=new Di(a.shape,o);return r.runWebGPUProgram(h,[a],a.dtype)}var Mi={kernelName:t.Tile,backendName:"webgpu",kernelFunc:Wi};var Vi={kernelName:t.SparseToDense,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,r=e.backend,i=e.attrs,a=n.sparseIndices,o=n.sparseValues,s=n.defaultValue,u=i.outputShape,l=t.backend_util.calculateShapes(o,a,u),d=l.sliceRank,h=l.numUpdates,p=l.sliceSize,c=l.strides,f=l.outputSize,m=!1;if("string"===o.dtype){var v=r.bufferSync(a),g=r.bufferSync(o),b=t.util.decodeString(r.readSync(s.dataId)[0]),x=ft(v,g,u,f,p,h,d,c,b,m);return r.makeTensorInfo(u,x.dtype,x.values)}var y=[f/p,p],w=le({inputs:{x:a},backend:r,attrs:{shape:[h,d]}}),k=o.shape.length?le({inputs:{x:o},backend:r,attrs:{shape:[h,p]}}):me({inputs:{x:o},backend:r}),I=k.dtype,S=r.makeTensorInfo([],I,t.util.makeZerosTypedArray(1,I)),C=le({inputs:{x:s},backend:r,attrs:{shape:Array(y.length).fill(1)}}),R=Wi({inputs:{x:C},backend:r,attrs:{reps:y}}),A=[{type:"int32",data:[d]},{type:"int32",data:c},{type:"int32",data:[t.util.sizeFromShape([h,p])]}];switch(h){case 0:break;case 1:var T=new Ri([h,p],d,w.shape.length,k.shape.length,c,y,I,m);r.runWebGPUProgram(T,[k,w],I,A,R);break;default:T=new Ri([h,p],d,w.shape.length,S.shape.length,c,y,I,m);r.runWebGPUProgram(T,[S,w],I,A,R);T=new Ri([h,p],d,w.shape.length,k.shape.length,c,y,I);r.runWebGPUProgram(T,[k,w],I,A,R)}var z=le({inputs:{x:R},backend:r,attrs:{shape:u}});return r.disposeData(w.dataId),r.disposeData(k.dataId),r.disposeData(C.dataId),r.disposeData(S.dataId),r.disposeData(R.dataId),z}};var Hi={kernelName:t.SplitV,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,r=e.backend,i=e.attrs,a=n.x,o=i.numOrSizeSplits,s=i.axis,u=t.util.parseAxisParam(s,a.shape)[0],d=t.backend_util.prepareSplitSize(a,o,u),h=a.shape.length,p=new Array(h).fill(0),c=a.shape.slice();return d.map((function(e){var t=l(c);t[u]=e;var n=Zt({inputs:{x:a},backend:r,attrs:{begin:p,size:t}});return p[u]+=e,n}))}},Xi=ye({opType:W.SQRT}),qi={kernelName:t.Sqrt,backendName:"webgpu",kernelFunc:Xi},Ki={kernelName:t.Square,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=t.x,i=n,a=new xe(r.shape,W.SQUARE);return i.runWebGPUProgram(a,[r],r.dtype)}},ji=we({opType:D.SQUARED_DIFFERENCE}),Yi={kernelName:t.SquaredDifference,backendName:"webgpu",kernelFunc:ji},Qi=function(){function e(e){this.variableNames=["x"],this.workPerThread=1,this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=B(this.outputShape),this.dispatch=z(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]);var t=x(this.outputShape.length);this.uniforms="begin : "+t+",  strides : "+t+", ",this.shaderKey="stridedSlice"}return e.prototype.getUserCode=function(){var e=this,t="";if(1===this.outputShape.length)t="coords * uniforms.strides + uniforms.begin";else{var n=0;t=this.outputShape.map((function(t,r){return n++,1===e.outputShape.length?"coords * uniforms.strides["+r+"] + uniforms.begin["+r+"]":"coords["+(n-1)+"] * uniforms.strides["+r+"] + uniforms.begin["+r+"]"})).join(",")}return"\n       "+w("index")+" {\n         if (index < uniforms.size) {\n           let coords = getCoordsFromIndex(index);\n           setOutputAtIndex(index, getX("+t+"));\n         }\n       }\n     "},e}();var Zi={kernelName:t.StridedSlice,backendName:"webgpu",kernelFunc:function(e){var n,r=e.inputs,i=e.backend,a=e.attrs,o=r.x,s=a.begin,u=a.end,l=a.strides,d=a.beginMask,h=a.endMask,p=a.ellipsisMask,c=a.newAxisMask,f=a.shrinkAxisMask,m=t.slice_util.sliceInfo(o.shape,s,u,l,d,h,p,c,f),v=m.finalShapeSparse,g=m.finalShape,b=m.isIdentity,x=m.sliceDim0,y=m.isSimpleSlice,w=m.begin,k=m.end,I=m.strides;if(b)n=le({inputs:{x:o},backend:i,attrs:{shape:g}});else if(x||y){t.util.assert(o.shape.length>=1,(function(){return"Input must have rank at least 1, got: "+o.shape.length}));var S=t.slice_util.computeOutShape(w,k,I),C=Zt({inputs:{x:o},backend:i,attrs:{begin:w,size:S}});n=le({inputs:{x:C},backend:i,attrs:{shape:g}}),i.disposeData(C.dataId)}else{if(i.shouldExecuteOnCPU([o])){var R=i.readSync(o.dataId),A=t.buffer(o.shape,o.dtype,R),T=gt(v,A,I,w);n=i.makeTensorInfo(g,o.dtype,T.values)}else{var z=new Qi(v),P=[{type:"int32",data:w},{type:"int32",data:I}];n=le({inputs:{x:T=i.runWebGPUProgram(z,[o],o.dtype,P)},backend:i,attrs:{shape:g}}),i.disposeData(T.dataId)}}return n}};var Ji={kernelName:t.StringNGrams,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=r.separator,a=r.nGramWidths,o=r.leftPad,s=r.rightPad,l=r.padWidth,d=r.preserveShortSequences,h=t.data,p=t.dataSplits,c=n.readSync(h.dataId),f=n.readSync(p.dataId),m=u(bt(c,f,i,a,o,s,l,d),2),v=m[0],g=m[1];return[n.makeTensorInfo([v.length],"string",v),n.makeTensorInfo(p.shape,"int32",g)]}},$i=ye({opType:W.TANH}),ea={kernelName:t.Tanh,backendName:"webgpu",kernelFunc:$i},ta=function(){function e(e){this.variableNames=["x","indices"],this.workGroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=B(this.outputShape),this.dispatch=z(this.dispatchLayout,this.outputShape,this.workGroupSize),this.uniforms="inputSize : i32, firstPass : i32, negativeInf : f32,\n        dir : i32, inc : i32,",this.shaderKey="swap"}return e.prototype.getUserCode=function(){return"\n        "+w("index")+" {\n          if (index < uniforms.size) {\n            let outC = getCoordsFromIndex(index);\n            let batch = outC[0];\n            let elemIdx = outC[1];\n            // We compare elements pair-wise within a group of size 2 * inc.\n            // The comparing rule for each group alternates between ascending\n            // and descending. Within each group, we compare each pair at\n            // positions i and i+inc. To decide whether an element at position i\n            // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n            // inc, it is in the first half of the group, we denote it as x0,\n            // otherwise we denote it as x1.\n            // For example, as shown in the Bitonic top K paper referenced\n            // above, Figure5(a) shows that element[1] is in the second half of\n            // the group when group size is 2, but it is in the first half of\n            // the group when group size is 4.\n            let isFirstInPair = elemIdx % (2 * uniforms.inc) < uniforms.inc;\n            var i = 0;\n            if (isFirstInPair) {\n              i = elemIdx;\n            } else {\n              i = elemIdx - uniforms.inc;\n            }\n\n            var i0 = 0;\n            if (uniforms.firstPass == 1) {\n              i0 = i;\n            } else {\n              i0 = i32(getIndices(batch, i));\n            }\n\n            var i1 = 0;\n            if (uniforms.firstPass == 1) {\n              i1 = i + uniforms.inc;\n            } else {\n              i1 = i32(getIndices(batch, i + uniforms.inc));\n            }\n\n            var x0 = f32(0.0);\n            var x1 = f32(0.0);\n            if (i0 < uniforms.inputSize) {\n              x0 = getX(batch, i0);\n            } else {\n              x0 = uniforms.negativeInf;\n            }\n            if (i1 < uniforms.inputSize) {\n              x1 = getX(batch, i1);\n            } else {\n              x1 = uniforms.negativeInf;\n            }\n\n            let reverse = elemIdx % (2 * uniforms.dir) >= uniforms.dir;\n            let isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n            if (reverse == isGreater) {\n              // Elements in opposite order of direction\n              let iTemp = i0;\n              i0 = i1;\n              i1 = iTemp;\n            }\n            if (isFirstInPair) {\n              setOutputAtIndex(index, f32(i0));\n            } else {\n              setOutputAtIndex(index, f32(i1));\n            }\n          }\n        }\n      "},e}(),na=function(){function e(e){this.variableNames=["x","indices"],this.workGroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=B(this.outputShape),this.dispatch=z(this.dispatchLayout,this.outputShape,this.workGroupSize),this.uniforms="inputSize : i32, firstPass : i32, k : i32,",this.shaderKey="merge"}return e.prototype.getUserCode=function(){return"\n        "+w("index")+" {\n          if (index < uniforms.size) {\n            let outC = getCoordsFromIndex(index);\n            let batch = outC[0];\n            let elemIdx = outC[1];\n            // The output size is half of the previous size.\n            // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _\n            // (k=4), we only need to output the indices at positions |, the\n            // indices at positions _ can be thrown away, see Figure5(b) After\n            // Phase 2 (Merge phase) in the Bitonic Top K paper referenced\n            // above.\n            // For example, the paper shows we only need to output the orange\n            // bars. The output sequence should look like this | | | | | | | |.\n            // Because the sequence is halved, to map the output index back to\n            // the previous sequence to find the corresponding value, we need\n            // to double the index. When we double the index, we basically\n            // interpolate a position, so 2i looks like\n            // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k\n            // position of each 2k positions by - elemIdx % k. E.g. for output\n            // at index 4,5,6,7, we want to get the corresponding element at\n            // original index 8,9,10,11, for output at index 8,9,10,11,\n            // we want to get the corresponding element at original index\n            // 16,17,18,19, so on and so forth.\n\n            var i = 0;\n            if (elemIdx < uniforms.k) {\n              i = elemIdx;\n            } else {\n              i = elemIdx * 2 - elemIdx % uniforms.k;\n            }\n            var i0 = 0;\n            if (uniforms.firstPass == 1) {\n              i0 = i;\n            } else {\n              i0 = i32(getIndices(batch, i));\n            }\n            var i1 = 0;\n            if (uniforms.firstPass == 1) {\n              i1 = i + uniforms.k;\n            } else {\n              i1 = i32(getIndices(batch, i + uniforms.k));\n            }\n\n            let x0 = getX(batch, i0);\n            var x1 = f32(0.0);\n            if (i1 < uniforms.inputSize) {\n              x1 = getX(batch, i1);\n            } else {\n              x1 = x0;\n            }\n\n            if (x0 >= x1) {\n              setOutputAtIndex(index, f32(i0));\n            } else {\n              setOutputAtIndex(index, f32(i1));\n            }\n          }\n        }\n      "},e}();function ra(e,t){null!==t&&e.disposeData(t.dataId)}function ia(e){for(var t=1;t<e;)t*=2;return t}var aa={kernelName:t.TopK,backendName:"webgpu",kernelFunc:function(e){var n=e.inputs,r=e.backend,i=e.attrs,a=n.x,o=i.k,s=i.sorted,l=a.shape,d=l[l.length-1];if(r.shouldExecuteOnCPU([a])){var h=r.readSync(a.dataId),p=u(wt(h,l,a.dtype,o,s),2),c=p[0],f=p[1];return[r.makeTensorInfo(c.shape,c.dtype,c.values),r.makeTensorInfo(f.shape,f.dtype,f.values)]}if(0===o)return l[l.length-1]=0,[r.makeTensorInfo(l,a.dtype,[]),r.makeTensorInfo(l,"int32",[])];if(1===d)return[a,se({attrs:{shape:l,dtype:"int32",value:0},backend:r})];for(var m=t.util.sizeFromShape(l)/d,v=le({inputs:{x:a},attrs:{shape:[m,d]},backend:r}),g=ia(o),b=ia(d),x=null,y=function(){return null===x?[v,v]:[v,x]},w=function(e,t,n){var i=y(),a=new ta(n),o=[{type:"int32",data:[d]},{type:"int32",data:[null===x?1:0]},{type:"float32",data:[Number.NEGATIVE_INFINITY]},{type:"int32",data:[e]},{type:"int32",data:[t]}],s=x;x=r.runWebGPUProgram(a,i,"int32",o),ra(r,s)},k=1;k<g;k*=2)for(var I=2*k,S=k;S>=1;S/=2)w(I,S,[m,b]);for(var C=b;C>g;C/=2){var R=y(),A=new na([m,C/2]),T=[{type:"int32",data:[d]},{type:"int32",data:[null===x?1:0]},{type:"int32",data:[g]}],z=x;x=r.runWebGPUProgram(A,R,"int32",T),ra(r,z);for(I=2*(k=g/2),S=k;S>=1;S/=2)w(I,S,x.shape)}var P=x;x=Zt({inputs:{x:x},backend:r,attrs:{begin:0,size:[m,o]}}),ra(r,P);var _=kr({inputs:{x:v,indices:x},backend:r,attrs:{axis:1,batchDims:1}});ra(r,v);var N=l.slice(0,-1);N.push(o),P=x,x=le({inputs:{x:x},attrs:{shape:N},backend:r}),ra(r,P);var B=_;return _=le({inputs:{x:_},attrs:{shape:N},backend:r}),ra(r,B),[_,x]}},oa=function(){function e(e){this.variableNames=["Image","Transforms"],this.uniforms="interpolationModeId : i32, fillModeId : i32, fillValue : f32,",this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=B(this.outputShape),this.dispatch=z(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="transform"}return e.prototype.getUserCode=function(){return"\n          fn mapCoord(outCoord : f32, len : f32) -> f32{\n            var inCoord = outCoord;\n            if(uniforms.fillModeId == 2) {\n              if (inCoord < 0.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz2 = 2.0 * len;\n                  if (inCoord < sz2) {\n                    inCoord = sz2 * f32(i32(f32(-inCoord / sz2))) +\n                    inCoord;\n                  }\n                  if (inCoord < -len) {\n                    inCoord = inCoord + sz2;\n                  } else {\n                    inCoord = -inCoord - 1.0;\n                  }\n                }\n              } else if (inCoord > len - 1.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz2 = 2.0 * len;\n                  inCoord = inCoord - sz2 * f32(i32(f32(inCoord / sz2)));\n                  if (inCoord >= len) {\n                    inCoord = sz2 - inCoord - 1.0;\n                  }\n                }\n              }\n              return clamp(inCoord, 0.0, len - 1.0);\n            } else if (uniforms.fillModeId == 3) {\n              if (inCoord < 0.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz = len - 1.0;\n                  inCoord = inCoord + len * (f32(i32(f32(-inCoord / sz))) + 1.0);\n                }\n              } else if (inCoord > len - 1.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz = len - 1.0;\n                  inCoord = inCoord - len * f32(i32(f32(inCoord / sz)));\n                }\n              }\n              return clamp(inCoord, 0.0, len - 1.0);\n            } else if (uniforms.fillModeId == 4) {\n              return clamp(outCoord, 0.0, len - 1.0);\n            }\n            return outCoord;\n          }\n          fn readWithFillValue(batch : i32, coordY : i32, coordX : i32,\n            channel : i32) -> f32 {\n            var outputValue : f32;\n            if (0 <= coordY && coordY < uniforms.imageShape[1] && 0 <= coordX && coordX < uniforms.imageShape[2]) {\n                outputValue = getImage(batch, coordY, coordX, channel);\n            } else {\n              outputValue = uniforms.fillValue;\n            }\n            return outputValue;\n          }\n\n          "+w("index")+" {\n            if (index < uniforms.size) {\n              let coords = getCoordsFromIndex(index);\n              var outputValue : f32;\n              let batch = coords[0];\n              let x = coords[2];\n              let y = coords[1];\n              let channel = coords[3];\n              let xf = f32(x);\n              let yf = f32(y);\n              let a1 = getTransforms(batch, 0);\n              let a2 = getTransforms(batch, 1);\n              let a3 = getTransforms(batch, 2);\n              let b1 = getTransforms(batch, 3);\n              let b2 = getTransforms(batch, 4);\n              let b3 = getTransforms(batch, 5);\n              let c1 = getTransforms(batch, 6);\n              let c2 = getTransforms(batch, 7);\n              let projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = uniforms.fillValue;\n              } else {\n                let inX = (a1 * xf + a2 * yf + a3) / projection;\n                let inY = (b1 * xf + b2 * yf + b3) / projection;\n                let mapX = mapCoord(inX, f32(uniforms.imageShape[2]));\n                let mapY = mapCoord(inY, f32(uniforms.imageShape[1]));\n\n                if (uniforms.interpolationModeId == 1) {\n                  let coordY = i32(round(mapY));\n                  let coordX = i32(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  let yFloor = floor(mapY);\n                  let xFloor = floor(mapX);\n                  let yCeil = yFloor + 1.0;\n                  let xCeil = xFloor + 1.0;\n                  let valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, i32(yFloor), i32(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, i32(yFloor), i32(xCeil), channel);\n                  let valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, i32(yCeil), i32(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, i32(yCeil), i32(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutputAtIndex(index, outputValue);\n            }\n          }\n        "},e}();var sa={kernelName:t.Transform,backendName:"webgpu",kernelFunc:function(e){var t,n=e.inputs,r=e.backend,i=e.attrs,a=n.image,o=n.transforms,s=i.interpolation,l=i.fillMode,d=i.fillValue,h=i.outputShape,p=u(a.shape,4),c=p[0],f=p[1],m=p[2],v=p[3],g=u(null!=h?h:[f,m],2),b=g[0],x=g[1],y=new oa([c,b,x,v]),w="nearest"===s?1:2;switch(l){case"constant":default:t=1;break;case"reflect":t=2;break;case"wrap":t=3;break;case"nearest":t=4}var k=[{type:"int32",data:[w]},{type:"int32",data:[t]},{type:"float32",data:[d]}];return r.runWebGPUProgram(y,[a,o],"float32",k)}};var ua,la,da=[pe,St,Rt,Tt,Et,Ft,Lt,Kt,jt,$t,an,sn,dn,be,vn,wn,Cn,An,zn,_n,Gn,Ln,Un,Vn,jn,Qn,Jn,er,rr,ar,ue,sr,cr,lr,hr,vr,gr,br,yr,Ir,Cr,Ar,ve,cn,zr,Pr,Nr,Er,Gr,Or,Dr,Vt,Mr,Vr,Xt,Hr,qr,jr,Xn,Yr,Qr,Zr,tn,ei,ti,ii,oi,si,ui,li,rn,hi,ci,mi,gi,de,xi,wi,Ii,Ci,Ai,zi,_i,Bi,Fi,Jt,Zi,Ji,Oi,Ui,Vi,Hi,qi,Ki,Yi,Li,Kn,ea,Mi,aa,sa,Bt,{kernelName:t.Unpack,backendName:"webgpu",kernelFunc:function(e){var t=e.inputs,n=e.backend,r=e.attrs,i=t.value,a=r.axis;a<0&&(a+=i.shape.length);for(var o=i,s=o.shape.length,u=i.shape[a],l=new Array(s-1),d=0,h=0;h<s;h++)h!==a&&(l[d++]=o.shape[h]);var p=[],c=new Array(s).fill(0),f=o.shape.slice();f[a]=1;var m=new Array(u);for(h=0;h<m.length;h++){c[a]=h;var v=Zt({inputs:{x:o},backend:n,attrs:{begin:c,size:f}}),g=le({inputs:{x:v},backend:n,attrs:{shape:l}});m[h]=g,p.push(v)}return p.forEach((function(e){return n.disposeData(e.dataId)})),m}},$r];try{for(var ha=s(da),pa=ha.next();!pa.done;pa=ha.next()){var ca=pa.value;t.registerKernel(ca)}}catch(e){ua={error:e}}finally{try{pa&&!pa.done&&(la=ha.return)&&la.call(ha)}finally{if(ua)throw ua.error}}e.WebGPUBackend=U,e.webgpu_util=L,Object.defineProperty(e,"__esModule",{value:!0})}));
//# sourceMappingURL=tf-backend-webgpu.min.js.map
