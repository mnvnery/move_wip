/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import { backend_util, util } from '@tensorflow/tfjs-core';
import { symbolicallyComputeStrides } from './shader_util';
export const compileProgram = (device, program, inputsData, output) => {
    const outputData = { dtype: output.dtype, shape: output.shape };
    const source = makeShader(inputsData, outputData, program);
    const module = device.createShaderModule({ code: source, label: program.constructor.name });
    const pipeline = device.createComputePipeline({
        compute: { module, entryPoint: '_start' },
        label: program.constructor.name,
        layout: 'auto'
    });
    return pipeline;
};
export function getCoordsDataType(rank) {
    if (rank <= 1) {
        return 'i32';
    }
    else if (rank === 2) {
        return `vec2<i32>`;
    }
    else if (rank === 3) {
        return `vec3<i32>`;
    }
    else if (rank === 4) {
        return `vec4<i32>`;
    }
    else if (rank === 5) {
        return `vec5`;
    }
    else if (rank === 6) {
        return `vec6`;
    }
    else {
        throw Error(`GPU for rank ${rank} is not yet supported`);
    }
}
export function getCoordsXYZ(index) {
    if (index === 0) {
        return 'x';
    }
    else if (index === 1) {
        return 'y';
    }
    else if (index === 2) {
        return 'z';
    }
    else if (index === 3) {
        return 'w';
    }
    else if (index === 4) {
        return 'u';
    }
    else if (index === 5) {
        return 'v';
    }
    else {
        throw Error(`Index ${index} is not yet supported`);
    }
}
export function getMainHeaderString(...params) {
    let snippet;
    switch (params.length) {
        case 0:
            snippet = `
        ${getWorkGroupSizeString()}
        fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,
                  @builtin(global_invocation_id) GlobalId : vec3<u32>,
                  @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {
          localId = LocalId;
          globalId = GlobalId;
          numWorkgroups = NumWorkgroups;
          main();
        }

        fn main()
      `;
            break;
        case 1:
            snippet = `
        ${getWorkGroupSizeString()}
        fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,
                  @builtin(global_invocation_id) GlobalId : vec3<u32>,
                  @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {
          localId = LocalId;
          globalId = GlobalId;
          numWorkgroups = NumWorkgroups;
          main(getGlobalIndex());
        }

        fn main(${params[0]} : i32)
      `;
            break;
        default:
            throw Error('Unreachable');
    }
    return snippet;
}
export function getWorkGroupSizeString() {
    return `
  @compute @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)
`;
}
function makeShader(inputInfo, outputData, program) {
    const prefixSnippets = [];
    prefixSnippets.push(`
      const workGroupSizeX = ${program.workGroupSize[0]}u;
      const workGroupSizeY = ${program.workGroupSize[1]}u;
      const workGroupSizeZ = ${program.workGroupSize[2]}u;

      var<private> localId: vec3<u32>;
      var<private> globalId: vec3<u32>;
      var<private> numWorkgroups: vec3<u32>;

      // Only used when the y/z dimension of workgroup size is 1.
      fn getGlobalIndex() -> i32 {
        ${isFlatDispatch(program) ?
        `  return i32(globalId.x);` :
        `  let localInvocationIndex = localId.z * workGroupSizeX * workGroupSizeY +
                   localId.y * workGroupSizeX + localId.x;
               let workGroupID = (globalId - localId)/vec3<u32>(
                   workGroupSizeX, workGroupSizeY, workGroupSizeZ);

               return i32((workGroupID.z * numWorkgroups.x * numWorkgroups.y +
                   workGroupID.y * numWorkgroups.x + workGroupID.x) *
                   (workGroupSizeX * workGroupSizeY * workGroupSizeZ) +
                   localInvocationIndex);
        `}
      }
    `);
    if (program.isFromPixels) {
        prefixSnippets.push(`
        struct Uniform {
          size            : i32,
          numChannels     : i32,
          outShapeStrides : vec2<i32>,
        };

        @group(0) @binding(0) var<storage, read_write> result: array<${mapToWgslTypes(outputData.dtype, program.isVec4)}>;
        @group(0) @binding(2) var<uniform> uniforms: Uniform;
      `);
        return [
            commonSnippet,
            prefixSnippets.join('\n'),
            getCoordsFromIndexSnippet(outputData.shape),
            program.getUserCode(),
        ].join('\n');
    }
    let uniformDeclaration = 'struct Uniforms { NAN : f32, ';
    program.variableNames.forEach((x, i) => {
        const perDataType = getCoordsDataType(inputInfo[i].shape.length);
        uniformDeclaration +=
            `${x.charAt(0).toLowerCase() + x.slice(1)}Shape : ${perDataType}, `;
    });
    const outputDataType = getCoordsDataType(outputData.shape.length);
    uniformDeclaration += `outShape : ${outputDataType}, `;
    const stridesLength = outputData.shape.length - 1;
    const stridesDataType = getCoordsDataType(stridesLength);
    uniformDeclaration += `
         outShapeStrides: ${stridesDataType}, `;
    if (program.size) {
        uniformDeclaration += 'size : i32, ';
    }
    if (program.uniforms) {
        uniformDeclaration += program.uniforms;
    }
    uniformDeclaration += '};';
    uniformDeclaration = insertAlignment(uniformDeclaration);
    prefixSnippets.push(uniformDeclaration);
    // Output buffer.
    if (program.atomic) {
        prefixSnippets.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<atomic<i32>>;
    `);
    }
    else {
        prefixSnippets.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<${mapToWgslTypes(outputData.dtype, program.isVec4)}>;
    `);
    }
    program.variableNames.forEach((x, i) => {
        prefixSnippets.push(`
      @group(0) @binding(${1 + i}) var<storage, read> ${x}: array<${program.variableTypes ?
            program.variableTypes[i] :
            mapToWgslTypes(inputInfo[i].dtype, program.isVec4)}>;
        `);
    });
    if (uniformDeclaration !== '') {
        prefixSnippets.push(`
      @group(0) @binding(${1 + program.variableNames.length}) var<uniform> uniforms: Uniforms;
      `);
    }
    const coordsSnippet = getOutputCoordsSnippet(outputData.shape, program.dispatchLayout);
    const sources = [
        commonSnippet, prefixSnippets.join('\n'),
        getCoordsFromIndexSnippet(outputData.shape), coordsSnippet,
        getOutputIndexFromCoordsSnippet(outputData.shape.length)
    ];
    if (!program.atomic) {
        sources.push(setOutputSnippet(outputData.shape, outputData.dtype, program.isVec4));
    }
    const inputSnippet = inputInfo
        .map((x, i) => getInputSnippet(x, outputData.shape, program.variableTypes ?
        (program.variableTypes[i] === 'vec4<f32>') :
        program.isVec4, program.dispatchLayout.x.length === outputData.shape.length))
        .join('\n');
    sources.push(inputSnippet);
    sources.push(program.getUserCode());
    const source = sources.join('\n');
    return source;
}
export function makeShaderKey(program, shapes, inputsData, output) {
    let key = program.shaderKey;
    if (program.isFromPixels) {
        return key;
    }
    const types = inputsData.map(d => d.dtype).concat(output.dtype);
    const broadcastDims = inputsData.map(d => backend_util.getBroadcastDims(d.shape, output.shape));
    const inputShapesEqualsOutShape = inputsData.map(d => util.arraysEqual(d.shape, output.shape)).join('_');
    const broadcastDimsKey = broadcastDims.map(d => d.join('_')).join(';');
    const flatDispatchString = isFlatDispatch(program) ? 'flatDispatch' : '';
    key += '_' + (program.workGroupSize ? program.workGroupSize.join(',') : '') +
        shapes.map(shape => shape.length).join(',') + types.join(',') +
        program.variableNames.join(',') + broadcastDimsKey +
        inputShapesEqualsOutShape + flatDispatchString;
    return key;
}
const commonSnippet = `
  struct vec5 {x: i32, y: i32, z: i32, w: i32, u: i32};
  struct vec6 {x: i32, y: i32, z: i32, w: i32, u: i32, v: i32};

  // Checks whether coordinates lie within the bounds of the shape.
  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {
    return all(coord >= vec2<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {
    return all(coord >= vec3<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {
    return all(coord >= vec4<i32>(0)) && all(coord < shape);
  }

  fn getIndexFromCoords1D(coord : i32, shape : i32) -> i32 {
    return coord;
  }
  fn getIndexFromCoords2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {
    return dot(coords, vec2<i32>(shape.y, 1));
  }
  fn getIndexFromCoords3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {
    return dot(coords, vec3<i32>(shape.y * shape.z, shape.z, 1));
  }
  fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
    return dot(coords, vec4<i32>(
        shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
  }
  fn getIndexFromCoords5D(coords : vec5, shape : vec5) -> i32 {
    let shapeStrides: vec5 = vec5(shape.y * shape.z * shape.w * shape.u, shape.z * shape.w * shape.u, shape.w * shape.u, shape.u, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u;
  }
  fn getIndexFromCoords6D(coords : vec6, shape : vec6) -> i32 {
    let shapeStrides: vec6 = vec6(shape.y * shape.z * shape.w * shape.u * shape.v, shape.z * shape.w * shape.u * shape.v, shape.w * shape.u * shape.v, shape.u * shape.v, shape.v, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u + coords.v*shapeStrides.v;
  }

  fn idiv(a: i32, b: i32, sign: f32) -> i32 {
    var res: i32 = a / b;
    let modulo: i32 = a % b;
    if (sign < 0. && modulo != 0) {
      res = res - 1;
    }
    return res;
  }

  // NaN defination in IEEE 754-1985 is :
  //   - sign = either 0 or 1.
  //   - biased exponent = all 1 bits.
  //   - fraction = anything except all 0 bits (since all 0 bits represents infinity).
  // https://en.wikipedia.org/wiki/IEEE_754-1985#Representation_of_non-numbers
  fn isnan(val: f32) -> bool {
    let floatToUint: u32 = bitcast<u32>(val);
    return (floatToUint & 0x7fffffffu) > 0x7f800000u;
  }
  fn isnanVec4(val : vec4<f32>) -> vec4<bool> {
    return vec4<bool>(isnan(val[0]), isnan(val[1]), isnan(val[2]), isnan(val[3]));
  }
`;
/**
 * Derives logical coordinates from a flat index. Performs integer division
 * with each stride and decrements the index until the index equals the final
 * dimension coordinate.
 */
function getCoordsFromIndexSnippet(shape) {
    const rank = shape.length;
    if (rank <= 1) {
        return `fn getCoordsFromIndex(index : i32) -> i32 { return index; }`;
    }
    const strides = util.computeStrides(shape);
    const dtype = getCoordsDataType(rank);
    const coords = [];
    for (let i = 0; i < rank; i++) {
        coords.push(`d${i}`);
    }
    if (strides.length === 1) {
        return `    fn getCoordsFromIndex(index : i32) -> vec2<i32> {
      let d0 = index / uniforms.outShapeStrides; let d1 = index - d0 * uniforms.outShapeStrides;
      return vec2<i32>(d0, d1);
    }`;
    }
    let snippet;
    snippet = 'var index2 = index;' +
        strides
            .map((_, i) => {
            const line1 = `let ${coords[i]} = index2 / uniforms.outShapeStrides.${getCoordsXYZ(i)}`;
            const line2 = i === strides.length - 1 ?
                `let ${coords[i + 1]} = index2 - ${coords[i]} * uniforms.outShapeStrides.${getCoordsXYZ(i)}` :
                `index2 = index2 - ${coords[i]} * uniforms.outShapeStrides.${getCoordsXYZ(i)}`;
            return `${line1}; ${line2};`;
        })
            .join('');
    return `
    fn getCoordsFromIndex(index : i32) -> ${dtype} {
      ${snippet}
      return ${dtype}(${coords.join(',')});
    }
  `;
}
function getInputAtCoordsSnippet(inputInfo, isVec4) {
    const texName = inputInfo.name;
    const rank = inputInfo.shape.length;
    const type = getCoordsDataType(rank);
    const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    const dims = ['d0', 'd1', 'd2', 'd3', 'd4', 'd5'].slice(0, rank);
    const inputs = dims.map(d => `${d} : i32`).join(', ');
    if (rank < 1) {
        if (isVec4) {
            return `
        fn ${funcName}() -> vec4<f32> {
          return vec4<f32>(${texName}[0]);
        }
      `;
        }
        return `
      fn ${funcName}() ->f32 {
        return f32(${texName}[0]);
      }
    `;
    }
    const shapeStr = `uniforms.${texName.charAt(0).toLowerCase() + texName.slice(1)}Shape`;
    let rankStr = `${rank}D`;
    if (rank === 0) {
        rankStr = '1D';
    }
    if (isVec4) {
        return `
      fn ${funcName}(${inputs}) -> vec4<f32> {
        return vec4<f32>(${texName}[getIndexFromCoords${rankStr}(${type}(${dims.join(',')}),
          ${shapeStr}) / 4]);
      }
      `;
    }
    return `
    fn ${funcName}(${inputs}) -> f32 {
      return f32(${texName}[getIndexFromCoords${rankStr}(${type}(${dims.join(',')}),
        ${shapeStr})]);
    }
   `;
}
function getInputByOutputSnippet(inputInfo, outShape, isVec4, isFlatDispatchLayout) {
    const texName = inputInfo.name;
    const texFuncSnippet = texName.charAt(0).toUpperCase() + texName.slice(1);
    const funcName = 'get' + texFuncSnippet + 'ByOutput';
    const inRank = inputInfo.shape.length;
    const outRank = outShape.length;
    const type = getCoordsDataType(outRank);
    // If the inShape equals the outShape and the dispatch layout is flat, we can
    // directly use |gl_GlobalInvocationID.x| as the index and don't need coords
    // conversion between these two shapes.
    if (util.arraysEqual(inputInfo.shape, outShape) && isFlatDispatchLayout) {
        if (isVec4) {
            return `
      fn ${funcName}Index(globalIndex : i32) -> vec4<f32> {
        return vec4<f32>(${texName}[globalIndex]);
      }

      fn ${funcName}Coords(coords : ${type}) -> vec4<f32> {
        return vec4<f32>(${texName}[${outRank > 1 ? 'getOutputIndexFromCoords(coords)' : 'coords'} / 4]);
      }
      `;
        }
        else {
            return `
    fn ${funcName}Index(globalIndex : i32) -> f32 {
      return f32(${texName}[globalIndex]);
    }

    fn ${funcName}Coords(coords : ${type}) -> f32 {
      return f32(${texName}[${outRank > 1 ? 'getOutputIndexFromCoords(coords)' : 'coords'}]);
    }
    `;
        }
    }
    const broadcastDims = backend_util.getBroadcastDims(inputInfo.shape, outShape);
    const rankDiff = outRank - inRank;
    let coordsSnippet = '';
    if (inRank === 0) {
        if (isVec4) {
            return `
    fn ${funcName}Index(globalIndex : i32) -> vec4<f32> {
      return get${texFuncSnippet}();
    }

    fn ${funcName}Coords(coords : ${type}) -> vec4<f32> {
      return get${texFuncSnippet}();
    }
  `;
        }
        return `
    fn ${funcName}Index(globalIndex : i32) -> f32{
      return get${texFuncSnippet}();
    }

    fn ${funcName}Coords(coords : ${type}) -> f32{
      return get${texFuncSnippet}();
    }
  `;
    }
    else {
        if (outRank < 2 && broadcastDims.length >= 1) {
            coordsSnippet = 'coords = 0;';
        }
        else {
            coordsSnippet =
                broadcastDims.map(d => `coords.${getCoordsXYZ(d + rankDiff)} = 0;`)
                    .join('\n');
        }
    }
    let unpackedCoordsSnippet = '';
    if (outRank < 2 && inRank > 0) {
        unpackedCoordsSnippet = 'coords';
    }
    else {
        if (outRank > 1) {
            const coordsType = getCoordsDataType(inRank);
            const coordsValues = inputInfo.shape.map((s, i) => `coords.${getCoordsXYZ(i + rankDiff)}`)
                .join(', ');
            unpackedCoordsSnippet = `${coordsType}(${coordsValues})`;
        }
        else {
            unpackedCoordsSnippet = 'coords';
        }
    }
    const shapeStr = `uniforms.${texName.charAt(0).toLowerCase() + texName.slice(1)}Shape`;
    const rankStr = `${inRank}D`;
    if (isVec4) {
        return `
    fn ${funcName}Index(globalIndex : i32) -> vec4<f32> {
      var coords = getCoordsFromIndex(globalIndex);
      ${coordsSnippet}
      return ${texName}[getIndexFromCoords${rankStr}(${unpackedCoordsSnippet}, ${shapeStr}) / 4];
    }

    fn ${funcName}Coords(coordsIn : ${type}) -> vec4<f32> {
      var coords = coordsIn;
      ${coordsSnippet}
      return ${texName}[getIndexFromCoords${rankStr}(${unpackedCoordsSnippet}, ${shapeStr}) / 4];
    }
  `;
    }
    return `
  fn ${funcName}Index(globalIndex : i32) -> f32 {
    var coords = getCoordsFromIndex(globalIndex);
    ${coordsSnippet}
    return f32(${texName}[getIndexFromCoords${rankStr}(${unpackedCoordsSnippet}, ${shapeStr})]);
  }

  fn ${funcName}Coords(coordsIn : ${type}) -> f32 {
    var coords = coordsIn;
    ${coordsSnippet}
    return f32(${texName}[getIndexFromCoords${rankStr}(${unpackedCoordsSnippet}, ${shapeStr})]);
  }
`;
}
function getInputSnippet(inputInfo, outShape, isVec4, isFlatDispatchLayout) {
    let res = getInputAtCoordsSnippet(inputInfo, isVec4);
    const inShape = inputInfo.shape;
    if (inShape.length <= outShape.length) {
        res += getInputByOutputSnippet(inputInfo, outShape, isVec4, isFlatDispatchLayout);
    }
    return res;
}
/**
 * Generates getOutputCoords() function that computes output coordinates from
 * dispatch geometry to reduce arithmetic.
 */
function getOutputCoordsSnippet(outShape, dispatchLayout) {
    const { x, y = [], z = [] } = dispatchLayout;
    const outRank = outShape.length;
    const rank = x.length + y.length + z.length;
    // getOutputCoords is only meaningful when the output rank is same with
    // dispatch layout rank.
    if (rank !== outRank) {
        return '';
    }
    if (x.length === outRank) {
        const dtype = getCoordsDataType(outRank);
        const snippet = `fn getOutputCoords() -> ${dtype}{
    let globalIndex = getGlobalIndex();
    return getCoordsFromIndex(globalIndex);
  }
  `;
        return snippet;
    }
    let gatherDimensionsStr = '';
    const dims = [x, y, z];
    for (let i = 0; i < dims.length; i++) {
        const arr = dims[i];
        if (arr.length === 0) {
            continue;
        }
        if (arr.length === 1) {
            gatherDimensionsStr += `let d${arr[0]} = i32(globalId[${i}]);`;
        }
        else {
            const strides = symbolicallyComputeStrides(arr, 'uniforms.outShape');
            gatherDimensionsStr += `var index${i} = i32(globalId[${i}]);`;
            for (let j = 0; j < strides.length; j++) {
                gatherDimensionsStr += `let d${arr[j]} = index${i} / ${strides[j]};`;
                if (j === strides.length - 1) {
                    gatherDimensionsStr += `let d${arr[j + 1]} = ` +
                        `index${i} - d${arr[j]} * ${strides[j]};`;
                }
                else {
                    gatherDimensionsStr +=
                        `index${i} = index${i} - d${arr[j]} * ${strides[j]};`;
                }
            }
        }
    }
    const dimensions = [];
    for (let i = 0; i < rank; i++) {
        dimensions.push(`d${i}`);
    }
    const dtype = getCoordsDataType(rank);
    let snippet = `fn getOutputCoords() -> ${dtype} {
  ${gatherDimensionsStr}
`;
    if (dimensions.length === 0) {
        snippet += `return ${dtype}(0); }`;
    }
    else {
        snippet += `return ${dtype}(${dimensions.join(',')}); }`;
    }
    return snippet;
}
function getOutputIndexFromCoordsSnippet(outRank) {
    let snippet = '';
    switch (outRank) {
        case 0:
        case 1:
            snippet += `
        fn getOutputIndexFromCoords(coords : i32) -> i32 {
          return coords;
        }
        `;
            break;
        case 2:
            snippet += `
        fn getOutputIndexFromCoords(coords : vec2<i32>) -> i32 {
          return dot(coords, vec2<i32>(uniforms.outShapeStrides, 1));
        }
        `;
            break;
        case 3:
            snippet += `
        fn getOutputIndexFromCoords(coords : vec3<i32>) -> i32 {
          return dot(coords, vec3<i32>(uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, 1));
        }
        `;
            break;
        case 4:
            snippet += `
        fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
          return dot(coords, vec4<i32>(
            uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, uniforms.outShapeStrides.z, 1));
        }
        `;
            break;
        case 5:
            snippet += `
        fn getOutputIndexFromCoords(coords : vec5) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u;
        }
        `;
            break;
        case 6:
            snippet += `
        fn getOutputIndexFromCoords(coords : vec6) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u * uniforms.outShapeStrides.u +
              coords.v;
        }
        `;
            break;
        default:
            util.assert(false, () => `Unsupported ${outRank}D shape`);
            break;
    }
    return snippet;
}
function isFlatDispatch(program) {
    return program.dispatch[1] === 1 && program.dispatch[2] === 1;
}
export function mapToWgslTypes(type, isVec4) {
    if (type === 'float32') {
        return isVec4 ? 'vec4<f32>' : 'f32';
    }
    else if (type === 'int32') {
        return isVec4 ? 'vec4<i32>' : 'i32';
    }
    else if (type === 'bool') {
        // Type 'bool' cannot be used in storage class,
        // https://www.w3.org/TR/WGSL/#host-shareable-types.
        return isVec4 ? 'vec4<i32>' : 'i32';
    }
    return type;
}
function setOutputSnippet(outShape, outBufferType, isVec4) {
    const outRank = outShape.length;
    const wgslType = mapToWgslTypes(outBufferType, isVec4);
    let snippet;
    if (isVec4) {
        snippet = `fn setOutputAtIndex(flatIndex : i32, value : vec4<f32>) {
      result[flatIndex] = ${wgslType}(value);
    }
    fn setOutputAtIndexI32(flatIndex : i32, value : vec4<i32>) {
      result[flatIndex] = ${wgslType}(value);
    }`;
    }
    else {
        snippet = `fn setOutputAtIndex(flatIndex : i32, value : f32) {
      result[flatIndex] = ${wgslType}(value);
    }
    fn setOutputAtIndexI32(flatIndex : i32, value : i32) {
      result[flatIndex] = ${wgslType}(value);
    }`;
    }
    if (outRank >= 2) {
        const dims = ['d0', 'd1', 'd2', 'd3', 'd4', 'd5'].slice(0, outRank);
        const type = getCoordsDataType(outRank);
        if (isVec4) {
            snippet += `
      fn setOutputAtCoords(${dims.map(d => `${d} : i32`).join(', ')}, value : vec4<f32>) {
        let flatIndex = getOutputIndexFromCoords(${type}(${dims.join(', ')}));
        setOutputAtIndex(flatIndex / 4, value);
      }
      fn setOutputAtCoordsI32(${dims.map(d => `${d} : i32`).join(', ')}, value : vec4<i32>) {
        let flatIndex = getOutputIndexFromCoords(${type}(${dims.join(', ')}));
        setOutputAtIndexI32(flatIndex / 4, value);
      }
    `;
        }
        else {
            snippet += `
      fn setOutputAtCoords(${dims.map(d => `${d} : i32`).join(', ')}, value : f32) {
        let flatIndex = getOutputIndexFromCoords(${type}(${dims.join(', ')}));
        setOutputAtIndex(flatIndex, value);
      }
      fn setOutputAtCoordsI32(${dims.map(d => `${d} : i32`).join(', ')}, value : i32) {
        let flatIndex = getOutputIndexFromCoords(${type}(${dims.join(', ')}));
        setOutputAtIndexI32(flatIndex, value);
      }
    `;
        }
    }
    return snippet;
}
function insertAlignment(uniformShader) {
    // insert alignment when current pattern is vec5 or vec6
    const curInsertRe = /(\w+)\s*:\s*vec(5|6)/g;
    uniformShader = uniformShader.replace(curInsertRe, (match) => {
        return '@align(16) ' + match;
    });
    // insert alignment when previous pattern is vec5 or vec6
    const preInsertRe = /vec(5|6)\s*,\s*(\w+)/g;
    uniformShader = uniformShader.replace(preInsertRe, (_, p1, p2) => {
        return `vec${p1}, @align(16) ${p2}`;
    });
    return uniformShader;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2ViZ3B1X3Byb2dyYW0uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi90ZmpzLWJhY2tlbmQtd2ViZ3B1L3NyYy93ZWJncHVfcHJvZ3JhbS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFFSCxPQUFPLEVBQUMsWUFBWSxFQUF3QyxJQUFJLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQUUvRixPQUFPLEVBQUMsMEJBQTBCLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFrQ3pELE1BQU0sQ0FBQyxNQUFNLGNBQWMsR0FDdkIsQ0FBQyxNQUFpQixFQUFFLE9BQXNCLEVBQUUsVUFBdUIsRUFDbEUsTUFBa0IsRUFBc0IsRUFBRTtJQUN6QyxNQUFNLFVBQVUsR0FBRyxFQUFDLEtBQUssRUFBRSxNQUFNLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxNQUFNLENBQUMsS0FBSyxFQUFDLENBQUM7SUFDOUQsTUFBTSxNQUFNLEdBQUcsVUFBVSxDQUFDLFVBQVUsRUFBRSxVQUFVLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFDM0QsTUFBTSxNQUFNLEdBQUcsTUFBTSxDQUFDLGtCQUFrQixDQUNwQyxFQUFDLElBQUksRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLE9BQU8sQ0FBQyxXQUFXLENBQUMsSUFBSSxFQUFDLENBQUMsQ0FBQztJQUNyRCxNQUFNLFFBQVEsR0FBRyxNQUFNLENBQUMscUJBQXFCLENBQUM7UUFDNUMsT0FBTyxFQUFFLEVBQUMsTUFBTSxFQUFFLFVBQVUsRUFBRSxRQUFRLEVBQUM7UUFDdkMsS0FBSyxFQUFFLE9BQU8sQ0FBQyxXQUFXLENBQUMsSUFBSTtRQUMvQixNQUFNLEVBQUUsTUFBTTtLQUNmLENBQUMsQ0FBQztJQUVILE9BQU8sUUFBUSxDQUFDO0FBQ2xCLENBQUMsQ0FBQztBQUVOLE1BQU0sVUFBVSxpQkFBaUIsQ0FBQyxJQUFZO0lBQzVDLElBQUksSUFBSSxJQUFJLENBQUMs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LElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQzttREFDRyxJQUFJLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUM7OztnQ0FJaEUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDO21EQUNHLElBQUksSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQzs7O0tBR3JFLENBQUM7U0FDRDtLQUNGO0lBRUQsT0FBTyxPQUFPLENBQUM7QUFDakIsQ0FBQztBQUVELFNBQVMsZUFBZSxDQUFDLGFBQXFCO0lBQzVDLHdEQUF3RDtJQUN4RCxNQUFNLFdBQVcsR0FBRyx1QkFBdUIsQ0FBQztJQUM1QyxhQUFhLEdBQUcsYUFBYSxDQUFDLE9BQU8sQ0FBQyxXQUFXLEVBQUUsQ0FBQyxLQUFLLEVBQUUsRUFBRTtRQUMzRCxPQUFPLGFBQWEsR0FBRyxLQUFLLENBQUM7SUFDL0IsQ0FBQyxDQUFDLENBQUM7SUFFSCx5REFBeUQ7SUFDekQsTUFBTSxXQUFXLEdBQUcsdUJBQXVCLENBQUM7SUFDNUMsYUFBYSxHQUFHLGFBQWEsQ0FBQyxPQUFPLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRTtRQUMvRCxPQUFPLE1BQU0sRUFBRSxnQkFBZ0IsRUFBRSxFQUFFLENBQUM7SUFDdEMsQ0FBQyxDQUFDLENBQUM7SUFDSCxPQUFPLGFBQWEsQ0FBQztBQUN2QixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG5pbXBvcnQge2JhY2tlbmRfdXRpbCwgRGF0YVR5cGUsIFJhbmssIFNoYXBlTWFwLCBUZW5zb3JJbmZvLCB1dGlsfSBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xuXG5pbXBvcnQge3N5bWJvbGljYWxseUNvbXB1dGVTdHJpZGVzfSBmcm9tICcuL3NoYWRlcl91dGlsJztcblxuZXhwb3J0IGludGVyZmFjZSBXZWJHUFVQcm9ncmFtIHtcbiAgLy8gV2hldGhlciB0byB1c2UgYXRvbWljIGJ1aWx0LWluIGZ1bmN0aW9ucy5cbiAgYXRvbWljPzogYm9vbGVhbjtcbiAgLy8gZGlzcGF0Y2ggc3BlY2lmaWVzIGdlb21ldHJ5IG9mIHRocmVhZCBncm91cHMgLSBkZXJpdmVkIGZyb20gZGlzcGF0Y2hMYXlvdXQuXG4gIGRpc3BhdGNoOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG4gIC8vIGRpc3BhdGNoTGF5b3V0IGVudW1lcmF0ZXMgaG93IHRlbnNvciBkaW1lbnNpb25zIGFyZSBkaXN0cmlidXRlZCBhbW9uZ1xuICAvLyBkaXNwYXRjaCB4LHkseiBkaW1lbnNpb25zLlxuICBkaXNwYXRjaExheW91dDoge3g6IG51bWJlcltdLCB5PzogbnVtYmVyW10sIHo/OiBudW1iZXJbXX07XG4gIGlzRnJvbVBpeGVscz86IGJvb2xlYW47XG4gIGlzVmVjND86IGJvb2xlYW47XG4gIG91dHB1dFNoYXBlOiBudW1iZXJbXTtcbiAgLy8gVGhlIHVuaXF1ZSBrZXkgdG8gZGlzdGluZ3Vpc2ggZGlmZmVyZW50IHNoYWRlciBzb3VyY2UgY29kZS5cbiAgc2hhZGVyS2V5OiBzdHJpbmc7XG4gIC8vIFdoZXRoZXIgdG8gdXNlIG91dHB1dCBzaXplIGZvciBib3VuZHMgY2hlY2tpbmcuXG4gIHNpemU/OiBib29sZWFuO1xuICB1bmlmb3Jtcz86IHN0cmluZztcbiAgdmFyaWFibGVOYW1lczogc3RyaW5nW107XG4gIC8vIERlc2NyaWJlIGVhY2ggdmFyaWFibGUncyB0eXBlIGFuZCBtdXN0IGhhdmUgb25lLW9uZSBtYXBwaW5nIHdpdGhcbiAgLy8gdmFyaWFibGVOYW1lcy4gSWYgbm90IHNldCwgYWxsIHZhcmlhYmxlcyB0eXBlIHdpbGwgYmUgZWl0aGVyIGYzMiBvclxuICAvLyB2ZWM0PGYzMj4gYmFzZWQgb24gaXNWZWM0IG1lbWJlci5cbiAgdmFyaWFibGVUeXBlcz86IHN0cmluZ1tdO1xuICAvLyB3b3JrR3JvdXBTaXplLnggKiB3b3JrR3JvdXBTaXplLnkgKiB3b3JrR3JvdXBTaXplLnogPSB0aGUgbnVtYmVyIG9mIHRocmVhZHNcbiAgLy8gaW4gYSB0aHJlYWQgZ3JvdXAuIEluZGl2aWR1YWwgZGltZW5zaW9ucyBkZXRlcm1pbmVzIHRocmVhZCBsYXlvdXQgd2l0aGluXG4gIC8vIHRoZSBncm91cC5cbiAgd29ya0dyb3VwU2l6ZTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdO1xuICAvLyBTaXplIG9mIHJlZ2lzdGVyIGNhY2hlIGluIG9uZSBkaW1lbnNpb24gKGFzc3VtZXMgc3F1YXJlIGNhY2hlKS5cbiAgLy8gRWFjaCB0aHJlYWQgd3JpdGVzIHRvIHdvcmtQZXJUaHJlYWQgKiB3b3JrUGVyVGhyZWFkIGxvY2F0aW9ucyBpbiB0aGUgb3V0cHV0XG4gIC8vIGJ1ZmZlci5cbiAgd29ya1BlclRocmVhZD86IG51bWJlcjtcbiAgZ2V0VXNlckNvZGU6ICgpID0+IHN0cmluZztcbn1cblxuZXhwb3J0IGNvbnN0IGNvbXBpbGVQcm9ncmFtID1cbiAgICAoZGV2aWNlOiBHUFVEZXZpY2UsIHByb2dyYW06IFdlYkdQVVByb2dyYW0sIGlucHV0c0RhdGE6IElucHV0SW5mb1tdLFxuICAgICBvdXRwdXQ6IFRlbnNvckluZm8pOiBHUFVDb21wdXRlUGlwZWxpbmUgPT4ge1xuICAgICAgY29uc3Qgb3V0cHV0RGF0YSA9IHtkdHlwZTogb3V0cHV0LmR0eXBlLCBzaGFwZTogb3V0cHV0LnNoYXBlfTtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IG1ha2VTaGFkZXIoaW5wdXRzRGF0YSwgb3V0cHV0RGF0YSwgcHJvZ3JhbSk7XG4gICAgICBjb25zdCBtb2R1bGUgPSBkZXZpY2UuY3JlYXRlU2hhZGVyTW9kdWxlKFxuICAgICAgICAgIHtjb2RlOiBzb3VyY2UsIGxhYmVsOiBwcm9ncmFtLmNvbnN0cnVjdG9yLm5hbWV9KTtcbiAgICAgIGNvbnN0IHBpcGVsaW5lID0gZGV2aWNlLmNyZWF0ZUNvbXB1dGVQaXBlbGluZSh7XG4gICAgICAgIGNvbXB1dGU6IHttb2R1bGUsIGVudHJ5UG9pbnQ6ICdfc3RhcnQnfSxcbiAgICAgICAgbGFiZWw6IHByb2dyYW0uY29uc3RydWN0b3IubmFtZSxcbiAgICAgICAgbGF5b3V0OiAnYXV0bydcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gcGlwZWxpbmU7XG4gICAgfTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldENvb3Jkc0RhdGFUeXBlKHJhbms6IG51bWJlcik6IHN0cmluZyB7XG4gIGlmIChyYW5rIDw9IDEpIHtcbiAgICByZXR1cm4gJ2kzMic7XG4gIH0gZWxzZSBpZiAocmFuayA9PT0gMikge1xuICAgIHJldHVybiBgdmVjMjxpMzI+YDtcbiAgfSBlbHNlIGlmIChyYW5rID09PSAzKSB7XG4gICAgcmV0dXJuIGB2ZWMzPGkzMj5gO1xuICB9IGVsc2UgaWYgKHJhbmsgPT09IDQpIHtcbiAgICByZXR1cm4gYHZlYzQ8aTMyPmA7XG4gIH0gZWxzZSBpZiAocmFuayA9PT0gNSkge1xuICAgIHJldHVybiBgdmVjNWA7XG4gIH0gZWxzZSBpZiAocmFuayA9PT0gNikge1xuICAgIHJldHVybiBgdmVjNmA7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgRXJyb3IoYEdQVSBmb3IgcmFuayAke3Jhbmt9IGlzIG5vdCB5ZXQgc3VwcG9ydGVkYCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldENvb3Jkc1hZWihpbmRleDogbnVtYmVyKTogc3RyaW5nIHtcbiAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgcmV0dXJuICd4JztcbiAgfSBlbHNlIGlmIChpbmRleCA9PT0gMSkge1xuICAgIHJldHVybiAneSc7XG4gIH0gZWxzZSBpZiAoaW5kZXggPT09IDIpIHtcbiAgICByZXR1cm4gJ3onO1xuICB9IGVsc2UgaWYgKGluZGV4ID09PSAzKSB7XG4gICAgcmV0dXJuICd3JztcbiAgfSBlbHNlIGlmIChpbmRleCA9PT0gNCkge1xuICAgIHJldHVybiAndSc7XG4gIH0gZWxzZSBpZiAoaW5kZXggPT09IDUpIHtcbiAgICByZXR1cm4gJ3YnO1xuICB9IGVsc2Uge1xuICAgIHRocm93IEVycm9yKGBJbmRleCAke2luZGV4fSBpcyBub3QgeWV0IHN1cHBvcnRlZGApO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRNYWluSGVhZGVyU3RyaW5nKCk6IHN0cmluZztcbmV4cG9ydCBmdW5jdGlvbiBnZXRNYWluSGVhZGVyU3RyaW5nKGluZGV4OiBzdHJpbmcpOiBzdHJpbmc7XG5leHBvcnQgZnVuY3Rpb24gZ2V0TWFpbkhlYWRlclN0cmluZyguLi5wYXJhbXM6IHN0cmluZ1tdKTogc3RyaW5nIHtcbiAgbGV0IHNuaXBwZXQ6IHN0cmluZztcbiAgc3dpdGNoIChwYXJhbXMubGVuZ3RoKSB7XG4gICAgY2FzZSAwOlxuICAgICAgc25pcHBldCA9IGBcbiAgICAgICAgJHtnZXRXb3JrR3JvdXBTaXplU3RyaW5nKCl9XG4gICAgICAgIGZuIF9zdGFydChAYnVpbHRpbihsb2NhbF9pbnZvY2F0aW9uX2lkKSBMb2NhbElkIDogdmVjMzx1MzI+LFxuICAgICAgICAgICAgICAgICAgQGJ1aWx0aW4oZ2xvYmFsX2ludm9jYXRpb25faWQpIEdsb2JhbElkIDogdmVjMzx1MzI+LFxuICAgICAgICAgICAgICAgICAgQGJ1aWx0aW4obnVtX3dvcmtncm91cHMpIE51bVdvcmtncm91cHMgOiB2ZWMzPHUzMj4pIHtcbiAgICAgICAgICBsb2NhbElkID0gTG9jYWxJZDtcbiAgICAgICAgICBnbG9iYWxJZCA9IEdsb2JhbElkO1xuICAgICAgICAgIG51bVdvcmtncm91cHMgPSBOdW1Xb3JrZ3JvdXBzO1xuICAgICAgICAgIG1haW4oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZuIG1haW4oKVxuICAgICAgYDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTpcbiAgICAgIHNuaXBwZXQgPSBgXG4gICAgICAgICR7Z2V0V29ya0dyb3VwU2l6ZVN0cmluZygpfVxuICAgICAgICBmbiBfc3RhcnQoQGJ1aWx0aW4obG9jYWxfaW52b2NhdGlvbl9pZCkgTG9jYWxJZCA6IHZlYzM8dTMyPixcbiAgICAgICAgICAgICAgICAgIEBidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKSBHbG9iYWxJZCA6IHZlYzM8dTMyPixcbiAgICAgICAgICAgICAgICAgIEBidWlsdGluKG51bV93b3JrZ3JvdXBzKSBOdW1Xb3JrZ3JvdXBzIDogdmVjMzx1MzI+KSB7XG4gICAgICAgICAgbG9jYWxJZCA9IExvY2FsSWQ7XG4gICAgICAgICAgZ2xvYmFsSWQgPSBHbG9iYWxJZDtcbiAgICAgICAgICBudW1Xb3JrZ3JvdXBzID0gTnVtV29ya2dyb3VwcztcbiAgICAgICAgICBtYWluKGdldEdsb2JhbEluZGV4KCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm4gbWFpbigke3BhcmFtc1swXX0gOiBpMzIpXG4gICAgICBgO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IEVycm9yKCdVbnJlYWNoYWJsZScpO1xuICB9XG4gIHJldHVybiBzbmlwcGV0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0V29ya0dyb3VwU2l6ZVN0cmluZygpOiBzdHJpbmcge1xuICByZXR1cm4gYFxuICBAY29tcHV0ZSBAd29ya2dyb3VwX3NpemUod29ya0dyb3VwU2l6ZVgsIHdvcmtHcm91cFNpemVZLCB3b3JrR3JvdXBTaXplWilcbmA7XG59XG5cbmZ1bmN0aW9uIG1ha2VTaGFkZXIoXG4gICAgaW5wdXRJbmZvOiBJbnB1dEluZm9bXSwgb3V0cHV0RGF0YToge2R0eXBlOiBEYXRhVHlwZSwgc2hhcGU6IG51bWJlcltdfSxcbiAgICBwcm9ncmFtOiBXZWJHUFVQcm9ncmFtKTogc3RyaW5nIHtcbiAgY29uc3QgcHJlZml4U25pcHBldHM6IHN0cmluZ1tdID0gW107XG4gIHByZWZpeFNuaXBwZXRzLnB1c2goYFxuICAgICAgY29uc3Qgd29ya0dyb3VwU2l6ZVggPSAke3Byb2dyYW0ud29ya0dyb3VwU2l6ZVswXX11O1xuICAgICAgY29uc3Qgd29ya0dyb3VwU2l6ZVkgPSAke3Byb2dyYW0ud29ya0dyb3VwU2l6ZVsxXX11O1xuICAgICAgY29uc3Qgd29ya0dyb3VwU2l6ZVogPSAke3Byb2dyYW0ud29ya0dyb3VwU2l6ZVsyXX11O1xuXG4gICAgICB2YXI8cHJpdmF0ZT4gbG9jYWxJZDogdmVjMzx1MzI+O1xuICAgICAgdmFyPHByaXZhdGU+IGdsb2JhbElkOiB2ZWMzPHUzMj47XG4gICAgICB2YXI8cHJpdmF0ZT4gbnVtV29ya2dyb3VwczogdmVjMzx1MzI+O1xuXG4gICAgICAvLyBPbmx5IHVzZWQgd2hlbiB0aGUgeS96IGRpbWVuc2lvbiBvZiB3b3JrZ3JvdXAgc2l6ZSBpcyAxLlxuICAgICAgZm4gZ2V0R2xvYmFsSW5kZXgoKSAtPiBpMzIge1xuICAgICAgICAke1xuICAgICAgaXNGbGF0RGlzcGF0Y2gocHJvZ3JhbSkgP1xuICAgICAgICAgIGAgIHJldHVybiBpMzIoZ2xvYmFsSWQueCk7YCA6XG4gICAgICAgICAgYCAgbGV0IGxvY2FsSW52b2NhdGlvbkluZGV4ID0gbG9jYWxJZC56ICogd29ya0dyb3VwU2l6ZVggKiB3b3JrR3JvdXBTaXplWSArXG4gICAgICAgICAgICAgICAgICAgbG9jYWxJZC55ICogd29ya0dyb3VwU2l6ZVggKyBsb2NhbElkLng7XG4gICAgICAgICAgICAgICBsZXQgd29ya0dyb3VwSUQgPSAoZ2xvYmFsSWQgLSBsb2NhbElkKS92ZWMzPHUzMj4oXG4gICAgICAgICAgICAgICAgICAgd29ya0dyb3VwU2l6ZVgsIHdvcmtHcm91cFNpemVZLCB3b3JrR3JvdXBTaXplWik7XG5cbiAgICAgICAgICAgICAgIHJldHVybiBpMzIoKHdvcmtHcm91cElELnogKiBudW1Xb3JrZ3JvdXBzLnggKiBudW1Xb3JrZ3JvdXBzLnkgK1xuICAgICAgICAgICAgICAgICAgIHdvcmtHcm91cElELnkgKiBudW1Xb3JrZ3JvdXBzLnggKyB3b3JrR3JvdXBJRC54KSAqXG4gICAgICAgICAgICAgICAgICAgKHdvcmtHcm91cFNpemVYICogd29ya0dyb3VwU2l6ZVkgKiB3b3JrR3JvdXBTaXplWikgK1xuICAgICAgICAgICAgICAgICAgIGxvY2FsSW52b2NhdGlvbkluZGV4KTtcbiAgICAgICAgYH1cbiAgICAgIH1cbiAgICBgKTtcblxuICBpZiAocHJvZ3JhbS5pc0Zyb21QaXhlbHMpIHtcbiAgICBwcmVmaXhTbmlwcGV0cy5wdXNoKGBcbiAgICAgICAgc3RydWN0IFVuaWZvcm0ge1xuICAgICAgICAgIHNpemUgICAgICAgICAgICA6IGkzMixcbiAgICAgICAgICBudW1DaGFubmVscyAgICAgOiBpMzIsXG4gICAgICAgICAgb3V0U2hhcGVTdHJpZGVzIDogdmVjMjxpMzI+LFxuICAgICAgICB9O1xuXG4gICAgICAgIEBncm91cCgwKSBAYmluZGluZygwKSB2YXI8c3RvcmFnZSwgcmVhZF93cml0ZT4gcmVzdWx0OiBhcnJheTwke1xuICAgICAgICBtYXBUb1dnc2xUeXBlcyhvdXRwdXREYXRhLmR0eXBlLCBwcm9ncmFtLmlzVmVjNCl9PjtcbiAgICAgICAgQGdyb3VwKDApIEBiaW5kaW5nKDIpIHZhcjx1bmlmb3JtPiB1bmlmb3JtczogVW5pZm9ybTtcbiAgICAgIGApO1xuICAgIHJldHVybiBbXG4gICAgICBjb21tb25TbmlwcGV0LFxuICAgICAgcHJlZml4U25pcHBldHMuam9pbignXFxuJyksXG4gICAgICBnZXRDb29yZHNGcm9tSW5kZXhTbmlwcGV0KG91dHB1dERhdGEuc2hhcGUpLFxuICAgICAgcHJvZ3JhbS5nZXRVc2VyQ29kZSgpLFxuICAgIF0uam9pbignXFxuJyk7XG4gIH1cblxuICBsZXQgdW5pZm9ybURlY2xhcmF0aW9uID0gJ3N0cnVjdCBVbmlmb3JtcyB7IE5BTiA6IGYzMiwgJztcbiAgcHJvZ3JhbS52YXJpYWJsZU5hbWVzLmZvckVhY2goKHgsIGkpID0+IHtcbiAgICBjb25zdCBwZXJEYXRhVHlwZSA9IGdldENvb3Jkc0RhdGFUeXBlKGlucHV0SW5mb1tpXS5zaGFwZS5sZW5ndGgpO1xuICAgIHVuaWZvcm1EZWNsYXJhdGlvbiArPVxuICAgICAgICBgJHt4LmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpICsgeC5zbGljZSgxKX1TaGFwZSA6ICR7cGVyRGF0YVR5cGV9LCBgO1xuICB9KTtcbiAgY29uc3Qgb3V0cHV0RGF0YVR5cGUgPSBnZXRDb29yZHNEYXRhVHlwZShvdXRwdXREYXRhLnNoYXBlLmxlbmd0aCk7XG4gIHVuaWZvcm1EZWNsYXJhdGlvbiArPSBgb3V0U2hhcGUgOiAke291dHB1dERhdGFUeXBlfSwgYDtcbiAgY29uc3Qgc3RyaWRlc0xlbmd0aCA9IG91dHB1dERhdGEuc2hhcGUubGVuZ3RoIC0gMTtcbiAgY29uc3Qgc3RyaWRlc0RhdGFUeXBlID0gZ2V0Q29vcmRzRGF0YVR5cGUoc3RyaWRlc0xlbmd0aCk7XG4gIHVuaWZvcm1EZWNsYXJhdGlvbiArPSBgXG4gICAgICAgICBvdXRTaGFwZVN0cmlkZXM6ICR7c3RyaWRlc0RhdGFUeXBlfSwgYDtcblxuICBpZiAocHJvZ3JhbS5zaXplKSB7XG4gICAgdW5pZm9ybURlY2xhcmF0aW9uICs9ICdzaXplIDogaTMyLCAnO1xuICB9XG5cbiAgaWYgKHByb2dyYW0udW5pZm9ybXMpIHtcbiAgICB1bmlmb3JtRGVjbGFyYXRpb24gKz0gcHJvZ3JhbS51bmlmb3JtcztcbiAgfVxuICB1bmlmb3JtRGVjbGFyYXRpb24gKz0gJ307JztcbiAgdW5pZm9ybURlY2xhcmF0aW9uID0gaW5zZXJ0QWxpZ25tZW50KHVuaWZvcm1EZWNsYXJhdGlvbik7XG5cbiAgcHJlZml4U25pcHBldHMucHVzaCh1bmlmb3JtRGVjbGFyYXRpb24pO1xuXG4gIC8vIE91dHB1dCBidWZmZXIuXG4gIGlmIChwcm9ncmFtLmF0b21pYykge1xuICAgIHByZWZpeFNuaXBwZXRzLnB1c2goYFxuICAgICAgQGdyb3VwKDApIEBiaW5kaW5nKDApIHZhcjxzdG9yYWdlLCByZWFkX3dyaXRlPiByZXN1bHQ6IGFycmF5PGF0b21pYzxpMzI+PjtcbiAgICBgKTtcbiAgfSBlbHNlIHtcbiAgICBwcmVmaXhTbmlwcGV0cy5wdXNoKGBcbiAgICAgIEBncm91cCgwKSBAYmluZGluZygwKSB2YXI8c3RvcmFnZSwgcmVhZF93cml0ZT4gcmVzdWx0OiBhcnJheTwke1xuICAgICAgICBtYXBUb1dnc2xUeXBlcyhvdXRwdXREYXRhLmR0eXBlLCBwcm9ncmFtLmlzVmVjNCl9PjtcbiAgICBgKTtcbiAgfVxuICBwcm9ncmFtLnZhcmlhYmxlTmFtZXMuZm9yRWFjaCgoeCwgaSkgPT4ge1xuICAgIHByZWZpeFNuaXBwZXRzLnB1c2goYFxuICAgICAgQGdyb3VwKDApIEBiaW5kaW5nKCR7MSArIGl9KSB2YXI8c3RvcmFnZSwgcmVhZD4gJHt4fTogYXJyYXk8JHtcbiAgICAgICAgcHJvZ3JhbS52YXJpYWJsZVR5cGVzID9cbiAgICAgICAgICAgIHByb2dyYW0udmFyaWFibGVUeXBlc1tpXSA6XG4gICAgICAgICAgICBtYXBUb1dnc2xUeXBlcyhpbnB1dEluZm9baV0uZHR5cGUsIHByb2dyYW0uaXNWZWM0KX0+O1xuICAgICAgICBgKTtcbiAgfSk7XG5cbiAgaWYgKHVuaWZvcm1EZWNsYXJhdGlvbiAhPT0gJycpIHtcbiAgICBwcmVmaXhTbmlwcGV0cy5wdXNoKGBcbiAgICAgIEBncm91cCgwKSBAYmluZGluZygke1xuICAgICAgICAxICsgcHJvZ3JhbS52YXJpYWJsZU5hbWVzLmxlbmd0aH0pIHZhcjx1bmlmb3JtPiB1bmlmb3JtczogVW5pZm9ybXM7XG4gICAgICBgKTtcbiAgfVxuXG4gIGNvbnN0IGNvb3Jkc1NuaXBwZXQgPVxuICAgICAgZ2V0T3V0cHV0Q29vcmRzU25pcHBldChvdXRwdXREYXRhLnNoYXBlLCBwcm9ncmFtLmRpc3BhdGNoTGF5b3V0KTtcblxuICBjb25zdCBzb3VyY2VzID0gW1xuICAgIGNvbW1vblNuaXBwZXQsIHByZWZpeFNuaXBwZXRzLmpvaW4oJ1xcbicpLFxuICAgIGdldENvb3Jkc0Zyb21JbmRleFNuaXBwZXQob3V0cHV0RGF0YS5zaGFwZSksIGNvb3Jkc1NuaXBwZXQsXG4gICAgZ2V0T3V0cHV0SW5kZXhGcm9tQ29vcmRzU25pcHBldChvdXRwdXREYXRhLnNoYXBlLmxlbmd0aClcbiAgXTtcbiAgaWYgKCFwcm9ncmFtLmF0b21pYykge1xuICAgIHNvdXJjZXMucHVzaChcbiAgICAgICAgc2V0T3V0cHV0U25pcHBldChvdXRwdXREYXRhLnNoYXBlLCBvdXRwdXREYXRhLmR0eXBlLCBwcm9ncmFtLmlzVmVjNCkpO1xuICB9XG5cbiAgY29uc3QgaW5wdXRTbmlwcGV0ID1cbiAgICAgIGlucHV0SW5mb1xuICAgICAgICAgIC5tYXAoXG4gICAgICAgICAgICAgICh4LCBpKSA9PiBnZXRJbnB1dFNuaXBwZXQoXG4gICAgICAgICAgICAgICAgICB4LCBvdXRwdXREYXRhLnNoYXBlLFxuICAgICAgICAgICAgICAgICAgcHJvZ3JhbS52YXJpYWJsZVR5cGVzID9cbiAgICAgICAgICAgICAgICAgICAgICAocHJvZ3JhbS52YXJpYWJsZVR5cGVzW2ldID09PSAndmVjNDxmMzI+JykgOlxuICAgICAgICAgICAgICAgICAgICAgIHByb2dyYW0uaXNWZWM0LFxuICAgICAgICAgICAgICAgICAgcHJvZ3JhbS5kaXNwYXRjaExheW91dC54Lmxlbmd0aCA9PT0gb3V0cHV0RGF0YS5zaGFwZS5sZW5ndGgpKVxuICAgICAgICAgIC5qb2luKCdcXG4nKTtcbiAgc291cmNlcy5wdXNoKGlucHV0U25pcHBldCk7XG5cbiAgc291cmNlcy5wdXNoKHByb2dyYW0uZ2V0VXNlckNvZGUoKSk7XG4gIGNvbnN0IHNvdXJjZSA9IHNvdXJjZXMuam9pbignXFxuJyk7XG4gIHJldHVybiBzb3VyY2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYWtlU2hhZGVyS2V5PFIgZXh0ZW5kcyBSYW5rPihcbiAgICBwcm9ncmFtOiBXZWJHUFVQcm9ncmFtLCBzaGFwZXM6IEFycmF5PFNoYXBlTWFwW1JdPiwgaW5wdXRzRGF0YTogSW5wdXRJbmZvW10sXG4gICAgb3V0cHV0OiBUZW5zb3JJbmZvKTogc3RyaW5nIHtcbiAgbGV0IGtleSA9IHByb2dyYW0uc2hhZGVyS2V5O1xuICBpZiAocHJvZ3JhbS5pc0Zyb21QaXhlbHMpIHtcbiAgICByZXR1cm4ga2V5O1xuICB9XG5cbiAgY29uc3QgdHlwZXMgPSBpbnB1dHNEYXRhLm1hcChkID0+IGQuZHR5cGUpLmNvbmNhdChvdXRwdXQuZHR5cGUpO1xuICBjb25zdCBicm9hZGNhc3REaW1zID1cbiAgICAgIGlucHV0c0RhdGEubWFwKGQgPT4gYmFja2VuZF91dGlsLmdldEJyb2FkY2FzdERpbXMoZC5zaGFwZSwgb3V0cHV0LnNoYXBlKSk7XG4gIGNvbnN0IGlucHV0U2hhcGVzRXF1YWxzT3V0U2hhcGUgPVxuICAgICAgaW5wdXRzRGF0YS5tYXAoZCA9PiB1dGlsLmFycmF5c0VxdWFsKGQuc2hhcGUsIG91dHB1dC5zaGFwZSkpLmpvaW4oJ18nKTtcbiAgY29uc3QgYnJvYWRjYXN0RGltc0tleSA9IGJyb2FkY2FzdERpbXMubWFwKGQgPT4gZC5qb2luKCdfJykpLmpvaW4oJzsnKTtcblxuICBjb25zdCBmbGF0RGlzcGF0Y2hTdHJpbmcgPSBpc0ZsYXREaXNwYXRjaChwcm9ncmFtKSA/ICdmbGF0RGlzcGF0Y2gnIDogJyc7XG5cbiAga2V5ICs9ICdfJyArIChwcm9ncmFtLndvcmtHcm91cFNpemUgPyBwcm9ncmFtLndvcmtHcm91cFNpemUuam9pbignLCcpIDogJycpICtcbiAgICAgIHNoYXBlcy5tYXAoc2hhcGUgPT4gc2hhcGUubGVuZ3RoKS5qb2luKCcsJykgKyB0eXBlcy5qb2luKCcsJykgK1xuICAgICAgcHJvZ3JhbS52YXJpYWJsZU5hbWVzLmpvaW4oJywnKSArIGJyb2FkY2FzdERpbXNLZXkgK1xuICAgICAgaW5wdXRTaGFwZXNFcXVhbHNPdXRTaGFwZSArIGZsYXREaXNwYXRjaFN0cmluZztcblxuICByZXR1cm4ga2V5O1xufVxuXG5jb25zdCBjb21tb25TbmlwcGV0ID0gYFxuICBzdHJ1Y3QgdmVjNSB7eDogaTMyLCB5OiBpMzIsIHo6IGkzMiwgdzogaTMyLCB1OiBpMzJ9O1xuICBzdHJ1Y3QgdmVjNiB7eDogaTMyLCB5OiBpMzIsIHo6IGkzMiwgdzogaTMyLCB1OiBpMzIsIHY6IGkzMn07XG5cbiAgLy8gQ2hlY2tzIHdoZXRoZXIgY29vcmRpbmF0ZXMgbGllIHdpdGhpbiB0aGUgYm91bmRzIG9mIHRoZSBzaGFwZS5cbiAgZm4gY29vcmRzSW5Cb3VuZHMyRChjb29yZCA6IHZlYzI8aTMyPiwgc2hhcGUgOiB2ZWMyPGkzMj4pIC0+IGJvb2wge1xuICAgIHJldHVybiBhbGwoY29vcmQgPj0gdmVjMjxpMzI+KDApKSAmJiBhbGwoY29vcmQgPCBzaGFwZSk7XG4gIH1cbiAgZm4gY29vcmRzSW5Cb3VuZHMzRChjb29yZCA6IHZlYzM8aTMyPiwgc2hhcGUgOiB2ZWMzPGkzMj4pIC0+IGJvb2wge1xuICAgIHJldHVybiBhbGwoY29vcmQgPj0gdmVjMzxpMzI+KDApKSAmJiBhbGwoY29vcmQgPCBzaGFwZSk7XG4gIH1cbiAgZm4gY29vcmRzSW5Cb3VuZHM0RChjb29yZCA6IHZlYzQ8aTMyPiwgc2hhcGUgOiB2ZWM0PGkzMj4pIC0+IGJvb2wge1xuICAgIHJldHVybiBhbGwoY29vcmQgPj0gdmVjNDxpMzI+KDApKSAmJiBhbGwoY29vcmQgPCBzaGFwZSk7XG4gIH1cblxuICBmbiBnZXRJbmRleEZyb21Db29yZHMxRChjb29yZCA6IGkzMiwgc2hhcGUgOiBpMzIpIC0+IGkzMiB7XG4gICAgcmV0dXJuIGNvb3JkO1xuICB9XG4gIGZuIGdldEluZGV4RnJvbUNvb3JkczJEKGNvb3JkcyA6IHZlYzI8aTMyPiwgc2hhcGUgOiB2ZWMyPGkzMj4pIC0+IGkzMiB7XG4gICAgcmV0dXJuIGRvdChjb29yZHMsIHZlYzI8aTMyPihzaGFwZS55LCAxKSk7XG4gIH1cbiAgZm4gZ2V0SW5kZXhGcm9tQ29vcmRzM0QoY29vcmRzIDogdmVjMzxpMzI+LCBzaGFwZSA6IHZlYzM8aTMyPikgLT4gaTMyIHtcbiAgICByZXR1cm4gZG90KGNvb3JkcywgdmVjMzxpMzI+KHNoYXBlLnkgKiBzaGFwZS56LCBzaGFwZS56LCAxKSk7XG4gIH1cbiAgZm4gZ2V0SW5kZXhGcm9tQ29vcmRzNEQoY29vcmRzIDogdmVjNDxpMzI+LCBzaGFwZSA6IHZlYzQ8aTMyPikgLT4gaTMyIHtcbiAgICByZXR1cm4gZG90KGNvb3JkcywgdmVjNDxpMzI+KFxuICAgICAgICBzaGFwZS55ICogc2hhcGUueiAqIHNoYXBlLncsIHNoYXBlLnogKiBzaGFwZS53LCBzaGFwZS53LCAxKSk7XG4gIH1cbiAgZm4gZ2V0SW5kZXhGcm9tQ29vcmRzNUQoY29vcmRzIDogdmVjNSwgc2hhcGUgOiB2ZWM1KSAtPiBpMzIge1xuICAgIGxldCBzaGFwZVN0cmlkZXM6IHZlYzUgPSB2ZWM1KHNoYXBlLnkgKiBzaGFwZS56ICogc2hhcGUudyAqIHNoYXBlLnUsIHNoYXBlLnogKiBzaGFwZS53ICogc2hhcGUudSwgc2hhcGUudyAqIHNoYXBlLnUsIHNoYXBlLnUsIDEpO1xuICAgIHJldHVybiBjb29yZHMueCpzaGFwZVN0cmlkZXMueCArIGNvb3Jkcy55KnNoYXBlU3RyaWRlcy55ICsgY29vcmRzLnoqc2hhcGVTdHJpZGVzLnogKyBjb29yZHMudypzaGFwZVN0cmlkZXMudyArIGNvb3Jkcy51KnNoYXBlU3RyaWRlcy51O1xuICB9XG4gIGZuIGdldEluZGV4RnJvbUNvb3JkczZEKGNvb3JkcyA6IHZlYzYsIHNoYXBlIDogdmVjNikgLT4gaTMyIHtcbiAgICBsZXQgc2hhcGVTdHJpZGVzOiB2ZWM2ID0gdmVjNihzaGFwZS55ICogc2hhcGUueiAqIHNoYXBlLncgKiBzaGFwZS51ICogc2hhcGUudiwgc2hhcGUueiAqIHNoYXBlLncgKiBzaGFwZS51ICogc2hhcGUudiwgc2hhcGUudyAqIHNoYXBlLnUgKiBzaGFwZS52LCBzaGFwZS51ICogc2hhcGUudiwgc2hhcGUudiwgMSk7XG4gICAgcmV0dXJuIGNvb3Jkcy54KnNoYXBlU3RyaWRlcy54ICsgY29vcmRzLnkqc2hhcGVTdHJpZGVzLnkgKyBjb29yZHMueipzaGFwZVN0cmlkZXMueiArIGNvb3Jkcy53KnNoYXBlU3RyaWRlcy53ICsgY29vcmRzLnUqc2hhcGVTdHJpZGVzLnUgKyBjb29yZHMudipzaGFwZVN0cmlkZXMudjtcbiAgfVxuXG4gIGZuIGlkaXYoYTogaTMyLCBiOiBpMzIsIHNpZ246IGYzMikgLT4gaTMyIHtcbiAgICB2YXIgcmVzOiBpMzIgPSBhIC8gYjtcbiAgICBsZXQgbW9kdWxvOiBpMzIgPSBhICUgYjtcbiAgICBpZiAoc2lnbiA8IDAuICYmIG1vZHVsbyAhPSAwKSB7XG4gICAgICByZXMgPSByZXMgLSAxO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgLy8gTmFOIGRlZmluYXRpb24gaW4gSUVFRSA3NTQtMTk4NSBpcyA6XG4gIC8vICAgLSBzaWduID0gZWl0aGVyIDAgb3IgMS5cbiAgLy8gICAtIGJpYXNlZCBleHBvbmVudCA9IGFsbCAxIGJpdHMuXG4gIC8vICAgLSBmcmFjdGlvbiA9IGFueXRoaW5nIGV4Y2VwdCBhbGwgMCBiaXRzIChzaW5jZSBhbGwgMCBiaXRzIHJlcHJlc2VudHMgaW5maW5pdHkpLlxuICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JRUVFXzc1NC0xOTg1I1JlcHJlc2VudGF0aW9uX29mX25vbi1udW1iZXJzXG4gIGZuIGlzbmFuKHZhbDogZjMyKSAtPiBib29sIHtcbiAgICBsZXQgZmxvYXRUb1VpbnQ6IHUzMiA9IGJpdGNhc3Q8dTMyPih2YWwpO1xuICAgIHJldHVybiAoZmxvYXRUb1VpbnQgJiAweDdmZmZmZmZmdSkgPiAweDdmODAwMDAwdTtcbiAgfVxuICBmbiBpc25hblZlYzQodmFsIDogdmVjNDxmMzI+KSAtPiB2ZWM0PGJvb2w+IHtcbiAgICByZXR1cm4gdmVjNDxib29sPihpc25hbih2YWxbMF0pLCBpc25hbih2YWxbMV0pLCBpc25hbih2YWxbMl0pLCBpc25hbih2YWxbM10pKTtcbiAgfVxuYDtcblxudHlwZSBJbnB1dEluZm8gPSB7XG4gIGR0eXBlOiBEYXRhVHlwZTsgc2hhcGU6IG51bWJlcltdOyBuYW1lOiBzdHJpbmc7XG59O1xuZXhwb3J0IHR5cGUgV0dTTERhdGFUeXBlID0gJ2YzMid8J2kzMid8J3ZlYzQ8ZjMyPid8J3ZlYzQ8aTMyPid8J3ZlYzQ8Ym9vbD4nO1xuXG4vKipcbiAqIERlcml2ZXMgbG9naWNhbCBjb29yZGluYXRlcyBmcm9tIGEgZmxhdCBpbmRleC4gUGVyZm9ybXMgaW50ZWdlciBkaXZpc2lvblxuICogd2l0aCBlYWNoIHN0cmlkZSBhbmQgZGVjcmVtZW50cyB0aGUgaW5kZXggdW50aWwgdGhlIGluZGV4IGVxdWFscyB0aGUgZmluYWxcbiAqIGRpbWVuc2lvbiBjb29yZGluYXRlLlxuICovXG5mdW5jdGlvbiBnZXRDb29yZHNGcm9tSW5kZXhTbmlwcGV0KHNoYXBlOiBudW1iZXJbXSk6IHN0cmluZyB7XG4gIGNvbnN0IHJhbmsgPSBzaGFwZS5sZW5ndGg7XG5cbiAgaWYgKHJhbmsgPD0gMSkge1xuICAgIHJldHVybiBgZm4gZ2V0Q29vcmRzRnJvbUluZGV4KGluZGV4IDogaTMyKSAtPiBpMzIgeyByZXR1cm4gaW5kZXg7IH1gO1xuICB9XG5cbiAgY29uc3Qgc3RyaWRlcyA9IHV0aWwuY29tcHV0ZVN0cmlkZXMoc2hhcGUpO1xuICBjb25zdCBkdHlwZSA9IGdldENvb3Jkc0RhdGFUeXBlKHJhbmspO1xuXG4gIGNvbnN0IGNvb3Jkczogc3RyaW5nW10gPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5rOyBpKyspIHtcbiAgICBjb29yZHMucHVzaChgZCR7aX1gKTtcbiAgfVxuXG4gIGlmIChzdHJpZGVzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBgICAgIGZuIGdldENvb3Jkc0Zyb21JbmRleChpbmRleCA6IGkzMikgLT4gdmVjMjxpMzI+IHtcbiAgICAgIGxldCBkMCA9IGluZGV4IC8gdW5pZm9ybXMub3V0U2hhcGVTdHJpZGVzOyBsZXQgZDEgPSBpbmRleCAtIGQwICogdW5pZm9ybXMub3V0U2hhcGVTdHJpZGVzO1xuICAgICAgcmV0dXJuIHZlYzI8aTMyPihkMCwgZDEpO1xuICAgIH1gO1xuICB9XG4gIGxldCBzbmlwcGV0O1xuICBzbmlwcGV0ID0gJ3ZhciBpbmRleDIgPSBpbmRleDsnICtcbiAgICAgIHN0cmlkZXNcbiAgICAgICAgICAubWFwKChfLCBpKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsaW5lMSA9XG4gICAgICAgICAgICAgICAgYGxldCAke2Nvb3Jkc1tpXX0gPSBpbmRleDIgLyB1bmlmb3Jtcy5vdXRTaGFwZVN0cmlkZXMuJHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0Q29vcmRzWFlaKGkpfWA7XG4gICAgICAgICAgICBjb25zdCBsaW5lMiA9IGkgPT09IHN0cmlkZXMubGVuZ3RoIC0gMSA/XG4gICAgICAgICAgICAgICAgYGxldCAke2Nvb3Jkc1tpICsgMV19ID0gaW5kZXgyIC0gJHtcbiAgICAgICAgICAgICAgICAgICAgY29vcmRzW2ldfSAqIHVuaWZvcm1zLm91dFNoYXBlU3RyaWRlcy4ke2dldENvb3Jkc1hZWihpKX1gIDpcbiAgICAgICAgICAgICAgICBgaW5kZXgyID0gaW5kZXgyIC0gJHtjb29yZHNbaV19ICogdW5pZm9ybXMub3V0U2hhcGVTdHJpZGVzLiR7XG4gICAgICAgICAgICAgICAgICAgIGdldENvb3Jkc1hZWihpKX1gO1xuICAgICAgICAgICAgcmV0dXJuIGAke2xpbmUxfTsgJHtsaW5lMn07YDtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5qb2luKCcnKTtcblxuICByZXR1cm4gYFxuICAgIGZuIGdldENvb3Jkc0Zyb21JbmRleChpbmRleCA6IGkzMikgLT4gJHtkdHlwZX0ge1xuICAgICAgJHtzbmlwcGV0fVxuICAgICAgcmV0dXJuICR7ZHR5cGV9KCR7Y29vcmRzLmpvaW4oJywnKX0pO1xuICAgIH1cbiAgYDtcbn1cblxuZnVuY3Rpb24gZ2V0SW5wdXRBdENvb3Jkc1NuaXBwZXQoXG4gICAgaW5wdXRJbmZvOiBJbnB1dEluZm8sIGlzVmVjNDogYm9vbGVhbik6IHN0cmluZyB7XG4gIGNvbnN0IHRleE5hbWUgPSBpbnB1dEluZm8ubmFtZTtcbiAgY29uc3QgcmFuayA9IGlucHV0SW5mby5zaGFwZS5sZW5ndGg7XG4gIGNvbnN0IHR5cGUgPSBnZXRDb29yZHNEYXRhVHlwZShyYW5rKTtcbiAgY29uc3QgZnVuY05hbWUgPSAnZ2V0JyArIHRleE5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0ZXhOYW1lLnNsaWNlKDEpO1xuICBjb25zdCBkaW1zID0gWydkMCcsICdkMScsICdkMicsICdkMycsICdkNCcsICdkNSddLnNsaWNlKDAsIHJhbmspO1xuICBjb25zdCBpbnB1dHMgPSBkaW1zLm1hcChkID0+IGAke2R9IDogaTMyYCkuam9pbignLCAnKTtcblxuICBpZiAocmFuayA8IDEpIHtcbiAgICBpZiAoaXNWZWM0KSB7XG4gICAgICByZXR1cm4gYFxuICAgICAgICBmbiAke2Z1bmNOYW1lfSgpIC0+IHZlYzQ8ZjMyPiB7XG4gICAgICAgICAgcmV0dXJuIHZlYzQ8ZjMyPigke3RleE5hbWV9WzBdKTtcbiAgICAgICAgfVxuICAgICAgYDtcbiAgICB9XG5cbiAgICByZXR1cm4gYFxuICAgICAgZm4gJHtmdW5jTmFtZX0oKSAtPmYzMiB7XG4gICAgICAgIHJldHVybiBmMzIoJHt0ZXhOYW1lfVswXSk7XG4gICAgICB9XG4gICAgYDtcbiAgfVxuXG4gIGNvbnN0IHNoYXBlU3RyID1cbiAgICAgIGB1bmlmb3Jtcy4ke3RleE5hbWUuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkgKyB0ZXhOYW1lLnNsaWNlKDEpfVNoYXBlYDtcbiAgbGV0IHJhbmtTdHIgPSBgJHtyYW5rfURgO1xuICBpZiAocmFuayA9PT0gMCkge1xuICAgIHJhbmtTdHIgPSAnMUQnO1xuICB9XG5cbiAgaWYgKGlzVmVjNCkge1xuICAgIHJldHVybiBgXG4gICAgICBmbiAke2Z1bmNOYW1lfSgke2lucHV0c30pIC0+IHZlYzQ8ZjMyPiB7XG4gICAgICAgIHJldHVybiB2ZWM0PGYzMj4oJHt0ZXhOYW1lfVtnZXRJbmRleEZyb21Db29yZHMke3JhbmtTdHJ9KCR7dHlwZX0oJHtcbiAgICAgICAgZGltcy5qb2luKCcsJyl9KSxcbiAgICAgICAgICAke3NoYXBlU3RyfSkgLyA0XSk7XG4gICAgICB9XG4gICAgICBgO1xuICB9XG5cbiAgcmV0dXJuIGBcbiAgICBmbiAke2Z1bmNOYW1lfSgke2lucHV0c30pIC0+IGYzMiB7XG4gICAgICByZXR1cm4gZjMyKCR7dGV4TmFtZX1bZ2V0SW5kZXhGcm9tQ29vcmRzJHtyYW5rU3RyfSgke3R5cGV9KCR7XG4gICAgICBkaW1zLmpvaW4oJywnKX0pLFxuICAgICAgICAke3NoYXBlU3RyfSldKTtcbiAgICB9XG4gICBgO1xufVxuXG5mdW5jdGlvbiBnZXRJbnB1dEJ5T3V0cHV0U25pcHBldChcbiAgICBpbnB1dEluZm86IElucHV0SW5mbywgb3V0U2hhcGU6IG51bWJlcltdLCBpc1ZlYzQ6IGJvb2xlYW4sXG4gICAgaXNGbGF0RGlzcGF0Y2hMYXlvdXQ6IGJvb2xlYW4pOiBzdHJpbmcge1xuICBjb25zdCB0ZXhOYW1lID0gaW5wdXRJbmZvLm5hbWU7XG4gIGNvbnN0IHRleEZ1bmNTbmlwcGV0ID0gdGV4TmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHRleE5hbWUuc2xpY2UoMSk7XG5cbiAgY29uc3QgZnVuY05hbWUgPSAnZ2V0JyArIHRleEZ1bmNTbmlwcGV0ICsgJ0J5T3V0cHV0JztcblxuICBjb25zdCBpblJhbmsgPSBpbnB1dEluZm8uc2hhcGUubGVuZ3RoO1xuICBjb25zdCBvdXRSYW5rID0gb3V0U2hhcGUubGVuZ3RoO1xuICBjb25zdCB0eXBlID0gZ2V0Q29vcmRzRGF0YVR5cGUob3V0UmFuayk7XG5cbiAgLy8gSWYgdGhlIGluU2hhcGUgZXF1YWxzIHRoZSBvdXRTaGFwZSBhbmQgdGhlIGRpc3BhdGNoIGxheW91dCBpcyBmbGF0LCB3ZSBjYW5cbiAgLy8gZGlyZWN0bHkgdXNlIHxnbF9HbG9iYWxJbnZvY2F0aW9uSUQueHwgYXMgdGhlIGluZGV4IGFuZCBkb24ndCBuZWVkIGNvb3Jkc1xuICAvLyBjb252ZXJzaW9uIGJldHdlZW4gdGhlc2UgdHdvIHNoYXBlcy5cbiAgaWYgKHV0aWwuYXJyYXlzRXF1YWwoaW5wdXRJbmZvLnNoYXBlLCBvdXRTaGFwZSkgJiYgaXNGbGF0RGlzcGF0Y2hMYXlvdXQpIHtcbiAgICBpZiAoaXNWZWM0KSB7XG4gICAgICByZXR1cm4gYFxuICAgICAgZm4gJHtmdW5jTmFtZX1JbmRleChnbG9iYWxJbmRleCA6IGkzMikgLT4gdmVjNDxmMzI+IHtcbiAgICAgICAgcmV0dXJuIHZlYzQ8ZjMyPigke3RleE5hbWV9W2dsb2JhbEluZGV4XSk7XG4gICAgICB9XG5cbiAgICAgIGZuICR7ZnVuY05hbWV9Q29vcmRzKGNvb3JkcyA6ICR7dHlwZX0pIC0+IHZlYzQ8ZjMyPiB7XG4gICAgICAgIHJldHVybiB2ZWM0PGYzMj4oJHt0ZXhOYW1lfVske1xuICAgICAgICAgIG91dFJhbmsgPiAxID8gJ2dldE91dHB1dEluZGV4RnJvbUNvb3Jkcyhjb29yZHMpJyA6ICdjb29yZHMnfSAvIDRdKTtcbiAgICAgIH1cbiAgICAgIGA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBgXG4gICAgZm4gJHtmdW5jTmFtZX1JbmRleChnbG9iYWxJbmRleCA6IGkzMikgLT4gZjMyIHtcbiAgICAgIHJldHVybiBmMzIoJHt0ZXhOYW1lfVtnbG9iYWxJbmRleF0pO1xuICAgIH1cblxuICAgIGZuICR7ZnVuY05hbWV9Q29vcmRzKGNvb3JkcyA6ICR7dHlwZX0pIC0+IGYzMiB7XG4gICAgICByZXR1cm4gZjMyKCR7dGV4TmFtZX1bJHtcbiAgICAgICAgICBvdXRSYW5rID4gMSA/ICdnZXRPdXRwdXRJbmRleEZyb21Db29yZHMoY29vcmRzKScgOiAnY29vcmRzJ31dKTtcbiAgICB9XG4gICAgYDtcbiAgICB9XG4gIH1cblxuICBjb25zdCBicm9hZGNhc3REaW1zID1cbiAgICAgIGJhY2tlbmRfdXRpbC5nZXRCcm9hZGNhc3REaW1zKGlucHV0SW5mby5zaGFwZSwgb3V0U2hhcGUpO1xuICBjb25zdCByYW5rRGlmZiA9IG91dFJhbmsgLSBpblJhbms7XG5cbiAgbGV0IGNvb3Jkc1NuaXBwZXQgPSAnJztcblxuICBpZiAoaW5SYW5rID09PSAwKSB7XG4gICAgaWYgKGlzVmVjNCkge1xuICAgICAgcmV0dXJuIGBcbiAgICBmbiAke2Z1bmNOYW1lfUluZGV4KGdsb2JhbEluZGV4IDogaTMyKSAtPiB2ZWM0PGYzMj4ge1xuICAgICAgcmV0dXJuIGdldCR7dGV4RnVuY1NuaXBwZXR9KCk7XG4gICAgfVxuXG4gICAgZm4gJHtmdW5jTmFtZX1Db29yZHMoY29vcmRzIDogJHt0eXBlfSkgLT4gdmVjNDxmMzI+IHtcbiAgICAgIHJldHVybiBnZXQke3RleEZ1bmNTbmlwcGV0fSgpO1xuICAgIH1cbiAgYDtcbiAgICB9XG4gICAgcmV0dXJuIGBcbiAgICBmbiAke2Z1bmNOYW1lfUluZGV4KGdsb2JhbEluZGV4IDogaTMyKSAtPiBmMzJ7XG4gICAgICByZXR1cm4gZ2V0JHt0ZXhGdW5jU25pcHBldH0oKTtcbiAgICB9XG5cbiAgICBmbiAke2Z1bmNOYW1lfUNvb3Jkcyhjb29yZHMgOiAke3R5cGV9KSAtPiBmMzJ7XG4gICAgICByZXR1cm4gZ2V0JHt0ZXhGdW5jU25pcHBldH0oKTtcbiAgICB9XG4gIGA7XG4gIH0gZWxzZSB7XG4gICAgaWYgKG91dFJhbmsgPCAyICYmIGJyb2FkY2FzdERpbXMubGVuZ3RoID49IDEpIHtcbiAgICAgIGNvb3Jkc1NuaXBwZXQgPSAnY29vcmRzID0gMDsnO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb29yZHNTbmlwcGV0ID1cbiAgICAgICAgICBicm9hZGNhc3REaW1zLm1hcChkID0+IGBjb29yZHMuJHtnZXRDb29yZHNYWVooZCArIHJhbmtEaWZmKX0gPSAwO2ApXG4gICAgICAgICAgICAgIC5qb2luKCdcXG4nKTtcbiAgICB9XG4gIH1cblxuICBsZXQgdW5wYWNrZWRDb29yZHNTbmlwcGV0ID0gJyc7XG4gIGlmIChvdXRSYW5rIDwgMiAmJiBpblJhbmsgPiAwKSB7XG4gICAgdW5wYWNrZWRDb29yZHNTbmlwcGV0ID0gJ2Nvb3Jkcyc7XG4gIH0gZWxzZSB7XG4gICAgaWYgKG91dFJhbmsgPiAxKSB7XG4gICAgICBjb25zdCBjb29yZHNUeXBlID0gZ2V0Q29vcmRzRGF0YVR5cGUoaW5SYW5rKTtcbiAgICAgIGNvbnN0IGNvb3Jkc1ZhbHVlcyA9XG4gICAgICAgICAgaW5wdXRJbmZvLnNoYXBlLm1hcCgocywgaSkgPT4gYGNvb3Jkcy4ke2dldENvb3Jkc1hZWihpICsgcmFua0RpZmYpfWApXG4gICAgICAgICAgICAgIC5qb2luKCcsICcpO1xuICAgICAgdW5wYWNrZWRDb29yZHNTbmlwcGV0ID0gYCR7Y29vcmRzVHlwZX0oJHtjb29yZHNWYWx1ZXN9KWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVucGFja2VkQ29vcmRzU25pcHBldCA9ICdjb29yZHMnO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHNoYXBlU3RyID1cbiAgICAgIGB1bmlmb3Jtcy4ke3RleE5hbWUuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkgKyB0ZXhOYW1lLnNsaWNlKDEpfVNoYXBlYDtcbiAgY29uc3QgcmFua1N0ciA9IGAke2luUmFua31EYDtcbiAgaWYgKGlzVmVjNCkge1xuICAgIHJldHVybiBgXG4gICAgZm4gJHtmdW5jTmFtZX1JbmRleChnbG9iYWxJbmRleCA6IGkzMikgLT4gdmVjNDxmMzI+IHtcbiAgICAgIHZhciBjb29yZHMgPSBnZXRDb29yZHNGcm9tSW5kZXgoZ2xvYmFsSW5kZXgpO1xuICAgICAgJHtjb29yZHNTbmlwcGV0fVxuICAgICAgcmV0dXJuICR7dGV4TmFtZX1bZ2V0SW5kZXhGcm9tQ29vcmRzJHtyYW5rU3RyfSgke1xuICAgICAgICB1bnBhY2tlZENvb3Jkc1NuaXBwZXR9LCAke3NoYXBlU3RyfSkgLyA0XTtcbiAgICB9XG5cbiAgICBmbiAke2Z1bmNOYW1lfUNvb3Jkcyhjb29yZHNJbiA6ICR7dHlwZX0pIC0+IHZlYzQ8ZjMyPiB7XG4gICAgICB2YXIgY29vcmRzID0gY29vcmRzSW47XG4gICAgICAke2Nvb3Jkc1NuaXBwZXR9XG4gICAgICByZXR1cm4gJHt0ZXhOYW1lfVtnZXRJbmRleEZyb21Db29yZHMke3JhbmtTdHJ9KCR7XG4gICAgICAgIHVucGFja2VkQ29vcmRzU25pcHBldH0sICR7c2hhcGVTdHJ9KSAvIDRdO1xuICAgIH1cbiAgYDtcbiAgfVxuXG4gIHJldHVybiBgXG4gIGZuICR7ZnVuY05hbWV9SW5kZXgoZ2xvYmFsSW5kZXggOiBpMzIpIC0+IGYzMiB7XG4gICAgdmFyIGNvb3JkcyA9IGdldENvb3Jkc0Zyb21JbmRleChnbG9iYWxJbmRleCk7XG4gICAgJHtjb29yZHNTbmlwcGV0fVxuICAgIHJldHVybiBmMzIoJHt0ZXhOYW1lfVtnZXRJbmRleEZyb21Db29yZHMke3JhbmtTdHJ9KCR7XG4gICAgICB1bnBhY2tlZENvb3Jkc1NuaXBwZXR9LCAke3NoYXBlU3RyfSldKTtcbiAgfVxuXG4gIGZuICR7ZnVuY05hbWV9Q29vcmRzKGNvb3Jkc0luIDogJHt0eXBlfSkgLT4gZjMyIHtcbiAgICB2YXIgY29vcmRzID0gY29vcmRzSW47XG4gICAgJHtjb29yZHNTbmlwcGV0fVxuICAgIHJldHVybiBmMzIoJHt0ZXhOYW1lfVtnZXRJbmRleEZyb21Db29yZHMke3JhbmtTdHJ9KCR7XG4gICAgICB1bnBhY2tlZENvb3Jkc1NuaXBwZXR9LCAke3NoYXBlU3RyfSldKTtcbiAgfVxuYDtcbn1cblxuZnVuY3Rpb24gZ2V0SW5wdXRTbmlwcGV0KFxuICAgIGlucHV0SW5mbzogSW5wdXRJbmZvLCBvdXRTaGFwZTogbnVtYmVyW10sIGlzVmVjNDogYm9vbGVhbixcbiAgICBpc0ZsYXREaXNwYXRjaExheW91dDogYm9vbGVhbik6IHN0cmluZyB7XG4gIGxldCByZXMgPSBnZXRJbnB1dEF0Q29vcmRzU25pcHBldChpbnB1dEluZm8sIGlzVmVjNCk7XG5cbiAgY29uc3QgaW5TaGFwZSA9IGlucHV0SW5mby5zaGFwZTtcbiAgaWYgKGluU2hhcGUubGVuZ3RoIDw9IG91dFNoYXBlLmxlbmd0aCkge1xuICAgIHJlcyArPSBnZXRJbnB1dEJ5T3V0cHV0U25pcHBldChcbiAgICAgICAgaW5wdXRJbmZvLCBvdXRTaGFwZSwgaXNWZWM0LCBpc0ZsYXREaXNwYXRjaExheW91dCk7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBnZXRPdXRwdXRDb29yZHMoKSBmdW5jdGlvbiB0aGF0IGNvbXB1dGVzIG91dHB1dCBjb29yZGluYXRlcyBmcm9tXG4gKiBkaXNwYXRjaCBnZW9tZXRyeSB0byByZWR1Y2UgYXJpdGhtZXRpYy5cbiAqL1xuZnVuY3Rpb24gZ2V0T3V0cHV0Q29vcmRzU25pcHBldChcbiAgICBvdXRTaGFwZTogbnVtYmVyW10sXG4gICAgZGlzcGF0Y2hMYXlvdXQ6IHt4OiBudW1iZXJbXSwgeT86IG51bWJlcltdLCB6PzogbnVtYmVyW119KTogc3RyaW5nIHtcbiAgY29uc3Qge3gsIHkgPSBbXSwgeiA9IFtdfSA9IGRpc3BhdGNoTGF5b3V0O1xuXG4gIGNvbnN0IG91dFJhbmsgPSBvdXRTaGFwZS5sZW5ndGg7XG4gIGNvbnN0IHJhbmsgPSB4Lmxlbmd0aCArIHkubGVuZ3RoICsgei5sZW5ndGg7XG4gIC8vIGdldE91dHB1dENvb3JkcyBpcyBvbmx5IG1lYW5pbmdmdWwgd2hlbiB0aGUgb3V0cHV0IHJhbmsgaXMgc2FtZSB3aXRoXG4gIC8vIGRpc3BhdGNoIGxheW91dCByYW5rLlxuICBpZiAocmFuayAhPT0gb3V0UmFuaykge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmICh4Lmxlbmd0aCA9PT0gb3V0UmFuaykge1xuICAgIGNvbnN0IGR0eXBlID0gZ2V0Q29vcmRzRGF0YVR5cGUob3V0UmFuayk7XG4gICAgY29uc3Qgc25pcHBldCA9IGBmbiBnZXRPdXRwdXRDb29yZHMoKSAtPiAke2R0eXBlfXtcbiAgICBsZXQgZ2xvYmFsSW5kZXggPSBnZXRHbG9iYWxJbmRleCgpO1xuICAgIHJldHVybiBnZXRDb29yZHNGcm9tSW5kZXgoZ2xvYmFsSW5kZXgpO1xuICB9XG4gIGA7XG4gICAgcmV0dXJuIHNuaXBwZXQ7XG4gIH1cblxuICBsZXQgZ2F0aGVyRGltZW5zaW9uc1N0ciA9ICcnO1xuICBjb25zdCBkaW1zID0gW3gsIHksIHpdO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGltcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGFyciA9IGRpbXNbaV07XG5cbiAgICBpZiAoYXJyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGFyci5sZW5ndGggPT09IDEpIHtcbiAgICAgIGdhdGhlckRpbWVuc2lvbnNTdHIgKz0gYGxldCBkJHthcnJbMF19ID0gaTMyKGdsb2JhbElkWyR7aX1dKTtgO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzdHJpZGVzID0gc3ltYm9saWNhbGx5Q29tcHV0ZVN0cmlkZXMoYXJyLCAndW5pZm9ybXMub3V0U2hhcGUnKTtcbiAgICAgIGdhdGhlckRpbWVuc2lvbnNTdHIgKz0gYHZhciBpbmRleCR7aX0gPSBpMzIoZ2xvYmFsSWRbJHtpfV0pO2A7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHN0cmlkZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgZ2F0aGVyRGltZW5zaW9uc1N0ciArPSBgbGV0IGQke2FycltqXX0gPSBpbmRleCR7aX0gLyAke3N0cmlkZXNbal19O2A7XG5cbiAgICAgICAgaWYgKGogPT09IHN0cmlkZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIGdhdGhlckRpbWVuc2lvbnNTdHIgKz0gYGxldCBkJHthcnJbaiArIDFdfSA9IGAgK1xuICAgICAgICAgICAgICBgaW5kZXgke2l9IC0gZCR7YXJyW2pdfSAqICR7c3RyaWRlc1tqXX07YDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnYXRoZXJEaW1lbnNpb25zU3RyICs9XG4gICAgICAgICAgICAgIGBpbmRleCR7aX0gPSBpbmRleCR7aX0gLSBkJHthcnJbal19ICogJHtzdHJpZGVzW2pdfTtgO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29uc3QgZGltZW5zaW9ucyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbms7IGkrKykge1xuICAgIGRpbWVuc2lvbnMucHVzaChgZCR7aX1gKTtcbiAgfVxuXG4gIGNvbnN0IGR0eXBlID0gZ2V0Q29vcmRzRGF0YVR5cGUocmFuayk7XG4gIGxldCBzbmlwcGV0ID0gYGZuIGdldE91dHB1dENvb3JkcygpIC0+ICR7ZHR5cGV9IHtcbiAgJHtnYXRoZXJEaW1lbnNpb25zU3RyfVxuYDtcbiAgaWYgKGRpbWVuc2lvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgc25pcHBldCArPSBgcmV0dXJuICR7ZHR5cGV9KDApOyB9YDtcbiAgfSBlbHNlIHtcbiAgICBzbmlwcGV0ICs9IGByZXR1cm4gJHtkdHlwZX0oJHtkaW1lbnNpb25zLmpvaW4oJywnKX0pOyB9YDtcbiAgfVxuXG4gIHJldHVybiBzbmlwcGV0O1xufVxuXG5mdW5jdGlvbiBnZXRPdXRwdXRJbmRleEZyb21Db29yZHNTbmlwcGV0KG91dFJhbms6IG51bWJlcikge1xuICBsZXQgc25pcHBldCA9ICcnO1xuICBzd2l0Y2ggKG91dFJhbmspIHtcbiAgICBjYXNlIDA6XG4gICAgY2FzZSAxOlxuICAgICAgc25pcHBldCArPSBgXG4gICAgICAgIGZuIGdldE91dHB1dEluZGV4RnJvbUNvb3Jkcyhjb29yZHMgOiBpMzIpIC0+IGkzMiB7XG4gICAgICAgICAgcmV0dXJuIGNvb3JkcztcbiAgICAgICAgfVxuICAgICAgICBgO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAyOlxuICAgICAgc25pcHBldCArPSBgXG4gICAgICAgIGZuIGdldE91dHB1dEluZGV4RnJvbUNvb3Jkcyhjb29yZHMgOiB2ZWMyPGkzMj4pIC0+IGkzMiB7XG4gICAgICAgICAgcmV0dXJuIGRvdChjb29yZHMsIHZlYzI8aTMyPih1bmlmb3Jtcy5vdXRTaGFwZVN0cmlkZXMsIDEpKTtcbiAgICAgICAgfVxuICAgICAgICBgO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAzOlxuICAgICAgc25pcHBldCArPSBgXG4gICAgICAgIGZuIGdldE91dHB1dEluZGV4RnJvbUNvb3Jkcyhjb29yZHMgOiB2ZWMzPGkzMj4pIC0+IGkzMiB7XG4gICAgICAgICAgcmV0dXJuIGRvdChjb29yZHMsIHZlYzM8aTMyPih1bmlmb3Jtcy5vdXRTaGFwZVN0cmlkZXMueCwgdW5pZm9ybXMub3V0U2hhcGVTdHJpZGVzLnksIDEpKTtcbiAgICAgICAgfVxuICAgICAgICBgO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSA0OlxuICAgICAgc25pcHBldCArPSBgXG4gICAgICAgIGZuIGdldE91dHB1dEluZGV4RnJvbUNvb3Jkcyhjb29yZHMgOiB2ZWM0PGkzMj4pIC0+IGkzMiB7XG4gICAgICAgICAgcmV0dXJuIGRvdChjb29yZHMsIHZlYzQ8aTMyPihcbiAgICAgICAgICAgIHVuaWZvcm1zLm91dFNoYXBlU3RyaWRlcy54LCB1bmlmb3Jtcy5vdXRTaGFwZVN0cmlkZXMueSwgdW5pZm9ybXMub3V0U2hhcGVTdHJpZGVzLnosIDEpKTtcbiAgICAgICAgfVxuICAgICAgICBgO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSA1OlxuICAgICAgc25pcHBldCArPSBgXG4gICAgICAgIGZuIGdldE91dHB1dEluZGV4RnJvbUNvb3Jkcyhjb29yZHMgOiB2ZWM1KSAtPiBpMzIge1xuICAgICAgICAgIHJldHVybiBjb29yZHMueCAqIHVuaWZvcm1zLm91dFNoYXBlU3RyaWRlcy54ICtcbiAgICAgICAgICAgICAgY29vcmRzLnkgKiB1bmlmb3Jtcy5vdXRTaGFwZVN0cmlkZXMueSArXG4gICAgICAgICAgICAgIGNvb3Jkcy56ICogdW5pZm9ybXMub3V0U2hhcGVTdHJpZGVzLnogK1xuICAgICAgICAgICAgICBjb29yZHMudyAqIHVuaWZvcm1zLm91dFNoYXBlU3RyaWRlcy53ICtcbiAgICAgICAgICAgICAgY29vcmRzLnU7XG4gICAgICAgIH1cbiAgICAgICAgYDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNjpcbiAgICAgIHNuaXBwZXQgKz0gYFxuICAgICAgICBmbiBnZXRPdXRwdXRJbmRleEZyb21Db29yZHMoY29vcmRzIDogdmVjNikgLT4gaTMyIHtcbiAgICAgICAgICByZXR1cm4gY29vcmRzLnggKiB1bmlmb3Jtcy5vdXRTaGFwZVN0cmlkZXMueCArXG4gICAgICAgICAgICAgIGNvb3Jkcy55ICogdW5pZm9ybXMub3V0U2hhcGVTdHJpZGVzLnkgK1xuICAgICAgICAgICAgICBjb29yZHMueiAqIHVuaWZvcm1zLm91dFNoYXBlU3RyaWRlcy56ICtcbiAgICAgICAgICAgICAgY29vcmRzLncgKiB1bmlmb3Jtcy5vdXRTaGFwZVN0cmlkZXMudyArXG4gICAgICAgICAgICAgIGNvb3Jkcy51ICogdW5pZm9ybXMub3V0U2hhcGVTdHJpZGVzLnUgK1xuICAgICAgICAgICAgICBjb29yZHMudjtcbiAgICAgICAgfVxuICAgICAgICBgO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHV0aWwuYXNzZXJ0KGZhbHNlLCAoKSA9PiBgVW5zdXBwb3J0ZWQgJHtvdXRSYW5rfUQgc2hhcGVgKTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiBzbmlwcGV0O1xufVxuXG5mdW5jdGlvbiBpc0ZsYXREaXNwYXRjaChwcm9ncmFtOiBXZWJHUFVQcm9ncmFtKTogYm9vbGVhbiB7XG4gIHJldHVybiBwcm9ncmFtLmRpc3BhdGNoWzFdID09PSAxICYmIHByb2dyYW0uZGlzcGF0Y2hbMl0gPT09IDE7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXBUb1dnc2xUeXBlcyh0eXBlOiBEYXRhVHlwZSwgaXNWZWM0OiBib29sZWFuKTogV0dTTERhdGFUeXBlfFxuICAgIERhdGFUeXBlIHtcbiAgaWYgKHR5cGUgPT09ICdmbG9hdDMyJykge1xuICAgIHJldHVybiBpc1ZlYzQgPyAndmVjNDxmMzI+JyA6ICdmMzInO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdpbnQzMicpIHtcbiAgICByZXR1cm4gaXNWZWM0ID8gJ3ZlYzQ8aTMyPicgOiAnaTMyJztcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnYm9vbCcpIHtcbiAgICAvLyBUeXBlICdib29sJyBjYW5ub3QgYmUgdXNlZCBpbiBzdG9yYWdlIGNsYXNzLFxuICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9XR1NMLyNob3N0LXNoYXJlYWJsZS10eXBlcy5cbiAgICByZXR1cm4gaXNWZWM0ID8gJ3ZlYzQ8aTMyPicgOiAnaTMyJztcbiAgfVxuXG4gIHJldHVybiB0eXBlO1xufVxuXG5mdW5jdGlvbiBzZXRPdXRwdXRTbmlwcGV0KFxuICAgIG91dFNoYXBlOiBudW1iZXJbXSwgb3V0QnVmZmVyVHlwZTogRGF0YVR5cGUsIGlzVmVjNDogYm9vbGVhbik6IHN0cmluZyB7XG4gIGNvbnN0IG91dFJhbmsgPSBvdXRTaGFwZS5sZW5ndGg7XG4gIGNvbnN0IHdnc2xUeXBlID0gbWFwVG9XZ3NsVHlwZXMob3V0QnVmZmVyVHlwZSwgaXNWZWM0KTtcbiAgbGV0IHNuaXBwZXQ7XG4gIGlmIChpc1ZlYzQpIHtcbiAgICBzbmlwcGV0ID0gYGZuIHNldE91dHB1dEF0SW5kZXgoZmxhdEluZGV4IDogaTMyLCB2YWx1ZSA6IHZlYzQ8ZjMyPikge1xuICAgICAgcmVzdWx0W2ZsYXRJbmRleF0gPSAke3dnc2xUeXBlfSh2YWx1ZSk7XG4gICAgfVxuICAgIGZuIHNldE91dHB1dEF0SW5kZXhJMzIoZmxhdEluZGV4IDogaTMyLCB2YWx1ZSA6IHZlYzQ8aTMyPikge1xuICAgICAgcmVzdWx0W2ZsYXRJbmRleF0gPSAke3dnc2xUeXBlfSh2YWx1ZSk7XG4gICAgfWA7XG4gIH0gZWxzZSB7XG4gICAgc25pcHBldCA9IGBmbiBzZXRPdXRwdXRBdEluZGV4KGZsYXRJbmRleCA6IGkzMiwgdmFsdWUgOiBmMzIpIHtcbiAgICAgIHJlc3VsdFtmbGF0SW5kZXhdID0gJHt3Z3NsVHlwZX0odmFsdWUpO1xuICAgIH1cbiAgICBmbiBzZXRPdXRwdXRBdEluZGV4STMyKGZsYXRJbmRleCA6IGkzMiwgdmFsdWUgOiBpMzIpIHtcbiAgICAgIHJlc3VsdFtmbGF0SW5kZXhdID0gJHt3Z3NsVHlwZX0odmFsdWUpO1xuICAgIH1gO1xuICB9XG4gIGlmIChvdXRSYW5rID49IDIpIHtcbiAgICBjb25zdCBkaW1zID0gWydkMCcsICdkMScsICdkMicsICdkMycsICdkNCcsICdkNSddLnNsaWNlKDAsIG91dFJhbmspO1xuICAgIGNvbnN0IHR5cGUgPSBnZXRDb29yZHNEYXRhVHlwZShvdXRSYW5rKTtcblxuICAgIGlmIChpc1ZlYzQpIHtcbiAgICAgIHNuaXBwZXQgKz0gYFxuICAgICAgZm4gc2V0T3V0cHV0QXRDb29yZHMoJHtcbiAgICAgICAgICBkaW1zLm1hcChkID0+IGAke2R9IDogaTMyYCkuam9pbignLCAnKX0sIHZhbHVlIDogdmVjNDxmMzI+KSB7XG4gICAgICAgIGxldCBmbGF0SW5kZXggPSBnZXRPdXRwdXRJbmRleEZyb21Db29yZHMoJHt0eXBlfSgke2RpbXMuam9pbignLCAnKX0pKTtcbiAgICAgICAgc2V0T3V0cHV0QXRJbmRleChmbGF0SW5kZXggLyA0LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICBmbiBzZXRPdXRwdXRBdENvb3Jkc0kzMigke1xuICAgICAgICAgIGRpbXMubWFwKGQgPT4gYCR7ZH0gOiBpMzJgKS5qb2luKCcsICcpfSwgdmFsdWUgOiB2ZWM0PGkzMj4pIHtcbiAgICAgICAgbGV0IGZsYXRJbmRleCA9IGdldE91dHB1dEluZGV4RnJvbUNvb3Jkcygke3R5cGV9KCR7ZGltcy5qb2luKCcsICcpfSkpO1xuICAgICAgICBzZXRPdXRwdXRBdEluZGV4STMyKGZsYXRJbmRleCAvIDQsIHZhbHVlKTtcbiAgICAgIH1cbiAgICBgO1xuICAgIH0gZWxzZSB7XG4gICAgICBzbmlwcGV0ICs9IGBcbiAgICAgIGZuIHNldE91dHB1dEF0Q29vcmRzKCR7XG4gICAgICAgICAgZGltcy5tYXAoZCA9PiBgJHtkfSA6IGkzMmApLmpvaW4oJywgJyl9LCB2YWx1ZSA6IGYzMikge1xuICAgICAgICBsZXQgZmxhdEluZGV4ID0gZ2V0T3V0cHV0SW5kZXhGcm9tQ29vcmRzKCR7dHlwZX0oJHtkaW1zLmpvaW4oJywgJyl9KSk7XG4gICAgICAgIHNldE91dHB1dEF0SW5kZXgoZmxhdEluZGV4LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICBmbiBzZXRPdXRwdXRBdENvb3Jkc0kzMigke1xuICAgICAgICAgIGRpbXMubWFwKGQgPT4gYCR7ZH0gOiBpMzJgKS5qb2luKCcsICcpfSwgdmFsdWUgOiBpMzIpIHtcbiAgICAgICAgbGV0IGZsYXRJbmRleCA9IGdldE91dHB1dEluZGV4RnJvbUNvb3Jkcygke3R5cGV9KCR7ZGltcy5qb2luKCcsICcpfSkpO1xuICAgICAgICBzZXRPdXRwdXRBdEluZGV4STMyKGZsYXRJbmRleCwgdmFsdWUpO1xuICAgICAgfVxuICAgIGA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNuaXBwZXQ7XG59XG5cbmZ1bmN0aW9uIGluc2VydEFsaWdubWVudCh1bmlmb3JtU2hhZGVyOiBzdHJpbmcpIHtcbiAgLy8gaW5zZXJ0IGFsaWdubWVudCB3aGVuIGN1cnJlbnQgcGF0dGVybiBpcyB2ZWM1IG9yIHZlYzZcbiAgY29uc3QgY3VySW5zZXJ0UmUgPSAvKFxcdyspXFxzKjpcXHMqdmVjKDV8NikvZztcbiAgdW5pZm9ybVNoYWRlciA9IHVuaWZvcm1TaGFkZXIucmVwbGFjZShjdXJJbnNlcnRSZSwgKG1hdGNoKSA9PiB7XG4gICAgcmV0dXJuICdAYWxpZ24oMTYpICcgKyBtYXRjaDtcbiAgfSk7XG5cbiAgLy8gaW5zZXJ0IGFsaWdubWVudCB3aGVuIHByZXZpb3VzIHBhdHRlcm4gaXMgdmVjNSBvciB2ZWM2XG4gIGNvbnN0IHByZUluc2VydFJlID0gL3ZlYyg1fDYpXFxzKixcXHMqKFxcdyspL2c7XG4gIHVuaWZvcm1TaGFkZXIgPSB1bmlmb3JtU2hhZGVyLnJlcGxhY2UocHJlSW5zZXJ0UmUsIChfLCBwMSwgcDIpID0+IHtcbiAgICByZXR1cm4gYHZlYyR7cDF9LCBAYWxpZ24oMTYpICR7cDJ9YDtcbiAgfSk7XG4gIHJldHVybiB1bmlmb3JtU2hhZGVyO1xufVxuIl19