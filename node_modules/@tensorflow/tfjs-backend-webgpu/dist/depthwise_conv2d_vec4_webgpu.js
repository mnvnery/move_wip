/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import { util } from '@tensorflow/tfjs-core';
import { activationFnSnippet, biasActivationSnippet } from './activation_util';
import { getWorkGroupSizeString } from './webgpu_program';
import { computeDispatch } from './webgpu_util';
export class DepthwiseConv2DVec4Program {
    constructor(convInfo, addBias = false, activation = null, hasPreluActivation = false) {
        this.variableNames = ['x', 'W'];
        this.uniforms = 'pad : vec2<i32>, inDims : vec2<i32>,';
        this.workGroupSize = [4, 4, 4];
        this.workPerThread = 4;
        this.isVec4 = true;
        this.outputShape = convInfo.outShape;
        this.dispatchLayout = { x: [3], y: [2], z: [0, 1] };
        this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workGroupSize, [4, this.workPerThread, 1]);
        util.assert(convInfo.dataFormat === 'channelsLast', () => 'TODO: NCHW is unimplemented');
        if (addBias) {
            this.variableNames.push('bias');
        }
        if (hasPreluActivation) {
            this.variableNames.push('preluActivationWeights');
        }
        this.convInfo = convInfo;
        this.addBias = addBias;
        this.activation = activation;
        this.hasPreluActivation = hasPreluActivation;
        this.shaderKey =
            `depthwiseVec4_${activation}_${this.convInfo.filterHeight}_${this.convInfo.filterWidth}_${this.convInfo.strideHeight}_${this.convInfo.strideWidth}_${this.workPerThread}`;
    }
    getUserCode() {
        const xNumber = (this.workPerThread - 1) * this.convInfo.strideWidth +
            this.convInfo.filterWidth;
        const userCode = `
      ${activationFnSnippet(this.activation, this.hasPreluActivation, true, 4)}
      fn readX(batch : i32, row : i32, col : i32, channel : i32) -> vec4<f32> {
        var value = vec4<f32>(0.0);
        if (col >=0 && col < uniforms.inDims[1]) {
          value = getX(batch, row, col, channel);
        }
        return value;
      }

      const strideHeight = ${this.convInfo.strideHeight};
      const strideWidth = ${this.convInfo.strideWidth};
      ${getWorkGroupSizeString()}
      fn _start(@builtin(global_invocation_id) globalId: vec3<u32>) {
        let batch = i32(globalId.z) / uniforms.outShape[1];
        let r = i32(globalId.z) % uniforms.outShape[1];
        let c = i32(globalId.y) * ${this.workPerThread};
        let d1 = i32(globalId.x) * 4;
        let xRCCorner = vec2<i32>(r, c) * vec2<i32>(strideHeight, strideWidth) - uniforms.pad;

        let xRCorner = xRCCorner.x;
        let xCCorner = xRCCorner.y;
        var xVals : array<vec4<f32>, ${xNumber}>;
        var dotProd : array<vec4<f32>, ${this.workPerThread}>;
        for (var i = 0; i < ${this.workPerThread}; i++) {
          dotProd[i] = vec4<f32>(0.0);
        }

        // Use constant instead of uniform can give better performance.
        for (var wR = 0; wR < ${this.convInfo.filterHeight}; wR = wR + 1) {
          let xR = xRCorner + wR;
          if (xR >=0 && xR < uniforms.inDims[0]) {
            for (var i = 0; i < ${xNumber}; i++) {
              xVals[i] = readX(batch, xR, xCCorner + i, d1);
            }
            for (var wC = 0; wC < ${this.convInfo.filterWidth}; wC = wC + 1) {
              let wValue = getW(wR, wC, d1, 0);
              for (var i = 0; i < ${this.workPerThread}; i++) {
                dotProd[i] = fma(xVals[i * strideWidth + wC], wValue, dotProd[i]);
              }
            }
          }
        }

        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let coords = vec4<i32>(batch, r, c + i, d1);
          if (coordsInBounds4D(coords, uniforms.outShape)) {
            var value = dotProd[i];
            ${biasActivationSnippet(this.addBias, this.activation)}
            setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
          }
        }
      }
    `;
        return userCode;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVwdGh3aXNlX2NvbnYyZF92ZWM0X3dlYmdwdS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3RmanMtYmFja2VuZC13ZWJncHUvc3JjL2RlcHRod2lzZV9jb252MmRfdmVjNF93ZWJncHUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBRUgsT0FBTyxFQUFlLElBQUksRUFBQyxNQUFNLHVCQUF1QixDQUFDO0FBQ3pELE9BQU8sRUFBQyxtQkFBbUIsRUFBRSxxQkFBcUIsRUFBQyxNQUFNLG1CQUFtQixDQUFDO0FBQzdFLE9BQU8sRUFBQyxzQkFBc0IsRUFBZ0IsTUFBTSxrQkFBa0IsQ0FBQztBQUN2RSxPQUFPLEVBQUMsZUFBZSxFQUFDLE1BQU0sZUFBZSxDQUFDO0FBRTlDLE1BQU0sT0FBTywwQkFBMEI7SUFlckMsWUFDSSxRQUFpQyxFQUFFLE9BQU8sR0FBRyxLQUFLLEVBQ2xELGFBQXNDLElBQUksRUFBRSxrQkFBa0IsR0FBRyxLQUFLO1FBWjFFLGtCQUFhLEdBQUcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFDM0IsYUFBUSxHQUFHLHNDQUFzQyxDQUFDO1FBQ2xELGtCQUFhLEdBQTZCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUNwRCxrQkFBYSxHQUFHLENBQUMsQ0FBQztRQUtsQixXQUFNLEdBQUcsSUFBSSxDQUFDO1FBS1osSUFBSSxDQUFDLFdBQVcsR0FBRyxRQUFRLENBQUMsUUFBUSxDQUFDO1FBQ3JDLElBQUksQ0FBQyxjQUFjLEdBQUcsRUFBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUMsQ0FBQztRQUNsRCxJQUFJLENBQUMsUUFBUSxHQUFHLGVBQWUsQ0FDM0IsSUFBSSxDQUFDLGNBQWMsRUFBRSxJQUFJLENBQUMsV0FBVyxFQUFFLElBQUksQ0FBQyxhQUFhLEVBQ3pELENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUVoQyxJQUFJLENBQUMsTUFBTSxDQUNQLFFBQVEsQ0FBQyxVQUFVLEtBQUssY0FBYyxFQUN0QyxHQUFHLEVBQUUsQ0FBQyw2QkFBNkIsQ0FBQyxDQUFDO1FBRXpDLElBQUksT0FBTyxFQUFFO1lBQ1gsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7U0FDakM7UUFDRCxJQUFJLGtCQUFrQixFQUFFO1lBQ3RCLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLHdCQUF3QixDQUFDLENBQUM7U0FDbkQ7UUFFRCxJQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztRQUN6QixJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQztRQUN2QixJQUFJLENBQUMsVUFBVSxHQUFHLFVBQVUsQ0FBQztRQUM3QixJQUFJLENBQUMsa0JBQWtCLEdBQUcsa0JBQWtCLENBQUM7UUFFN0MsSUFBSSxDQUFDLFNBQVM7WUFDVixpQkFBaUIsVUFBVSxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsWUFBWSxJQUNyRCxJQUFJLENBQUMsUUFBUSxDQUFDLFdBQVcsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLFlBQVksSUFDdkQsSUFBSSxDQUFDLFFBQVEsQ0FBQyxXQUFXLElBQUksSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO0lBQzVELENBQUM7SUFFRCxXQUFXO1FBQ1QsTUFBTSxPQUFPLEdBQUcsQ0FBQyxJQUFJLENBQUMsYUFBYSxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsV0FBVztZQUNoRSxJQUFJLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQztRQUU5QixNQUFNLFFBQVEsR0FBRztRQUNiLG1CQUFtQixDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLGtCQUFrQixFQUFFLElBQUksRUFBRSxDQUFDLENBQUM7Ozs7Ozs7Ozs2QkFTakQsSUFBSSxDQUFDLFFBQVEsQ0FBQyxZQUFZOzRCQUMzQixJQUFJLENBQUMsUUFBUSxDQUFDLFdBQVc7UUFDN0Msc0JBQXNCLEVBQUU7Ozs7b0NBSUksSUFBSSxDQUFDLGFBQWE7Ozs7Ozt1Q0FNZixPQUFPO3lDQUNMLElBQUksQ0FBQyxhQUFhOzhCQUM3QixJQUFJLENBQUMsYUFBYTs7Ozs7Z0NBS2hCLElBQUksQ0FBQyxRQUFRLENBQUMsWUFBWTs7O2tDQUd4QixPQUFPOzs7b0NBR0wsSUFBSSxDQUFDLFFBQVEsQ0FBQyxXQUFXOztvQ0FFekIsSUFBSSxDQUFDLGFBQWE7Ozs7Ozs7OEJBT3hCLElBQUksQ0FBQyxhQUFhOzs7O2NBSWxDLHFCQUFxQixDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLFVBQVUsQ0FBQzs7Ozs7S0FLN0QsQ0FBQztRQUNGLE9BQU8sUUFBUSxDQUFDO0lBQ2xCLENBQUM7Q0FDRiIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuaW1wb3J0IHtiYWNrZW5kX3V0aWwsIHV0aWx9IGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XG5pbXBvcnQge2FjdGl2YXRpb25GblNuaXBwZXQsIGJpYXNBY3RpdmF0aW9uU25pcHBldH0gZnJvbSAnLi9hY3RpdmF0aW9uX3V0aWwnO1xuaW1wb3J0IHtnZXRXb3JrR3JvdXBTaXplU3RyaW5nLCBXZWJHUFVQcm9ncmFtfSBmcm9tICcuL3dlYmdwdV9wcm9ncmFtJztcbmltcG9ydCB7Y29tcHV0ZURpc3BhdGNofSBmcm9tICcuL3dlYmdwdV91dGlsJztcblxuZXhwb3J0IGNsYXNzIERlcHRod2lzZUNvbnYyRFZlYzRQcm9ncmFtIGltcGxlbWVudHMgV2ViR1BVUHJvZ3JhbSB7XG4gIG91dHB1dFNoYXBlOiBudW1iZXJbXTtcbiAgc2hhZGVyS2V5OiBzdHJpbmc7XG4gIGRpc3BhdGNoTGF5b3V0OiB7eDogbnVtYmVyW10sIHk6IG51bWJlcltdLCB6OiBudW1iZXJbXX07XG4gIGRpc3BhdGNoOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG4gIHZhcmlhYmxlTmFtZXMgPSBbJ3gnLCAnVyddO1xuICB1bmlmb3JtcyA9ICdwYWQgOiB2ZWMyPGkzMj4sIGluRGltcyA6IHZlYzI8aTMyPiwnO1xuICB3b3JrR3JvdXBTaXplOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0gPSBbNCwgNCwgNF07XG4gIHdvcmtQZXJUaHJlYWQgPSA0O1xuICBjb252SW5mbzogYmFja2VuZF91dGlsLkNvbnYyREluZm87XG4gIGFkZEJpYXM6IGJvb2xlYW47XG4gIGFjdGl2YXRpb246IGJhY2tlbmRfdXRpbC5BY3RpdmF0aW9uO1xuICBoYXNQcmVsdUFjdGl2YXRpb246IGJvb2xlYW47XG4gIGlzVmVjNCA9IHRydWU7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgICBjb252SW5mbzogYmFja2VuZF91dGlsLkNvbnYyREluZm8sIGFkZEJpYXMgPSBmYWxzZSxcbiAgICAgIGFjdGl2YXRpb246IGJhY2tlbmRfdXRpbC5BY3RpdmF0aW9uID0gbnVsbCwgaGFzUHJlbHVBY3RpdmF0aW9uID0gZmFsc2UpIHtcbiAgICB0aGlzLm91dHB1dFNoYXBlID0gY29udkluZm8ub3V0U2hhcGU7XG4gICAgdGhpcy5kaXNwYXRjaExheW91dCA9IHt4OiBbM10sIHk6IFsyXSwgejogWzAsIDFdfTtcbiAgICB0aGlzLmRpc3BhdGNoID0gY29tcHV0ZURpc3BhdGNoKFxuICAgICAgICB0aGlzLmRpc3BhdGNoTGF5b3V0LCB0aGlzLm91dHB1dFNoYXBlLCB0aGlzLndvcmtHcm91cFNpemUsXG4gICAgICAgIFs0LCB0aGlzLndvcmtQZXJUaHJlYWQsIDFdKTtcblxuICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICBjb252SW5mby5kYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNMYXN0JyxcbiAgICAgICAgKCkgPT4gJ1RPRE86IE5DSFcgaXMgdW5pbXBsZW1lbnRlZCcpO1xuXG4gICAgaWYgKGFkZEJpYXMpIHtcbiAgICAgIHRoaXMudmFyaWFibGVOYW1lcy5wdXNoKCdiaWFzJyk7XG4gICAgfVxuICAgIGlmIChoYXNQcmVsdUFjdGl2YXRpb24pIHtcbiAgICAgIHRoaXMudmFyaWFibGVOYW1lcy5wdXNoKCdwcmVsdUFjdGl2YXRpb25XZWlnaHRzJyk7XG4gICAgfVxuXG4gICAgdGhpcy5jb252SW5mbyA9IGNvbnZJbmZvO1xuICAgIHRoaXMuYWRkQmlhcyA9IGFkZEJpYXM7XG4gICAgdGhpcy5hY3RpdmF0aW9uID0gYWN0aXZhdGlvbjtcbiAgICB0aGlzLmhhc1ByZWx1QWN0aXZhdGlvbiA9IGhhc1ByZWx1QWN0aXZhdGlvbjtcblxuICAgIHRoaXMuc2hhZGVyS2V5ID1cbiAgICAgICAgYGRlcHRod2lzZVZlYzRfJHthY3RpdmF0aW9ufV8ke3RoaXMuY29udkluZm8uZmlsdGVySGVpZ2h0fV8ke1xuICAgICAgICAgICAgdGhpcy5jb252SW5mby5maWx0ZXJXaWR0aH1fJHt0aGlzLmNvbnZJbmZvLnN0cmlkZUhlaWdodH1fJHtcbiAgICAgICAgICAgIHRoaXMuY29udkluZm8uc3RyaWRlV2lkdGh9XyR7dGhpcy53b3JrUGVyVGhyZWFkfWA7XG4gIH1cblxuICBnZXRVc2VyQ29kZSgpOiBzdHJpbmcge1xuICAgIGNvbnN0IHhOdW1iZXIgPSAodGhpcy53b3JrUGVyVGhyZWFkIC0gMSkgKiB0aGlzLmNvbnZJbmZvLnN0cmlkZVdpZHRoICtcbiAgICAgICAgdGhpcy5jb252SW5mby5maWx0ZXJXaWR0aDtcblxuICAgIGNvbnN0IHVzZXJDb2RlID0gYFxuICAgICAgJHthY3RpdmF0aW9uRm5TbmlwcGV0KHRoaXMuYWN0aXZhdGlvbiwgdGhpcy5oYXNQcmVsdUFjdGl2YXRpb24sIHRydWUsIDQpfVxuICAgICAgZm4gcmVhZFgoYmF0Y2ggOiBpMzIsIHJvdyA6IGkzMiwgY29sIDogaTMyLCBjaGFubmVsIDogaTMyKSAtPiB2ZWM0PGYzMj4ge1xuICAgICAgICB2YXIgdmFsdWUgPSB2ZWM0PGYzMj4oMC4wKTtcbiAgICAgICAgaWYgKGNvbCA+PTAgJiYgY29sIDwgdW5pZm9ybXMuaW5EaW1zWzFdKSB7XG4gICAgICAgICAgdmFsdWUgPSBnZXRYKGJhdGNoLCByb3csIGNvbCwgY2hhbm5lbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBzdHJpZGVIZWlnaHQgPSAke3RoaXMuY29udkluZm8uc3RyaWRlSGVpZ2h0fTtcbiAgICAgIGNvbnN0IHN0cmlkZVdpZHRoID0gJHt0aGlzLmNvbnZJbmZvLnN0cmlkZVdpZHRofTtcbiAgICAgICR7Z2V0V29ya0dyb3VwU2l6ZVN0cmluZygpfVxuICAgICAgZm4gX3N0YXJ0KEBidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKSBnbG9iYWxJZDogdmVjMzx1MzI+KSB7XG4gICAgICAgIGxldCBiYXRjaCA9IGkzMihnbG9iYWxJZC56KSAvIHVuaWZvcm1zLm91dFNoYXBlWzFdO1xuICAgICAgICBsZXQgciA9IGkzMihnbG9iYWxJZC56KSAlIHVuaWZvcm1zLm91dFNoYXBlWzFdO1xuICAgICAgICBsZXQgYyA9IGkzMihnbG9iYWxJZC55KSAqICR7dGhpcy53b3JrUGVyVGhyZWFkfTtcbiAgICAgICAgbGV0IGQxID0gaTMyKGdsb2JhbElkLngpICogNDtcbiAgICAgICAgbGV0IHhSQ0Nvcm5lciA9IHZlYzI8aTMyPihyLCBjKSAqIHZlYzI8aTMyPihzdHJpZGVIZWlnaHQsIHN0cmlkZVdpZHRoKSAtIHVuaWZvcm1zLnBhZDtcblxuICAgICAgICBsZXQgeFJDb3JuZXIgPSB4UkNDb3JuZXIueDtcbiAgICAgICAgbGV0IHhDQ29ybmVyID0geFJDQ29ybmVyLnk7XG4gICAgICAgIHZhciB4VmFscyA6IGFycmF5PHZlYzQ8ZjMyPiwgJHt4TnVtYmVyfT47XG4gICAgICAgIHZhciBkb3RQcm9kIDogYXJyYXk8dmVjNDxmMzI+LCAke3RoaXMud29ya1BlclRocmVhZH0+O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8ICR7dGhpcy53b3JrUGVyVGhyZWFkfTsgaSsrKSB7XG4gICAgICAgICAgZG90UHJvZFtpXSA9IHZlYzQ8ZjMyPigwLjApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXNlIGNvbnN0YW50IGluc3RlYWQgb2YgdW5pZm9ybSBjYW4gZ2l2ZSBiZXR0ZXIgcGVyZm9ybWFuY2UuXG4gICAgICAgIGZvciAodmFyIHdSID0gMDsgd1IgPCAke3RoaXMuY29udkluZm8uZmlsdGVySGVpZ2h0fTsgd1IgPSB3UiArIDEpIHtcbiAgICAgICAgICBsZXQgeFIgPSB4UkNvcm5lciArIHdSO1xuICAgICAgICAgIGlmICh4UiA+PTAgJiYgeFIgPCB1bmlmb3Jtcy5pbkRpbXNbMF0pIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgJHt4TnVtYmVyfTsgaSsrKSB7XG4gICAgICAgICAgICAgIHhWYWxzW2ldID0gcmVhZFgoYmF0Y2gsIHhSLCB4Q0Nvcm5lciArIGksIGQxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIHdDID0gMDsgd0MgPCAke3RoaXMuY29udkluZm8uZmlsdGVyV2lkdGh9OyB3QyA9IHdDICsgMSkge1xuICAgICAgICAgICAgICBsZXQgd1ZhbHVlID0gZ2V0Vyh3Uiwgd0MsIGQxLCAwKTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAke3RoaXMud29ya1BlclRocmVhZH07IGkrKykge1xuICAgICAgICAgICAgICAgIGRvdFByb2RbaV0gPSBmbWEoeFZhbHNbaSAqIHN0cmlkZVdpZHRoICsgd0NdLCB3VmFsdWUsIGRvdFByb2RbaV0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAke3RoaXMud29ya1BlclRocmVhZH07IGkgPSBpICsgMSkge1xuICAgICAgICAgIGxldCBjb29yZHMgPSB2ZWM0PGkzMj4oYmF0Y2gsIHIsIGMgKyBpLCBkMSk7XG4gICAgICAgICAgaWYgKGNvb3Jkc0luQm91bmRzNEQoY29vcmRzLCB1bmlmb3Jtcy5vdXRTaGFwZSkpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGRvdFByb2RbaV07XG4gICAgICAgICAgICAke2JpYXNBY3RpdmF0aW9uU25pcHBldCh0aGlzLmFkZEJpYXMsIHRoaXMuYWN0aXZhdGlvbil9XG4gICAgICAgICAgICBzZXRPdXRwdXRBdENvb3Jkcyhjb29yZHNbMF0sIGNvb3Jkc1sxXSwgY29vcmRzWzJdLCBjb29yZHNbM10sIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBgO1xuICAgIHJldHVybiB1c2VyQ29kZTtcbiAgfVxufVxuIl19