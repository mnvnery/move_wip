/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import { util } from '@tensorflow/tfjs-core';
import { activationFnSnippet, biasActivationSnippet, typeSnippet } from './activation_util';
import { makeMatMulPackedSource, makeMatMulPackedVec4Source, matMulReadFnSource } from './matmul_packed_webgpu';
import { getMainHeaderString as main } from './webgpu_program';
import { computeDispatch, flatDispatchLayout } from './webgpu_util';
export class MatMulSplitKProgram {
    constructor(outputShape, dimInner, batchAEqualOne, batchBEqualOne, transposeA = false, transposeB = false) {
        this.variableNames = ['A', 'B'];
        this.uniforms = `dimAOuter : i32, dimBOuter : i32, dimInner : i32,`;
        this.workGroupSize = [8, 8, 1];
        this.atomic = true;
        this.isVec4 = false;
        this.splitedDimInner = 128;
        util.assert(outputShape[0] === 1, () => 'MatMulSplitKProgram only supports batch = 1.');
        this.outputShape = outputShape;
        this.dispatchLayout = { x: [2], y: [1], z: [0, 3] };
        this.isVec4 = (transposeA && this.outputShape[1] % 4 === 0 ||
            !transposeA && dimInner % 4 === 0) &&
            this.outputShape[2] % 4 === 0;
        this.elementsPerThread = [4, 4, this.splitedDimInner];
        if (!this.isVec4) {
            if (this.outputShape[1] < 16) {
                this.elementsPerThread[1] = 1;
            }
            if (this.outputShape[2] < 16) {
                this.elementsPerThread[0] = 1;
            }
        }
        this.dispatch = computeDispatch(this.dispatchLayout, [
            this.outputShape[0], this.outputShape[1], this.outputShape[2],
            dimInner
        ], this.workGroupSize, this.elementsPerThread);
        this.transposeA = transposeA;
        this.transposeB = transposeB;
        this.batchAEqualOne = batchAEqualOne;
        this.batchBEqualOne = batchBEqualOne;
        this.shaderKey =
            `matMulSplitK_${transposeA}_${transposeB}_${batchAEqualOne}_${batchBEqualOne}_${this.elementsPerThread}_${this.isVec4}`;
    }
    getUserCode() {
        // atomicAdd only supports uint/int type. For float, we use
        // atomicCompareExchangeWeak to simulate.
        const atomicAddSnippet = (component) => {
            return `
      for (var i = 0; i < ${component}; i = i + 1)
      {
        var oldValue = atomicLoad(&(result[flatIndex + i]));
        var exchanged = false;
        for (; !exchanged;) {
          let newValueF32 = bitcast<f32>(oldValue) + ${component > 1 ? 'value[i]' : 'value'};
          let newValue = bitcast<i32>(newValueF32);
          let res = atomicCompareExchangeWeak(&(result[flatIndex + i]), oldValue, newValue);
          oldValue = res.old_value;
          exchanged = res.exchanged;
        }
      }
      `;
        };
        const component = this.isVec4 ? 4 : 1;
        const userCode = `
      ${matMulReadFnSource(this.batchAEqualOne, this.batchBEqualOne, false, this.transposeB, false, false, false, component)}
      fn mm_write(batch: i32, row : i32, colIn : i32, value : ${typeSnippet(component)}) {
        let col = colIn * ${component};
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
          let coords = vec3<i32>(batch, row, col);
          let flatIndex = getOutputIndexFromCoords(coords);
          // The problem is that we should initialize output to zero before using.
          // Otherwise, the original value will be added to the result.
          ${atomicAddSnippet(component)}
        }
      }
      ${this.isVec4 ? makeMatMulPackedVec4Source(this.elementsPerThread, this.workGroupSize, this.transposeA, 32, true, this.splitedDimInner) :
            makeMatMulPackedSource(this.elementsPerThread, this.workGroupSize, this.transposeA, 32, true, this.splitedDimInner)}
    `;
        return userCode;
    }
}
export class BiasActivationProgram {
    constructor(outputShape, bias = null, activation = null, preluActivationWeights = null) {
        this.uniforms = '';
        this.variableNames = ['x'];
        this.workGroupSize = [64, 1, 1];
        this.size = true;
        this.outputShape = outputShape;
        this.dispatchLayout = flatDispatchLayout(this.outputShape);
        this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workGroupSize);
        this.addBias = bias != null;
        this.hasPreluActivationWeights = preluActivationWeights != null;
        this.activation = activation;
        if (this.addBias) {
            this.variableNames.push('bias');
        }
        if (this.hasPreluActivationWeights) {
            this.variableNames.push('preluActivationWeights');
        }
        this.shaderKey = `biasActivation_${activation}`;
    }
    getUserCode() {
        return `
    ${activationFnSnippet(this.activation, this.hasPreluActivationWeights)}
    ${main('index')} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        var value = getXByOutputIndex(index);
        ${biasActivationSnippet(this.addBias, this.activation)}
        setOutputAtIndex(index, value);
      }
    }
    `;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWF0bXVsX3NwbGl0S193ZWJncHUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi90ZmpzLWJhY2tlbmQtd2ViZ3B1L3NyYy9tYXRtdWxfc3BsaXRLX3dlYmdwdS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFFSCxPQUFPLEVBQTJCLElBQUksRUFBQyxNQUFNLHVCQUF1QixDQUFDO0FBRXJFLE9BQU8sRUFBQyxtQkFBbUIsRUFBRSxxQkFBcUIsRUFBRSxXQUFXLEVBQUMsTUFBTSxtQkFBbUIsQ0FBQztBQUMxRixPQUFPLEVBQUMsc0JBQXNCLEVBQUUsMEJBQTBCLEVBQUUsa0JBQWtCLEVBQUMsTUFBTSx3QkFBd0IsQ0FBQztBQUM5RyxPQUFPLEVBQUMsbUJBQW1CLElBQUksSUFBSSxFQUFnQixNQUFNLGtCQUFrQixDQUFDO0FBQzVFLE9BQU8sRUFBQyxlQUFlLEVBQUUsa0JBQWtCLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFFbEUsTUFBTSxPQUFPLG1CQUFtQjtJQWlCOUIsWUFDSSxXQUFxQyxFQUFFLFFBQWdCLEVBQ3ZELGNBQXVCLEVBQUUsY0FBdUIsRUFBRSxVQUFVLEdBQUcsS0FBSyxFQUNwRSxVQUFVLEdBQUcsS0FBSztRQWZ0QixrQkFBYSxHQUFHLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBQzNCLGFBQVEsR0FBRyxtREFBbUQsQ0FBQztRQUMvRCxrQkFBYSxHQUE2QixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFJcEQsV0FBTSxHQUFHLElBQUksQ0FBQztRQUdkLFdBQU0sR0FBRyxLQUFLLENBQUM7UUFDZixvQkFBZSxHQUFHLEdBQUcsQ0FBQztRQU1wQixJQUFJLENBQUMsTUFBTSxDQUNQLFdBQVcsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEVBQ3BCLEdBQUcsRUFBRSxDQUFDLDhDQUE4QyxDQUFDLENBQUM7UUFDMUQs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QyxDQUFDO1NBQ2pDO1FBRUQsSUFBSSxJQUFJLENBQUMseUJBQXlCLEVBQUU7WUFDbEMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsd0JBQXdCLENBQUMsQ0FBQztTQUNuRDtRQUVELElBQUksQ0FBQyxTQUFTLEdBQUcsa0JBQWtCLFVBQVUsRUFBRSxDQUFDO0lBQ2xELENBQUM7SUFFRCxXQUFXO1FBQ1QsT0FBTztNQUNMLG1CQUFtQixDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLHlCQUF5QixDQUFDO01BQ3BFLElBQUksQ0FBQyxPQUFPLENBQUM7Ozs7VUFJVCxxQkFBcUIsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxVQUFVLENBQUM7Ozs7S0FJekQsQ0FBQztJQUNKLENBQUM7Q0FDRiIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuaW1wb3J0IHtiYWNrZW5kX3V0aWwsIFRlbnNvckluZm8sIHV0aWx9IGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XG5cbmltcG9ydCB7YWN0aXZhdGlvbkZuU25pcHBldCwgYmlhc0FjdGl2YXRpb25TbmlwcGV0LCB0eXBlU25pcHBldH0gZnJvbSAnLi9hY3RpdmF0aW9uX3V0aWwnO1xuaW1wb3J0IHttYWtlTWF0TXVsUGFja2VkU291cmNlLCBtYWtlTWF0TXVsUGFja2VkVmVjNFNvdXJjZSwgbWF0TXVsUmVhZEZuU291cmNlfSBmcm9tICcuL21hdG11bF9wYWNrZWRfd2ViZ3B1JztcbmltcG9ydCB7Z2V0TWFpbkhlYWRlclN0cmluZyBhcyBtYWluLCBXZWJHUFVQcm9ncmFtfSBmcm9tICcuL3dlYmdwdV9wcm9ncmFtJztcbmltcG9ydCB7Y29tcHV0ZURpc3BhdGNoLCBmbGF0RGlzcGF0Y2hMYXlvdXR9IGZyb20gJy4vd2ViZ3B1X3V0aWwnO1xuXG5leHBvcnQgY2xhc3MgTWF0TXVsU3BsaXRLUHJvZ3JhbSBpbXBsZW1lbnRzIFdlYkdQVVByb2dyYW0ge1xuICBvdXRwdXRTaGFwZTogbnVtYmVyW107XG4gIHNoYWRlcktleTogc3RyaW5nO1xuICBkaXNwYXRjaExheW91dDoge3g6IG51bWJlcltdLCB5OiBudW1iZXJbXSwgejogbnVtYmVyW119O1xuICBkaXNwYXRjaDogW251bWJlciwgbnVtYmVyLCBudW1iZXJdO1xuICB2YXJpYWJsZU5hbWVzID0gWydBJywgJ0InXTtcbiAgdW5pZm9ybXMgPSBgZGltQU91dGVyIDogaTMyLCBkaW1CT3V0ZXIgOiBpMzIsIGRpbUlubmVyIDogaTMyLGA7XG4gIHdvcmtHcm91cFNpemU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSA9IFs4LCA4LCAxXTtcbiAgZWxlbWVudHNQZXJUaHJlYWQ6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbiAgdHJhbnNwb3NlQTogYm9vbGVhbjtcbiAgdHJhbnNwb3NlQjogYm9vbGVhbjtcbiAgYXRvbWljID0gdHJ1ZTtcbiAgYmF0Y2hBRXF1YWxPbmU6IGJvb2xlYW47XG4gIGJhdGNoQkVxdWFsT25lOiBib29sZWFuO1xuICBpc1ZlYzQgPSBmYWxzZTtcbiAgc3BsaXRlZERpbUlubmVyID0gMTI4O1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgICAgb3V0cHV0U2hhcGU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSwgZGltSW5uZXI6IG51bWJlcixcbiAgICAgIGJhdGNoQUVxdWFsT25lOiBib29sZWFuLCBiYXRjaEJFcXVhbE9uZTogYm9vbGVhbiwgdHJhbnNwb3NlQSA9IGZhbHNlLFxuICAgICAgdHJhbnNwb3NlQiA9IGZhbHNlKSB7XG4gICAgdXRpbC5hc3NlcnQoXG4gICAgICAgIG91dHB1dFNoYXBlWzBdID09PSAxLFxuICAgICAgICAoKSA9PiAnTWF0TXVsU3BsaXRLUHJvZ3JhbSBvbmx5IHN1cHBvcnRzIGJhdGNoID0gMS4nKTtcbiAgICB0aGlzLm91dHB1dFNoYXBlID0gb3V0cHV0U2hhcGU7XG4gICAgdGhpcy5kaXNwYXRjaExheW91dCA9IHt4OiBbMl0sIHk6IFsxXSwgejogWzAsIDNdfTtcbiAgICB0aGlzLmlzVmVjNCA9ICh0cmFuc3Bvc2VBICYmIHRoaXMub3V0cHV0U2hhcGVbMV0gJSA0ID09PSAwIHx8XG4gICAgICAgICAgICAgICAgICAgIXRyYW5zcG9zZUEgJiYgZGltSW5uZXIgJSA0ID09PSAwKSAmJlxuICAgICAgICB0aGlzLm91dHB1dFNoYXBlWzJdICUgNCA9PT0gMDtcbiAgICB0aGlzLmVsZW1lbnRzUGVyVGhyZWFkID0gWzQsIDQsIHRoaXMuc3BsaXRlZERpbUlubmVyXTtcblxuICAgIGlmICghdGhpcy5pc1ZlYzQpIHtcbiAgICAgIGlmICh0aGlzLm91dHB1dFNoYXBlWzFdIDwgMTYpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50c1BlclRocmVhZFsxXSA9IDE7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5vdXRwdXRTaGFwZVsyXSA8IDE2KSB7XG4gICAgICAgIHRoaXMuZWxlbWVudHNQZXJUaHJlYWRbMF0gPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuZGlzcGF0Y2ggPSBjb21wdXRlRGlzcGF0Y2goXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hMYXlvdXQsXG4gICAgICAgIFtcbiAgICAgICAgICB0aGlzLm91dHB1dFNoYXBlWzBdLCB0aGlzLm91dHB1dFNoYXBlWzFdLCB0aGlzLm91dHB1dFNoYXBlWzJdLFxuICAgICAgICAgIGRpbUlubmVyXG4gICAgICAgIF0sXG4gICAgICAgIHRoaXMud29ya0dyb3VwU2l6ZSwgdGhpcy5lbGVtZW50c1BlclRocmVhZCk7XG5cbiAgICB0aGlzLnRyYW5zcG9zZUEgPSB0cmFuc3Bvc2VBO1xuICAgIHRoaXMudHJhbnNwb3NlQiA9IHRyYW5zcG9zZUI7XG4gICAgdGhpcy5iYXRjaEFFcXVhbE9uZSA9IGJhdGNoQUVxdWFsT25lO1xuICAgIHRoaXMuYmF0Y2hCRXF1YWxPbmUgPSBiYXRjaEJFcXVhbE9uZTtcbiAgICB0aGlzLnNoYWRlcktleSA9XG4gICAgICAgIGBtYXRNdWxTcGxpdEtfJHt0cmFuc3Bvc2VBfV8ke3RyYW5zcG9zZUJ9XyR7YmF0Y2hBRXF1YWxPbmV9XyR7XG4gICAgICAgICAgICBiYXRjaEJFcXVhbE9uZX1fJHt0aGlzLmVsZW1lbnRzUGVyVGhyZWFkfV8ke3RoaXMuaXNWZWM0fWA7XG4gIH1cblxuICBnZXRVc2VyQ29kZSgpOiBzdHJpbmcge1xuICAgIC8vIGF0b21pY0FkZCBvbmx5IHN1cHBvcnRzIHVpbnQvaW50IHR5cGUuIEZvciBmbG9hdCwgd2UgdXNlXG4gICAgLy8gYXRvbWljQ29tcGFyZUV4Y2hhbmdlV2VhayB0byBzaW11bGF0ZS5cbiAgICBjb25zdCBhdG9taWNBZGRTbmlwcGV0ID0gKGNvbXBvbmVudDogbnVtYmVyKSA9PiB7XG4gICAgICByZXR1cm4gYFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAke2NvbXBvbmVudH07IGkgPSBpICsgMSlcbiAgICAgIHtcbiAgICAgICAgdmFyIG9sZFZhbHVlID0gYXRvbWljTG9hZCgmKHJlc3VsdFtmbGF0SW5kZXggKyBpXSkpO1xuICAgICAgICB2YXIgZXhjaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIGZvciAoOyAhZXhjaGFuZ2VkOykge1xuICAgICAgICAgIGxldCBuZXdWYWx1ZUYzMiA9IGJpdGNhc3Q8ZjMyPihvbGRWYWx1ZSkgKyAke1xuICAgICAgICAgIGNvbXBvbmVudCA+IDEgPyAndmFsdWVbaV0nIDogJ3ZhbHVlJ307XG4gICAgICAgICAgbGV0IG5ld1ZhbHVlID0gYml0Y2FzdDxpMzI+KG5ld1ZhbHVlRjMyKTtcbiAgICAgICAgICBsZXQgcmVzID0gYXRvbWljQ29tcGFyZUV4Y2hhbmdlV2VhaygmKHJlc3VsdFtmbGF0SW5kZXggKyBpXSksIG9sZFZhbHVlLCBuZXdWYWx1ZSk7XG4gICAgICAgICAgb2xkVmFsdWUgPSByZXMub2xkX3ZhbHVlO1xuICAgICAgICAgIGV4Y2hhbmdlZCA9IHJlcy5leGNoYW5nZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGA7XG4gICAgfTtcblxuICAgIGNvbnN0IGNvbXBvbmVudCA9IHRoaXMuaXNWZWM0ID8gNCA6IDE7XG4gICAgY29uc3QgdXNlckNvZGUgPSBgXG4gICAgICAke1xuICAgICAgICBtYXRNdWxSZWFkRm5Tb3VyY2UoXG4gICAgICAgICAgICB0aGlzLmJhdGNoQUVxdWFsT25lLCB0aGlzLmJhdGNoQkVxdWFsT25lLCBmYWxzZSwgdGhpcy50cmFuc3Bvc2VCLFxuICAgICAgICAgICAgZmFsc2UsIGZhbHNlLCBmYWxzZSwgY29tcG9uZW50KX1cbiAgICAgIGZuIG1tX3dyaXRlKGJhdGNoOiBpMzIsIHJvdyA6IGkzMiwgY29sSW4gOiBpMzIsIHZhbHVlIDogJHtcbiAgICAgICAgdHlwZVNuaXBwZXQoY29tcG9uZW50KX0pIHtcbiAgICAgICAgbGV0IGNvbCA9IGNvbEluICogJHtjb21wb25lbnR9O1xuICAgICAgICBpZiAocm93IDwgdW5pZm9ybXMuZGltQU91dGVyICYmIGNvbCA8IHVuaWZvcm1zLmRpbUJPdXRlcikge1xuICAgICAgICAgIGxldCBjb29yZHMgPSB2ZWMzPGkzMj4oYmF0Y2gsIHJvdywgY29sKTtcbiAgICAgICAgICBsZXQgZmxhdEluZGV4ID0gZ2V0T3V0cHV0SW5kZXhGcm9tQ29vcmRzKGNvb3Jkcyk7XG4gICAgICAgICAgLy8gVGhlIHByb2JsZW0gaXMgdGhhdCB3ZSBzaG91bGQgaW5pdGlhbGl6ZSBvdXRwdXQgdG8gemVybyBiZWZvcmUgdXNpbmcuXG4gICAgICAgICAgLy8gT3RoZXJ3aXNlLCB0aGUgb3JpZ2luYWwgdmFsdWUgd2lsbCBiZSBhZGRlZCB0byB0aGUgcmVzdWx0LlxuICAgICAgICAgICR7YXRvbWljQWRkU25pcHBldChjb21wb25lbnQpfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAke1xuICAgICAgICB0aGlzLmlzVmVjNCA/IG1ha2VNYXRNdWxQYWNrZWRWZWM0U291cmNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnRzUGVyVGhyZWFkLCB0aGlzLndvcmtHcm91cFNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhbnNwb3NlQSwgMzIsIHRydWUsIHRoaXMuc3BsaXRlZERpbUlubmVyKSA6XG4gICAgICAgICAgICAgICAgICAgICAgbWFrZU1hdE11bFBhY2tlZFNvdXJjZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50c1BlclRocmVhZCwgdGhpcy53b3JrR3JvdXBTaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYW5zcG9zZUEsIDMyLCB0cnVlLCB0aGlzLnNwbGl0ZWREaW1Jbm5lcil9XG4gICAgYDtcbiAgICByZXR1cm4gdXNlckNvZGU7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEJpYXNBY3RpdmF0aW9uUHJvZ3JhbSBpbXBsZW1lbnRzIFdlYkdQVVByb2dyYW0ge1xuICBvdXRwdXRTaGFwZTogbnVtYmVyW107XG4gIHNoYWRlcktleTogc3RyaW5nO1xuICB1bmlmb3JtcyA9ICcnO1xuICBkaXNwYXRjaExheW91dDoge3g6IG51bWJlcltdfTtcbiAgZGlzcGF0Y2g6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbiAgdmFyaWFibGVOYW1lcyA9IFsneCddO1xuICB3b3JrR3JvdXBTaXplOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0gPSBbNjQsIDEsIDFdO1xuICBzaXplID0gdHJ1ZTtcbiAgcHJpdmF0ZSBhZGRCaWFzOiBib29sZWFuO1xuICBwcml2YXRlIGFjdGl2YXRpb246IGJhY2tlbmRfdXRpbC5BY3RpdmF0aW9uO1xuICBwcml2YXRlIGhhc1ByZWx1QWN0aXZhdGlvbldlaWdodHM6IGJvb2xlYW47XG5cbiAgY29uc3RydWN0b3IoXG4gICAgICBvdXRwdXRTaGFwZTogbnVtYmVyW10sIGJpYXM6IFRlbnNvckluZm8gPSBudWxsLFxuICAgICAgYWN0aXZhdGlvbjogYmFja2VuZF91dGlsLkFjdGl2YXRpb24gPSBudWxsLFxuICAgICAgcHJlbHVBY3RpdmF0aW9uV2VpZ2h0czogVGVuc29ySW5mbyA9IG51bGwpIHtcbiAgICB0aGlzLm91dHB1dFNoYXBlID0gb3V0cHV0U2hhcGU7XG4gICAgdGhpcy5kaXNwYXRjaExheW91dCA9IGZsYXREaXNwYXRjaExheW91dCh0aGlzLm91dHB1dFNoYXBlKTtcbiAgICB0aGlzLmRpc3BhdGNoID0gY29tcHV0ZURpc3BhdGNoKFxuICAgICAgICB0aGlzLmRpc3BhdGNoTGF5b3V0LCB0aGlzLm91dHB1dFNoYXBlLCB0aGlzLndvcmtHcm91cFNpemUpO1xuICAgIHRoaXMuYWRkQmlhcyA9IGJpYXMgIT0gbnVsbDtcbiAgICB0aGlzLmhhc1ByZWx1QWN0aXZhdGlvbldlaWdodHMgPSBwcmVsdUFjdGl2YXRpb25XZWlnaHRzICE9IG51bGw7XG4gICAgdGhpcy5hY3RpdmF0aW9uID0gYWN0aXZhdGlvbjtcbiAgICBpZiAodGhpcy5hZGRCaWFzKSB7XG4gICAgICB0aGlzLnZhcmlhYmxlTmFtZXMucHVzaCgnYmlhcycpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmhhc1ByZWx1QWN0aXZhdGlvbldlaWdodHMpIHtcbiAgICAgIHRoaXMudmFyaWFibGVOYW1lcy5wdXNoKCdwcmVsdUFjdGl2YXRpb25XZWlnaHRzJyk7XG4gICAgfVxuXG4gICAgdGhpcy5zaGFkZXJLZXkgPSBgYmlhc0FjdGl2YXRpb25fJHthY3RpdmF0aW9ufWA7XG4gIH1cblxuICBnZXRVc2VyQ29kZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiBgXG4gICAgJHthY3RpdmF0aW9uRm5TbmlwcGV0KHRoaXMuYWN0aXZhdGlvbiwgdGhpcy5oYXNQcmVsdUFjdGl2YXRpb25XZWlnaHRzKX1cbiAgICAke21haW4oJ2luZGV4Jyl9IHtcbiAgICAgIGlmIChpbmRleCA8IHVuaWZvcm1zLnNpemUpIHtcbiAgICAgICAgbGV0IGNvb3JkcyA9IGdldENvb3Jkc0Zyb21JbmRleChpbmRleCk7XG4gICAgICAgIHZhciB2YWx1ZSA9IGdldFhCeU91dHB1dEluZGV4KGluZGV4KTtcbiAgICAgICAgJHtiaWFzQWN0aXZhdGlvblNuaXBwZXQodGhpcy5hZGRCaWFzLCB0aGlzLmFjdGl2YXRpb24pfVxuICAgICAgICBzZXRPdXRwdXRBdEluZGV4KGluZGV4LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGA7XG4gIH1cbn1cbiJdfQ==