/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import { util } from '@tensorflow/tfjs-core';
import { typeSnippet } from './activation_util';
import { makeMatMulPackedSource, makeMatMulPackedVec4Source } from './matmul_packed_webgpu';
import { computeDispatch, computeWorkGroupSizeForConv2d, computeWorkPerThreadForConv2d } from './webgpu_util';
function conv2dTransposeCommonSnippet(innerElementSize = 4) {
    const getWSnippet = (innerElementSize) => {
        switch (innerElementSize) {
            case 1:
                return 'return W[getIndexFromCoords4D(coord, uniforms.wShape)];';
            case 4:
                return `
            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);
            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);
            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);
            let v0 = W[getIndexFromCoords4D(coord, uniforms.wShape)];
            let v1 = W[getIndexFromCoords4D(coord1, uniforms.wShape)];
            let v2 = W[getIndexFromCoords4D(coord2, uniforms.wShape)];
            let v3 = W[getIndexFromCoords4D(coord3, uniforms.wShape)];
            return vec4<f32>(v0, v1, v2, v3);
            `;
            default:
                throw new Error(`innerElementSize ${innerElementSize} is not supported.`);
        }
    };
    const readASnippet = `
      let outRow = row / uniforms.outShape[2];
      let outCol = row % uniforms.outShape[2];

      let WRow = col / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
      let WCol = col / uniforms.outBackprop[3] % uniforms.filterDims[1];
      let xR = f32(outRow - uniforms.pads[0] + WRow) / f32(uniforms.stride[0]);
      let xC = f32(outCol - uniforms.pads[1] + WCol) / f32(uniforms.stride[1]);
      if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {
        return ${typeSnippet(innerElementSize)}(0.0);
      }
      if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {
        return ${typeSnippet(innerElementSize)}(0.0);
      }
      let coord = vec4<i32>(
          batch,
          i32(xR),
          i32(xC),
          col % uniforms.outBackprop[3]);
      return x[getIndexFromCoords4D(coord, uniforms.xShape)/${innerElementSize}];`;
    const sampleA = `if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${readASnippet}
      }
      return ${typeSnippet(innerElementSize)}(0.0);`;
    const userCode = `
  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${typeSnippet(innerElementSize)} {
    let col = colIn * ${innerElementSize};
    ${sampleA}
  }

  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${typeSnippet(innerElementSize)} {
    let col = colIn * ${innerElementSize};
    let coordX = uniforms.filterDims.x - 1 -
        row / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
    let coordY = uniforms.filterDims.y - 1 -
        (row / uniforms.outBackprop[3]) % uniforms.filterDims[1];
    if (row < uniforms.dimInner && col < uniforms.dimBOuter &&
        coordX >= 0 && coordY >= 0) {
      let rowInner = row % uniforms.outBackprop[3];
      let coord = vec4<i32>(coordX, coordY, col, rowInner);
      ${getWSnippet(innerElementSize)}
    }
    return ${typeSnippet(innerElementSize)}(0.0);
  }

  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${typeSnippet(innerElementSize)}) {
    let col = colIn * ${innerElementSize};
    if (row < uniforms.dimAOuter && (col + ${innerElementSize - 1}) < uniforms.dimBOuter) {
      var value = valueInput;
      let outCoord = vec4<i32>(
          batch,
          row / uniforms.outShape[2],
          row % uniforms.outShape[2],
          col);
      result[getIndexFromCoords4D(outCoord, uniforms.outShape)/${innerElementSize}] = value;
    }
  }`;
    return userCode;
}
export class Conv2DDerInputMMProgram {
    constructor(convInfo) {
        this.variableNames = ['x', 'W'];
        this.uniforms = 'filterDims : vec2<i32>, pads : vec2<i32>, stride : vec2<i32>, outBackprop : vec4<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,';
        this.outputShape = convInfo.inShape;
        util.assert(convInfo.dataFormat === 'channelsLast', () => 'TODO: NCHW is unimplemented');
        this.isVec4 =
            convInfo.inChannels % 4 === 0 && convInfo.outChannels % 4 === 0;
        this.dispatchLayout = { x: [3], y: [1, 2], z: [0] };
        this.workGroupSize = computeWorkGroupSizeForConv2d(this.dispatchLayout, this.outputShape, this.isVec4);
        this.elementsPerThread = computeWorkPerThreadForConv2d(this.dispatchLayout, this.outputShape, this.isVec4);
        this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workGroupSize, this.elementsPerThread);
        if (this.isVec4) {
            this.variableTypes = ['vec4<f32>', 'f32'];
        }
        this.shaderKey =
            `conv2DDerInputMM_${this.isVec4}_${this.elementsPerThread}`;
    }
    getUserCode() {
        const matMulSource = this.isVec4 ?
            makeMatMulPackedVec4Source(this.elementsPerThread, this.workGroupSize) :
            makeMatMulPackedSource(this.elementsPerThread, this.workGroupSize);
        const userCode = `
    ${conv2dTransposeCommonSnippet(this.isVec4 ? 4 : 1)}
    ${matMulSource}
    `;
        return userCode;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udl9iYWNrcHJvcF9tbV93ZWJncHUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi90ZmpzLWJhY2tlbmQtd2ViZ3B1L3NyYy9jb252X2JhY2twcm9wX21tX3dlYmdwdS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFFSCxPQUFPLEVBQWUsSUFBSSxFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFDekQsT0FBTyxFQUFDLFdBQVcsRUFBQyxNQUFNLG1CQUFtQixDQUFDO0FBQzlDLE9BQU8sRUFBQyxzQkFBc0IsRUFBRSwwQkFBMEIsRUFBQyxNQUFNLHdCQUF3QixDQUFDO0FBRTFGLE9BQU8sRUFBQyxlQUFlLEVBQUUsNkJBQTZCLEVBQUUsNkJBQTZCLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFFNUcsU0FBUyw0QkFBNEIsQ0FBQyxnQkFBZ0IsR0FBRyxDQUFDO0lBQ3hELE1BQU0sV0FBVyxHQUFHLENBQUMsZ0JBQXdCLEVBQUUsRUFBRTtRQUMvQyxRQUFRLGdCQUFnQixFQUFFO1lBQ3hCLEtBQUssQ0FBQztnQkFDSixPQUFPLHlEQUF5RCxDQUFDO1lBQ25FLEtBQUssQ0FBQztnQkFDSixPQUFPOzs7Ozs7Ozs7YUFTRixDQUFDO1lBQ1I7Z0JBQ0UsTUFBTSxJQUFJLEtBQUssQ0FDWCxvQkFBb0IsZ0JBQWdCLG9CQUFvQixDQUFDLENBQUM7U0FDakU7SUFDSCxDQUFDLENBQUM7SUFFRixNQUFNLFlBQVksR0FBRzs7Ozs7Ozs7O2lCQVNOLFdBQVcsQ0FBQyxnQkFBZ0IsQ0FBQzs7O2lCQUc3QixXQUFXLENBQUMsZ0JBQWdCLENBQUM7Ozs7Ozs7OERBUXhDLGdCQUFnQixJQUFJLENBQUM7SUFFekIsTUFBTSxPQUFPLEdBQUc7VUFDUixZQUFZOztlQUVQLFdBQVcsQ0FBQyxnQkFBZ0IsQ0FBQyxRQUFRLENBQUM7SUFFbkQsTUFBTSxRQUFRLEdBQUc7dURBRWIsV0FBVyxDQUFDLGdCQUFnQixDQUFDO3dCQUNYLGdCQUFnQjtNQUNsQyxPQUFPOzs7dURBSVAsV0FBVyxDQUFDLGdCQUFnQixDQUFDO3dCQUNYLGdCQUFnQjs7Ozs7Ozs7O1FBU2hDLFdBQVcsQ0FBQyxnQkFBZ0IsQ0FBQzs7YUFFeEIsV0FBVyxDQUFDLGdCQUFnQixDQUFDOzs7aUVBSXBDLFdBQVcsQ0FBQyxnQkFBZ0IsQ0FBQzt3QkFDWCxnQkFBZ0I7NkNBRWxDLGdCQUFnQixHQUFHLENBQUM7Ozs7Ozs7aUVBUXBCLGdCQUFnQjs7SUFFbEIsQ0FBQztJQUNILE9BQU8sUUFBUSxDQUFDO0FBQ2xCLENBQUM7QUFFRCxNQUFNLE9BQU8sdUJBQXVCO0lBYWxDLFlBQVksUUFBaUM7UUFSN0Msa0JBQWEsR0FBRyxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQztRQUUzQixhQUFRLEdBQ0osMElBQTBJLENBQUM7UUFNN0ksSUFBSSxDQUFDLFdBQVcsR0FBRyxRQUFRLENBQUMsT0FBTyxDQUFDO1FBRXBDLElBQUksQ0FBQyxNQUFNLENBQ1AsUUFBUSxDQUFDLFVBQVUsS0FBSyxjQUFjLEVBQ3RDLEdBQUcsRUFBRSxDQUFDLDZCQUE2QixDQUFDLENBQUM7UUFDekMsSUFBSSxDQUFDLE1BQU07WUFDUCxRQUFRLENBQUMsVUFBVSxHQUFHLENBQUMsS0FBSyxDQUFDLElBQUksUUFBUSxDQUFDLFdBQVcsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ3BFLElBQUksQ0FBQyxjQUFjLEdBQUcsRUFBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQztRQUNsRCxJQUFJLENBQUMsYUFBYSxHQUFHLDZCQUE2QixDQUM5QyxJQUFJLENBQUMsY0FBYyxFQUFFLElBQUksQ0FBQyxXQUFXLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ3hELElBQUksQ0FBQyxpQkFBaUIsR0FBRyw2QkFBNkIsQ0FDbEQsSUFBSSxDQUFDLGNBQWMsRUFBRSxJQUFJLENBQUMsV0FBVyxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUV4RCxJQUFJLENBQUMsUUFBUSxHQUFHLGVBQWUsQ0FDM0IsSUFBSSxDQUFDLGNBQWMsRUFBRSxJQUFJLENBQUMsV0FBVyxFQUFFLElBQUksQ0FBQyxhQUFhLEVBQ3pELElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO1FBRTVCLElBQUksSUFBSSxDQUFDLE1BQU0sRUFBRTtZQUNmLElBQUksQ0FBQyxhQUFhLEdBQUcsQ0FBQyxXQUFXLEVBQUUsS0FBSyxDQUFDLENBQUM7U0FDM0M7UUFFRCxJQUFJLENBQUMsU0FBUztZQUNWLG9CQUFvQixJQUFJLENBQUMsTUFBTSxJQUFJLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO0lBQ2xFLENBQUM7SUFFRCxXQUFXO1FBQ1QsTUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQzlCLDBCQUEwQixDQUFDLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQztZQUN4RSxzQkFBc0IsQ0FBQyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1FBQ3ZFLE1BQU0sUUFBUSxHQUFHO01BQ2YsNEJBQTRCLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7TUFDakQsWUFBWTtLQUNiLENBQUM7UUFDRixPQUFPLFFBQVEsQ0FBQztJQUNsQixDQUFDO0NBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmltcG9ydCB7YmFja2VuZF91dGlsLCB1dGlsfSBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xuaW1wb3J0IHt0eXBlU25pcHBldH0gZnJvbSAnLi9hY3RpdmF0aW9uX3V0aWwnO1xuaW1wb3J0IHttYWtlTWF0TXVsUGFja2VkU291cmNlLCBtYWtlTWF0TXVsUGFja2VkVmVjNFNvdXJjZX0gZnJvbSAnLi9tYXRtdWxfcGFja2VkX3dlYmdwdSc7XG5pbXBvcnQge1dlYkdQVVByb2dyYW19IGZyb20gJy4vd2ViZ3B1X3Byb2dyYW0nO1xuaW1wb3J0IHtjb21wdXRlRGlzcGF0Y2gsIGNvbXB1dGVXb3JrR3JvdXBTaXplRm9yQ29udjJkLCBjb21wdXRlV29ya1BlclRocmVhZEZvckNvbnYyZH0gZnJvbSAnLi93ZWJncHVfdXRpbCc7XG5cbmZ1bmN0aW9uIGNvbnYyZFRyYW5zcG9zZUNvbW1vblNuaXBwZXQoaW5uZXJFbGVtZW50U2l6ZSA9IDQpIHtcbiAgY29uc3QgZ2V0V1NuaXBwZXQgPSAoaW5uZXJFbGVtZW50U2l6ZTogbnVtYmVyKSA9PiB7XG4gICAgc3dpdGNoIChpbm5lckVsZW1lbnRTaXplKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiAncmV0dXJuIFdbZ2V0SW5kZXhGcm9tQ29vcmRzNEQoY29vcmQsIHVuaWZvcm1zLndTaGFwZSldOyc7XG4gICAgICBjYXNlIDQ6XG4gICAgICAgIHJldHVybiBgXG4gICAgICAgICAgICBsZXQgY29vcmQxID0gdmVjNDxpMzI+KGNvb3JkWCwgY29vcmRZLCBjb2wgKyAxLCByb3dJbm5lcik7XG4gICAgICAgICAgICBsZXQgY29vcmQyID0gdmVjNDxpMzI+KGNvb3JkWCwgY29vcmRZLCBjb2wgKyAyLCByb3dJbm5lcik7XG4gICAgICAgICAgICBsZXQgY29vcmQzID0gdmVjNDxpMzI+KGNvb3JkWCwgY29vcmRZLCBjb2wgKyAzLCByb3dJbm5lcik7XG4gICAgICAgICAgICBsZXQgdjAgPSBXW2dldEluZGV4RnJvbUNvb3JkczREKGNvb3JkLCB1bmlmb3Jtcy53U2hhcGUpXTtcbiAgICAgICAgICAgIGxldCB2MSA9IFdbZ2V0SW5kZXhGcm9tQ29vcmRzNEQoY29vcmQxLCB1bmlmb3Jtcy53U2hhcGUpXTtcbiAgICAgICAgICAgIGxldCB2MiA9IFdbZ2V0SW5kZXhGcm9tQ29vcmRzNEQoY29vcmQyLCB1bmlmb3Jtcy53U2hhcGUpXTtcbiAgICAgICAgICAgIGxldCB2MyA9IFdbZ2V0SW5kZXhGcm9tQ29vcmRzNEQoY29vcmQzLCB1bmlmb3Jtcy53U2hhcGUpXTtcbiAgICAgICAgICAgIHJldHVybiB2ZWM0PGYzMj4odjAsIHYxLCB2MiwgdjMpO1xuICAgICAgICAgICAgYDtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBpbm5lckVsZW1lbnRTaXplICR7aW5uZXJFbGVtZW50U2l6ZX0gaXMgbm90IHN1cHBvcnRlZC5gKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgcmVhZEFTbmlwcGV0ID0gYFxuICAgICAgbGV0IG91dFJvdyA9IHJvdyAvIHVuaWZvcm1zLm91dFNoYXBlWzJdO1xuICAgICAgbGV0IG91dENvbCA9IHJvdyAlIHVuaWZvcm1zLm91dFNoYXBlWzJdO1xuXG4gICAgICBsZXQgV1JvdyA9IGNvbCAvICh1bmlmb3Jtcy5maWx0ZXJEaW1zWzFdICogdW5pZm9ybXMub3V0QmFja3Byb3BbM10pO1xuICAgICAgbGV0IFdDb2wgPSBjb2wgLyB1bmlmb3Jtcy5vdXRCYWNrcHJvcFszXSAlIHVuaWZvcm1zLmZpbHRlckRpbXNbMV07XG4gICAgICBsZXQgeFIgPSBmMzIob3V0Um93IC0gdW5pZm9ybXMucGFkc1swXSArIFdSb3cpIC8gZjMyKHVuaWZvcm1zLnN0cmlkZVswXSk7XG4gICAgICBsZXQgeEMgPSBmMzIob3V0Q29sIC0gdW5pZm9ybXMucGFkc1sxXSArIFdDb2wpIC8gZjMyKHVuaWZvcm1zLnN0cmlkZVsxXSk7XG4gICAgICBpZiAoeFIgPCAwLjAgfHwgeFIgPj0gZjMyKHVuaWZvcm1zLm91dEJhY2twcm9wWzFdKSB8fCBmcmFjdCh4UikgPiAwLjApIHtcbiAgICAgICAgcmV0dXJuICR7dHlwZVNuaXBwZXQoaW5uZXJFbGVtZW50U2l6ZSl9KDAuMCk7XG4gICAgICB9XG4gICAgICBpZiAoeEMgPCAwLjAgfHwgeEMgPj0gZjMyKHVuaWZvcm1zLm91dEJhY2twcm9wWzJdKSB8fCBmcmFjdCh4QykgPiAwLjApIHtcbiAgICAgICAgcmV0dXJuICR7dHlwZVNuaXBwZXQoaW5uZXJFbGVtZW50U2l6ZSl9KDAuMCk7XG4gICAgICB9XG4gICAgICBsZXQgY29vcmQgPSB2ZWM0PGkzMj4oXG4gICAgICAgICAgYmF0Y2gsXG4gICAgICAgICAgaTMyKHhSKSxcbiAgICAgICAgICBpMzIoeEMpLFxuICAgICAgICAgIGNvbCAlIHVuaWZvcm1zLm91dEJhY2twcm9wWzNdKTtcbiAgICAgIHJldHVybiB4W2dldEluZGV4RnJvbUNvb3JkczREKGNvb3JkLCB1bmlmb3Jtcy54U2hhcGUpLyR7XG4gICAgICBpbm5lckVsZW1lbnRTaXplfV07YDtcblxuICBjb25zdCBzYW1wbGVBID0gYGlmIChyb3cgPCB1bmlmb3Jtcy5kaW1BT3V0ZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltSW5uZXIpIHtcbiAgICAgICAgJHtyZWFkQVNuaXBwZXR9XG4gICAgICB9XG4gICAgICByZXR1cm4gJHt0eXBlU25pcHBldChpbm5lckVsZW1lbnRTaXplKX0oMC4wKTtgO1xuXG4gIGNvbnN0IHVzZXJDb2RlID0gYFxuICBmbiBtbV9yZWFkQShiYXRjaDogaTMyLCByb3cgOiBpMzIsIGNvbEluIDogaTMyKSAtPiAke1xuICAgICAgdHlwZVNuaXBwZXQoaW5uZXJFbGVtZW50U2l6ZSl9IHtcbiAgICBsZXQgY29sID0gY29sSW4gKiAke2lubmVyRWxlbWVudFNpemV9O1xuICAgICR7c2FtcGxlQX1cbiAgfVxuXG4gIGZuIG1tX3JlYWRCKGJhdGNoOiBpMzIsIHJvdyA6IGkzMiwgY29sSW4gOiBpMzIpIC0+ICR7XG4gICAgICB0eXBlU25pcHBldChpbm5lckVsZW1lbnRTaXplKX0ge1xuICAgIGxldCBjb2wgPSBjb2xJbiAqICR7aW5uZXJFbGVtZW50U2l6ZX07XG4gICAgbGV0IGNvb3JkWCA9IHVuaWZvcm1zLmZpbHRlckRpbXMueCAtIDEgLVxuICAgICAgICByb3cgLyAodW5pZm9ybXMuZmlsdGVyRGltc1sxXSAqIHVuaWZvcm1zLm91dEJhY2twcm9wWzNdKTtcbiAgICBsZXQgY29vcmRZID0gdW5pZm9ybXMuZmlsdGVyRGltcy55IC0gMSAtXG4gICAgICAgIChyb3cgLyB1bmlmb3Jtcy5vdXRCYWNrcHJvcFszXSkgJSB1bmlmb3Jtcy5maWx0ZXJEaW1zWzFdO1xuICAgIGlmIChyb3cgPCB1bmlmb3Jtcy5kaW1Jbm5lciAmJiBjb2wgPCB1bmlmb3Jtcy5kaW1CT3V0ZXIgJiZcbiAgICAgICAgY29vcmRYID49IDAgJiYgY29vcmRZID49IDApIHtcbiAgICAgIGxldCByb3dJbm5lciA9IHJvdyAlIHVuaWZvcm1zLm91dEJhY2twcm9wWzNdO1xuICAgICAgbGV0IGNvb3JkID0gdmVjNDxpMzI+KGNvb3JkWCwgY29vcmRZLCBjb2wsIHJvd0lubmVyKTtcbiAgICAgICR7Z2V0V1NuaXBwZXQoaW5uZXJFbGVtZW50U2l6ZSl9XG4gICAgfVxuICAgIHJldHVybiAke3R5cGVTbmlwcGV0KGlubmVyRWxlbWVudFNpemUpfSgwLjApO1xuICB9XG5cbiAgZm4gbW1fd3JpdGUoYmF0Y2g6IGkzMiwgcm93IDogaTMyLCBjb2xJbiA6IGkzMiwgdmFsdWVJbnB1dCA6ICR7XG4gICAgICB0eXBlU25pcHBldChpbm5lckVsZW1lbnRTaXplKX0pIHtcbiAgICBsZXQgY29sID0gY29sSW4gKiAke2lubmVyRWxlbWVudFNpemV9O1xuICAgIGlmIChyb3cgPCB1bmlmb3Jtcy5kaW1BT3V0ZXIgJiYgKGNvbCArICR7XG4gICAgICBpbm5lckVsZW1lbnRTaXplIC0gMX0pIDwgdW5pZm9ybXMuZGltQk91dGVyKSB7XG4gICAgICB2YXIgdmFsdWUgPSB2YWx1ZUlucHV0O1xuICAgICAgbGV0IG91dENvb3JkID0gdmVjNDxpMzI+KFxuICAgICAgICAgIGJhdGNoLFxuICAgICAgICAgIHJvdyAvIHVuaWZvcm1zLm91dFNoYXBlWzJdLFxuICAgICAgICAgIHJvdyAlIHVuaWZvcm1zLm91dFNoYXBlWzJdLFxuICAgICAgICAgIGNvbCk7XG4gICAgICByZXN1bHRbZ2V0SW5kZXhGcm9tQ29vcmRzNEQob3V0Q29vcmQsIHVuaWZvcm1zLm91dFNoYXBlKS8ke1xuICAgICAgaW5uZXJFbGVtZW50U2l6ZX1dID0gdmFsdWU7XG4gICAgfVxuICB9YDtcbiAgcmV0dXJuIHVzZXJDb2RlO1xufVxuXG5leHBvcnQgY2xhc3MgQ29udjJERGVySW5wdXRNTVByb2dyYW0gaW1wbGVtZW50cyBXZWJHUFVQcm9ncmFtIHtcbiAgb3V0cHV0U2hhcGU6IG51bWJlcltdO1xuICBzaGFkZXJLZXk6IHN0cmluZztcbiAgZGlzcGF0Y2hMYXlvdXQ6IHt4OiBudW1iZXJbXSwgeTogbnVtYmVyW10sIHo6IG51bWJlcltdfTtcbiAgZGlzcGF0Y2g6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbiAgdmFyaWFibGVOYW1lcyA9IFsneCcsICdXJ107XG4gIHZhcmlhYmxlVHlwZXM6IHN0cmluZ1tdO1xuICB1bmlmb3JtcyA9XG4gICAgICAnZmlsdGVyRGltcyA6IHZlYzI8aTMyPiwgcGFkcyA6IHZlYzI8aTMyPiwgc3RyaWRlIDogdmVjMjxpMzI+LCBvdXRCYWNrcHJvcCA6IHZlYzQ8aTMyPiwgZGltQU91dGVyIDogaTMyLCBkaW1CT3V0ZXIgOiBpMzIsIGRpbUlubmVyIDogaTMyLCc7XG4gIHdvcmtHcm91cFNpemU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbiAgZWxlbWVudHNQZXJUaHJlYWQ6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbiAgaXNWZWM0PzogYm9vbGVhbjtcblxuICBjb25zdHJ1Y3Rvcihjb252SW5mbzogYmFja2VuZF91dGlsLkNvbnYyREluZm8pIHtcbiAgICB0aGlzLm91dHB1dFNoYXBlID0gY29udkluZm8uaW5TaGFwZTtcblxuICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICBjb252SW5mby5kYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNMYXN0JyxcbiAgICAgICAgKCkgPT4gJ1RPRE86IE5DSFcgaXMgdW5pbXBsZW1lbnRlZCcpO1xuICAgIHRoaXMuaXNWZWM0ID1cbiAgICAgICAgY29udkluZm8uaW5DaGFubmVscyAlIDQgPT09IDAgJiYgY29udkluZm8ub3V0Q2hhbm5lbHMgJSA0ID09PSAwO1xuICAgIHRoaXMuZGlzcGF0Y2hMYXlvdXQgPSB7eDogWzNdLCB5OiBbMSwgMl0sIHo6IFswXX07XG4gICAgdGhpcy53b3JrR3JvdXBTaXplID0gY29tcHV0ZVdvcmtHcm91cFNpemVGb3JDb252MmQoXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hMYXlvdXQsIHRoaXMub3V0cHV0U2hhcGUsIHRoaXMuaXNWZWM0KTtcbiAgICB0aGlzLmVsZW1lbnRzUGVyVGhyZWFkID0gY29tcHV0ZVdvcmtQZXJUaHJlYWRGb3JDb252MmQoXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hMYXlvdXQsIHRoaXMub3V0cHV0U2hhcGUsIHRoaXMuaXNWZWM0KTtcblxuICAgIHRoaXMuZGlzcGF0Y2ggPSBjb21wdXRlRGlzcGF0Y2goXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hMYXlvdXQsIHRoaXMub3V0cHV0U2hhcGUsIHRoaXMud29ya0dyb3VwU2l6ZSxcbiAgICAgICAgdGhpcy5lbGVtZW50c1BlclRocmVhZCk7XG5cbiAgICBpZiAodGhpcy5pc1ZlYzQpIHtcbiAgICAgIHRoaXMudmFyaWFibGVUeXBlcyA9IFsndmVjNDxmMzI+JywgJ2YzMiddO1xuICAgIH1cblxuICAgIHRoaXMuc2hhZGVyS2V5ID1cbiAgICAgICAgYGNvbnYyRERlcklucHV0TU1fJHt0aGlzLmlzVmVjNH1fJHt0aGlzLmVsZW1lbnRzUGVyVGhyZWFkfWA7XG4gIH1cblxuICBnZXRVc2VyQ29kZSgpOiBzdHJpbmcge1xuICAgIGNvbnN0IG1hdE11bFNvdXJjZSA9IHRoaXMuaXNWZWM0ID9cbiAgICAgICAgbWFrZU1hdE11bFBhY2tlZFZlYzRTb3VyY2UodGhpcy5lbGVtZW50c1BlclRocmVhZCwgdGhpcy53b3JrR3JvdXBTaXplKSA6XG4gICAgICAgIG1ha2VNYXRNdWxQYWNrZWRTb3VyY2UodGhpcy5lbGVtZW50c1BlclRocmVhZCwgdGhpcy53b3JrR3JvdXBTaXplKTtcbiAgICBjb25zdCB1c2VyQ29kZSA9IGBcbiAgICAke2NvbnYyZFRyYW5zcG9zZUNvbW1vblNuaXBwZXQodGhpcy5pc1ZlYzQgPyA0IDogMSl9XG4gICAgJHttYXRNdWxTb3VyY2V9XG4gICAgYDtcbiAgICByZXR1cm4gdXNlckNvZGU7XG4gIH1cbn1cbiJdfQ==