/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import { backend_util } from '@tensorflow/tfjs-core';
import { getMainHeaderString as main } from './webgpu_program';
import { computeDispatch, flatDispatchLayout } from './webgpu_util';
export class ReduceProgram {
    constructor(reduceInfo, reduceType) {
        this.workGroupSize = [64, 1, 1];
        this.variableNames = ['x'];
        this.uniforms = 'reduceSize : i32,';
        this.size = true;
        this.inputShape = [reduceInfo.batchSize, reduceInfo.inSize];
        const [outputShape,] = backend_util.computeOutAndReduceShapes(this.inputShape, [1]);
        this.outputShape = outputShape.length === 0 ? [1] : outputShape;
        this.dispatchLayout = flatDispatchLayout(this.outputShape);
        // A work group only outputs a data, so we transfer [1, 1, 1] to compute
        // dispatch size.
        this.dispatch =
            computeDispatch(this.dispatchLayout, this.outputShape, [1, 1, 1]);
        this.reduceType = reduceType;
        this.shaderKey = `reduce_${reduceType}`;
    }
    getUserCode() {
        let reduceOp = ``;
        let initValue = '0.0';
        if (this.reduceType === 'min' || this.reduceType === 'max') {
            reduceOp = `
         if (isnan(candidate)) {
          bestValue = uniforms.NAN;
         } else if (!isnan(bestValue) && candidate ${this.reduceType === 'min' ? '<' : '>'} bestValue)
           {  bestValue = candidate; }`;
            initValue = 'f32(x[offset])';
        }
        else if (this.reduceType === 'sum' || this.reduceType === 'mean') {
            reduceOp = ' bestValue = bestValue + candidate; ';
        }
        else if (this.reduceType === 'prod') {
            reduceOp = ' bestValue = bestValue * candidate; ';
            initValue = '1.0';
        }
        const outputSnippet = this.reduceType === 'mean' ?
            // tslint:disable-next-line:max-line-length
            `setOutputAtIndex(outputIndex, bestValue / f32(uniforms.reduceSize));` :
            `setOutputAtIndex(outputIndex, bestValue);`;
        const sharedMemorySnippet = `
         var<workgroup> xBestValues : array<f32, ${this.workGroupSize[0]}>;
       `;
        const userCode = `
       fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
       }

       ${sharedMemorySnippet}
       fn getOffset(outputIndex : i32) -> i32 {
         let outputCoords = getCoordsFromIndex(outputIndex);
         let offset = ${this.outputShape.length === 1 ?
            'outputCoords' :
            'outputCoords[0]'} * uniforms.reduceSize;
          return offset;
       }
       ${main('index')} {
         let outputIndex = index / i32(workGroupSizeX);
         let offset = getOffset(outputIndex);
         var bestValue = ${initValue};
         let Length = uniforms.reduceSize;
         let WorkPerThread = DIV_CEIL(u32(Length), workGroupSizeX);
         for (var k = i32(localId.x); k < Length && outputIndex < uniforms.size;
             k = k + i32(workGroupSizeX)) {
           let candidate = f32(x[offset + k]);
           ${reduceOp}
         }
         xBestValues[localId.x] = bestValue;
         workgroupBarrier();

         var reduceSize = min(u32(Length), workGroupSizeX);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            ${reduceOp}
            xBestValues[localId.x] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (localId.x == 0u && outputIndex < uniforms.size) {
          ${outputSnippet}
        }
       }
     `;
        return userCode;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVkdWNlX3dlYmdwdS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3RmanMtYmFja2VuZC13ZWJncHUvc3JjL3JlZHVjZV93ZWJncHUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBRUgsT0FBTyxFQUFDLFlBQVksRUFBQyxNQUFNLHVCQUF1QixDQUFDO0FBQ25ELE9BQU8sRUFBQyxtQkFBbUIsSUFBSSxJQUFJLEVBQWdCLE1BQU0sa0JBQWtCLENBQUM7QUFDNUUsT0FBTyxFQUFDLGVBQWUsRUFBRSxrQkFBa0IsRUFBQyxNQUFNLGVBQWUsQ0FBQztBQUVsRSxNQUFNLE9BQU8sYUFBYTtJQVl4QixZQUNJLFVBQW1DLEVBQ25DLFVBQTJDO1FBVC9DLGtCQUFhLEdBQTZCLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUNyRCxrQkFBYSxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDdEIsYUFBUSxHQUFHLG1CQUFtQixDQUFDO1FBRy9CLFNBQUksR0FBRyxJQUFJLENBQUM7UUFLVixJQUFJLENBQUMsVUFBVSxHQUFHLENBQUMsVUFBVSxDQUFDLFNBQVMsRUFBRSxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDNUQsTUFBTSxDQUFDLFdBQVcsRUFBRyxHQUNqQixZQUFZLENBQUMseUJBQXlCLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDakUsSUFBSSxDQUFDLFdBQVcsR0FBRyxXQUFXLENBQUMsTUFBTSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDO1FBRWhFLElBQUksQ0FBQyxjQUFjLEdBQUcsa0JBQWtCLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQzNELHdFQUF3RTtRQUN4RSxpQkFBaUI7UUFDakIsSUFBSSxDQUFDLFFBQVE7WUFDVCxlQUFlLENBQUMsSUFBSSxDQUFDLGNBQWMsRUFBRSxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRXRFLElBQUksQ0FBQyxVQUFVLEdBQUcsVUFBVSxDQUFDO1FBQzdCLElBQUksQ0FBQyxTQUFTLEdBQUcsVUFBVSxVQUFVLEVBQUUsQ0FBQztJQUMxQyxDQUFDO0lBRUQsV0FBVztRQUNULElBQUksUUFBUSxHQUFHLEVBQUUsQ0FBQztRQUNsQixJQUFJLFNBQVMsR0FBRyxLQUFLLENBQUM7UUFDdEIsSUFBSSxJQUFJLENBQUMsVUFBVSxLQUFLLEtBQUssSUFBSSxJQUFJLENBQUMsVUFBVSxLQUFLLEtBQUssRUFBRTtZQUMxRCxRQUFRLEdBQUc7OztxREFJUCxJQUFJLENBQUMsVUFBVSxLQUFLLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHO3VDQUNSLENBQUM7WUFDbEMsU0FBUyxHQUFHLGdCQUFnQixDQUFDO1NBQzlCO2FBQU0sSUFBSSxJQUFJLENBQUMsVUFBVSxLQUFLLEtBQUssSUFBSSxJQUFJLENBQUMsVUFBVSxLQUFLLE1BQU0sRUFBRTtZQUNsRSxRQUFRLEdBQUcsc0NBQXNDLENBQUM7U0FDbkQ7YUFBTSxJQUFJLElBQUksQ0FBQyxVQUFVLEtBQUssTUFBTSxFQUFFO1lBQ3JDLFFBQVEsR0FBRyxzQ0FBc0MsQ0FBQztZQUNsRCxTQUFTLEdBQUcsS0FBSyxDQUFDO1NBQ25CO1FBRUQsTUFBTSxhQUFhLEdBQUcsSUFBSSxDQUFDLFVBQVUsS0FBSyxNQUFNLENBQUMsQ0FBQztZQUM5QywyQ0FBMkM7WUFDM0Msc0VBQXNFLENBQUMsQ0FBQztZQUN4RSwyQ0FBMkMsQ0FBQztRQUVoRCxNQUFNLG1CQUFtQixHQUFHO21EQUNtQixJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQztRQUNoRSxDQUFDO1FBRUwsTUFBTSxRQUFRLEdBQUc7Ozs7O1NBS1osbUJBQW1COzs7d0JBSXBCLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxLQUFLLENBQUMsQ0FBQyxDQUFDO1lBQzNCLGNBQWMsQ0FBQyxDQUFDO1lBQ2hCLGlCQUFpQjs7O1NBR3BCLElBQUksQ0FBQyxPQUFPLENBQUM7OzsyQkFHSyxTQUFTOzs7Ozs7YUFNdkIsUUFBUTs7Ozs7Ozs7Ozs7Y0FXUCxRQUFROzs7Ozs7OztZQVFWLGFBQWE7OztNQUduQixDQUFDO1FBQ0gsT0FBTyxRQUFRLENBQUM7SUFDbEIsQ0FBQztDQUNGIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG5pbXBvcnQge2JhY2tlbmRfdXRpbH0gZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcbmltcG9ydCB7Z2V0TWFpbkhlYWRlclN0cmluZyBhcyBtYWluLCBXZWJHUFVQcm9ncmFtfSBmcm9tICcuL3dlYmdwdV9wcm9ncmFtJztcbmltcG9ydCB7Y29tcHV0ZURpc3BhdGNoLCBmbGF0RGlzcGF0Y2hMYXlvdXR9IGZyb20gJy4vd2ViZ3B1X3V0aWwnO1xuXG5leHBvcnQgY2xhc3MgUmVkdWNlUHJvZ3JhbSBpbXBsZW1lbnRzIFdlYkdQVVByb2dyYW0ge1xuICBvdXRwdXRTaGFwZTogbnVtYmVyW107XG4gIHNoYWRlcktleTogc3RyaW5nO1xuICBkaXNwYXRjaExheW91dDoge3g6IG51bWJlcltdfTtcbiAgZGlzcGF0Y2g6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbiAgd29ya0dyb3VwU2l6ZTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdID0gWzY0LCAxLCAxXTtcbiAgdmFyaWFibGVOYW1lcyA9IFsneCddO1xuICB1bmlmb3JtcyA9ICdyZWR1Y2VTaXplIDogaTMyLCc7XG4gIHJlZHVjZVR5cGU6ICdtYXgnfCdtZWFuJ3wnbWluJ3wncHJvZCd8J3N1bSc7XG4gIGlucHV0U2hhcGU6IG51bWJlcltdO1xuICBzaXplID0gdHJ1ZTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICAgIHJlZHVjZUluZm86IGJhY2tlbmRfdXRpbC5SZWR1Y2VJbmZvLFxuICAgICAgcmVkdWNlVHlwZTogJ21heCd8J21lYW4nfCdtaW4nfCdwcm9kJ3wnc3VtJykge1xuICAgIHRoaXMuaW5wdXRTaGFwZSA9IFtyZWR1Y2VJbmZvLmJhdGNoU2l6ZSwgcmVkdWNlSW5mby5pblNpemVdO1xuICAgIGNvbnN0IFtvdXRwdXRTaGFwZSwgXSA9XG4gICAgICAgIGJhY2tlbmRfdXRpbC5jb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzKHRoaXMuaW5wdXRTaGFwZSwgWzFdKTtcbiAgICB0aGlzLm91dHB1dFNoYXBlID0gb3V0cHV0U2hhcGUubGVuZ3RoID09PSAwID8gWzFdIDogb3V0cHV0U2hhcGU7XG5cbiAgICB0aGlzLmRpc3BhdGNoTGF5b3V0ID0gZmxhdERpc3BhdGNoTGF5b3V0KHRoaXMub3V0cHV0U2hhcGUpO1xuICAgIC8vIEEgd29yayBncm91cCBvbmx5IG91dHB1dHMgYSBkYXRhLCBzbyB3ZSB0cmFuc2ZlciBbMSwgMSwgMV0gdG8gY29tcHV0ZVxuICAgIC8vIGRpc3BhdGNoIHNpemUuXG4gICAgdGhpcy5kaXNwYXRjaCA9XG4gICAgICAgIGNvbXB1dGVEaXNwYXRjaCh0aGlzLmRpc3BhdGNoTGF5b3V0LCB0aGlzLm91dHB1dFNoYXBlLCBbMSwgMSwgMV0pO1xuXG4gICAgdGhpcy5yZWR1Y2VUeXBlID0gcmVkdWNlVHlwZTtcbiAgICB0aGlzLnNoYWRlcktleSA9IGByZWR1Y2VfJHtyZWR1Y2VUeXBlfWA7XG4gIH1cblxuICBnZXRVc2VyQ29kZSgpOiBzdHJpbmcge1xuICAgIGxldCByZWR1Y2VPcCA9IGBgO1xuICAgIGxldCBpbml0VmFsdWUgPSAnMC4wJztcbiAgICBpZiAodGhpcy5yZWR1Y2VUeXBlID09PSAnbWluJyB8fCB0aGlzLnJlZHVjZVR5cGUgPT09ICdtYXgnKSB7XG4gICAgICByZWR1Y2VPcCA9IGBcbiAgICAgICAgIGlmIChpc25hbihjYW5kaWRhdGUpKSB7XG4gICAgICAgICAgYmVzdFZhbHVlID0gdW5pZm9ybXMuTkFOO1xuICAgICAgICAgfSBlbHNlIGlmICghaXNuYW4oYmVzdFZhbHVlKSAmJiBjYW5kaWRhdGUgJHtcbiAgICAgICAgICB0aGlzLnJlZHVjZVR5cGUgPT09ICdtaW4nID8gJzwnIDogJz4nfSBiZXN0VmFsdWUpXG4gICAgICAgICAgIHsgIGJlc3RWYWx1ZSA9IGNhbmRpZGF0ZTsgfWA7XG4gICAgICBpbml0VmFsdWUgPSAnZjMyKHhbb2Zmc2V0XSknO1xuICAgIH0gZWxzZSBpZiAodGhpcy5yZWR1Y2VUeXBlID09PSAnc3VtJyB8fCB0aGlzLnJlZHVjZVR5cGUgPT09ICdtZWFuJykge1xuICAgICAgcmVkdWNlT3AgPSAnIGJlc3RWYWx1ZSA9IGJlc3RWYWx1ZSArIGNhbmRpZGF0ZTsgJztcbiAgICB9IGVsc2UgaWYgKHRoaXMucmVkdWNlVHlwZSA9PT0gJ3Byb2QnKSB7XG4gICAgICByZWR1Y2VPcCA9ICcgYmVzdFZhbHVlID0gYmVzdFZhbHVlICogY2FuZGlkYXRlOyAnO1xuICAgICAgaW5pdFZhbHVlID0gJzEuMCc7XG4gICAgfVxuXG4gICAgY29uc3Qgb3V0cHV0U25pcHBldCA9IHRoaXMucmVkdWNlVHlwZSA9PT0gJ21lYW4nID9cbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm1heC1saW5lLWxlbmd0aFxuICAgICAgICBgc2V0T3V0cHV0QXRJbmRleChvdXRwdXRJbmRleCwgYmVzdFZhbHVlIC8gZjMyKHVuaWZvcm1zLnJlZHVjZVNpemUpKTtgIDpcbiAgICAgICAgYHNldE91dHB1dEF0SW5kZXgob3V0cHV0SW5kZXgsIGJlc3RWYWx1ZSk7YDtcblxuICAgIGNvbnN0IHNoYXJlZE1lbW9yeVNuaXBwZXQgPSBgXG4gICAgICAgICB2YXI8d29ya2dyb3VwPiB4QmVzdFZhbHVlcyA6IGFycmF5PGYzMiwgJHt0aGlzLndvcmtHcm91cFNpemVbMF19PjtcbiAgICAgICBgO1xuXG4gICAgY29uc3QgdXNlckNvZGUgPSBgXG4gICAgICAgZm4gRElWX0NFSUwoYSA6IHUzMiwgYiA6IHUzMikgLT4gdTMyIHtcbiAgICAgICAgcmV0dXJuICgoYSAtIDF1KSAvIGIgKyAxdSk7XG4gICAgICAgfVxuXG4gICAgICAgJHtzaGFyZWRNZW1vcnlTbmlwcGV0fVxuICAgICAgIGZuIGdldE9mZnNldChvdXRwdXRJbmRleCA6IGkzMikgLT4gaTMyIHtcbiAgICAgICAgIGxldCBvdXRwdXRDb29yZHMgPSBnZXRDb29yZHNGcm9tSW5kZXgob3V0cHV0SW5kZXgpO1xuICAgICAgICAgbGV0IG9mZnNldCA9ICR7XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUubGVuZ3RoID09PSAxID9cbiAgICAgICAgICAgICdvdXRwdXRDb29yZHMnIDpcbiAgICAgICAgICAgICdvdXRwdXRDb29yZHNbMF0nfSAqIHVuaWZvcm1zLnJlZHVjZVNpemU7XG4gICAgICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICAgICB9XG4gICAgICAgJHttYWluKCdpbmRleCcpfSB7XG4gICAgICAgICBsZXQgb3V0cHV0SW5kZXggPSBpbmRleCAvIGkzMih3b3JrR3JvdXBTaXplWCk7XG4gICAgICAgICBsZXQgb2Zmc2V0ID0gZ2V0T2Zmc2V0KG91dHB1dEluZGV4KTtcbiAgICAgICAgIHZhciBiZXN0VmFsdWUgPSAke2luaXRWYWx1ZX07XG4gICAgICAgICBsZXQgTGVuZ3RoID0gdW5pZm9ybXMucmVkdWNlU2l6ZTtcbiAgICAgICAgIGxldCBXb3JrUGVyVGhyZWFkID0gRElWX0NFSUwodTMyKExlbmd0aCksIHdvcmtHcm91cFNpemVYKTtcbiAgICAgICAgIGZvciAodmFyIGsgPSBpMzIobG9jYWxJZC54KTsgayA8IExlbmd0aCAmJiBvdXRwdXRJbmRleCA8IHVuaWZvcm1zLnNpemU7XG4gICAgICAgICAgICAgayA9IGsgKyBpMzIod29ya0dyb3VwU2l6ZVgpKSB7XG4gICAgICAgICAgIGxldCBjYW5kaWRhdGUgPSBmMzIoeFtvZmZzZXQgKyBrXSk7XG4gICAgICAgICAgICR7cmVkdWNlT3B9XG4gICAgICAgICB9XG4gICAgICAgICB4QmVzdFZhbHVlc1tsb2NhbElkLnhdID0gYmVzdFZhbHVlO1xuICAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICAgICB2YXIgcmVkdWNlU2l6ZSA9IG1pbih1MzIoTGVuZ3RoKSwgd29ya0dyb3VwU2l6ZVgpO1xuICAgICAgICAgZm9yICh2YXIgY3VycmVudFNpemUgPSByZWR1Y2VTaXplIC8gMnU7IHJlZHVjZVNpemUgPiAxdTtcbiAgICAgICAgICAgICBjdXJyZW50U2l6ZSA9IHJlZHVjZVNpemUgLyAydSkge1xuICAgICAgICAgICBsZXQgaW50ZXJ2YWwgPSBESVZfQ0VJTChyZWR1Y2VTaXplLCAydSk7XG4gICAgICAgICAgIGlmIChsb2NhbElkLnggPCBjdXJyZW50U2l6ZSkge1xuICAgICAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHhCZXN0VmFsdWVzW2xvY2FsSWQueCArIGludGVydmFsXTtcbiAgICAgICAgICAgICR7cmVkdWNlT3B9XG4gICAgICAgICAgICB4QmVzdFZhbHVlc1tsb2NhbElkLnhdID0gYmVzdFZhbHVlO1xuICAgICAgICAgICB9XG4gICAgICAgICAgIHJlZHVjZVNpemUgPSBpbnRlcnZhbDtcbiAgICAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgICAgICAgfVxuXG4gICAgICAgICBpZiAobG9jYWxJZC54ID09IDB1ICYmIG91dHB1dEluZGV4IDwgdW5pZm9ybXMuc2l6ZSkge1xuICAgICAgICAgICR7b3V0cHV0U25pcHBldH1cbiAgICAgICAgfVxuICAgICAgIH1cbiAgICAgYDtcbiAgICByZXR1cm4gdXNlckNvZGU7XG4gIH1cbn1cbiJdfQ==