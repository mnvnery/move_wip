/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import*as e from"@tensorflow/tfjs-core";import{env as t,backend_util as n,util as r,KernelBackend as s,DataStorage as i,engine as a,buffer as o,registerBackend as u,Fill as l,Reshape as h,broadcast_util as d,_FusedMatMul as c,Identity as p,Complex as f,upcastType as m,tidy as g,reshape as b,broadcastTo as x,slice_util as w,TensorBuffer as I,Abs as y,Add as k,AddN as S,Transpose as v,ArgMax as C,ArgMin as $,Atan2 as R,sumOutType as A,Max as T,Mean as z,AvgPool as P,BatchMatMul as E,Slice as N,BatchToSpaceND as B,NotEqual as _,Real as F,Cast as O,Ceil as G,ClipByValue as L,Imag as D,Concat as U,Conv2D as W,Conv2DBackpropInput as M,Cos as V,Cosh as H,CropAndResize as X,Cumprod as q,Cumsum as K,DepthToSpace as Y,DepthwiseConv2dNative as j,Multiply as Q,Sum as Z,Einsum as J,Elu as ee,Equal as te,Exp as ne,ExpandDims as re,Expm1 as se,FlipLeftRight as ie,Floor as ae,FloorDiv as oe,FromPixels as ue,FusedBatchNorm as le,FusedConv2D as he,FusedDepthwiseConv2D as de,GatherNd as ce,GatherV2 as pe,Greater as fe,GreaterEqual as me,IsNan as ge,LeakyRelu as be,Less as xe,LessEqual as we,Log as Ie,LogicalAnd as ye,LogicalNot as ke,Maximum as Se,MaxPool as ve,Min as Ce,Minimum as $e,MirrorPad as Re,Neg as Ae,NonMaxSuppressionV3 as Te,kernel_impls as ze,NonMaxSuppressionV5 as Pe,ZerosLike as Ee,OnesLike as Ne,Pack as Be,PadV2 as _e,Pow as Fe,Prelu as Oe,Prod as Ge,Range as Le,RealDiv as De,Reciprocal as Ue,Relu as We,Relu6 as Me,ResizeBilinear as Ve,ResizeNearestNeighbor as He,RotateWithOffset as Xe,Rsqrt as qe,ScatterNd as Ke,Select as Ye,Sigmoid as je,Sin as Qe,Sinh as Ze,Sub as Je,Softmax as et,SpaceToBatchND as tt,Tile as nt,SparseToDense as rt,SplitV as st,Sqrt as it,Square as at,SquaredDifference as ot,StridedSlice as ut,StringNGrams as lt,Tanh as ht,TopK as dt,Transform as ct,Unpack as pt,registerKernel as ft}from"@tensorflow/tfjs-core";const mt=t();mt.registerFlag("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE",(()=>15)),mt.registerFlag("WEBGPU_CPU_FORWARD",(()=>!0)),mt.registerFlag("WEBGPU_MATMUL_PROGRAM_TYPE",(()=>-1)),mt.registerFlag("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE",(()=>!1)),mt.registerFlag("WEBGPU_USE_LOW_POWER_GPU",(()=>!1)),mt.registerFlag("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD",(()=>1e3)),mt.registerFlag("WEBGPU_USE_PROFILE_TOOL",(()=>!1)),mt.registerFlag("WEBGPU_IMPORT_EXTERNAL_TEXTURE",(()=>!0)),mt.registerFlag("WEBGPU_USE_NAIVE_CONV2D_DEBUG",(()=>!1));class gt{constructor(e){e&&(this.vendor=e.vendor)}isIntel(){return"intel"===this.vendor}}class bt{constructor(e){this.device=e,this.numUsedBuffers=0,this.numFreeBuffers=0,this.freeBuffers=new Map,this.usedBuffers=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireUploadBuffer(e,t){return this.acquireBuffer(e,t,!0)}acquireBuffer(e,t,n=!1){const r=xt(e,t);if(this.freeBuffers.has(r)||this.freeBuffers.set(r,[]),this.usedBuffers.has(r)||this.usedBuffers.set(r,[]),this.numBytesUsed+=e,this.numUsedBuffers++,this.freeBuffers.get(r).length>0){this.numFreeBuffers--;const e=this.freeBuffers.get(r).shift();return this.usedBuffers.get(r).push(e),e}this.numBytesAllocated+=e;const s=this.device.createBuffer({size:e,usage:t,mappedAtCreation:n});return this.usedBuffers.get(r).push(s),s}releaseBuffer(e,t,n){if(0===this.freeBuffers.size)return;const r=xt(t,n);this.freeBuffers.has(r)||this.freeBuffers.set(r,[]),this.freeBuffers.get(r).push(e),this.numFreeBuffers++,this.numUsedBuffers--;const s=this.usedBuffers.get(r),i=s.indexOf(e);if(i<0)throw new Error("Cannot release a buffer that was never provided by this buffer manager");s.splice(i,1),this.numBytesUsed-=t}releaseUploadBuffer(e,t,n){e.mapAsync(GPUMapMode.WRITE).then((()=>{this.releaseBuffer(e,t,n)}),(e=>{}))}getNumUsedBuffers(){return this.numUsedBuffers}getNumFreeBuffers(){return this.numFreeBuffers}dispose(){this.freeBuffers.forEach(((e,t)=>{e.forEach((e=>{e.destroy()}))})),this.usedBuffers.forEach(((e,t)=>{e.forEach((e=>{e.destroy()}))})),this.freeBuffers=new Map,this.usedBuffers=new Map,this.numUsedBuffers=0,this.numFreeBuffers=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function xt(e,t){return`${e}_${t}`}class wt{constructor(e){this.device=e,this.numUsedTextures=0,this.numFreeTextures=0,this.freeTextures=new Map,this.usedTextures=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireTexture(e,t,n,r){const s=e*t*yt(n),i=It(e,t,n,r);if(this.freeTextures.has(i)||this.freeTextures.set(i,[]),this.usedTextures.has(i)||this.usedTextures.set(i,[]),this.numBytesUsed+=s,this.numUsedTextures++,this.freeTextures.get(i).length>0){this.numFreeTextures--;const e=this.freeTextures.get(i).shift();return this.usedTextures.get(i).push(e),e}this.numBytesAllocated+=s;const a=this.device.createTexture({size:[e,t],format:n,usage:r});return this.usedTextures.get(i).push(a),a}releaseTexture(e,t,n,r,s){if(0===this.freeTextures.size)return;const i=It(t,n,r,s);this.freeTextures.has(i)||this.freeTextures.set(i,[]),this.freeTextures.get(i).push(e),this.numFreeTextures++,this.numUsedTextures--;const a=this.usedTextures.get(i),o=a.indexOf(e);if(o<0)throw new Error("Cannot release a texture that was never provided by this texture manager");a.splice(o,1);const u=t*n*yt(r);this.numBytesUsed-=u}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){this.freeTextures.forEach(((e,t)=>{e.forEach((e=>{e.destroy()}))})),this.usedTextures.forEach(((e,t)=>{e.forEach((e=>{e.destroy()}))})),this.freeTextures=new Map,this.usedTextures=new Map,this.numUsedTextures=0,this.numFreeTextures=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function It(e,t,n,r){return`${e}_${t}_${n}_${r}`}function yt(e){if("rgba8unorm"===e)return 16;throw new Error(`${e} is not supported!`)}function kt(e,t){if(Math.max(...e)>3)throw new Error("Cannot symbolically compute strides for rank > 4 tensor.");const n=e.length,r=e.map((e=>`${t}[${e}]`)),s=new Array(n-1);s[n-2]=r[n-1];for(let e=n-3;e>=0;--e)s[e]=`(${s[e+1]} * ${r[e+1]})`;return s}const St=(e,t,s,i)=>{const a=function(e,t,s){const i=[];if(i.push(`\n      const workGroupSizeX = ${s.workGroupSize[0]}u;\n      const workGroupSizeY = ${s.workGroupSize[1]}u;\n      const workGroupSizeZ = ${s.workGroupSize[2]}u;\n\n      var<private> localId: vec3<u32>;\n      var<private> globalId: vec3<u32>;\n      var<private> numWorkgroups: vec3<u32>;\n\n      // Only used when the y/z dimension of workgroup size is 1.\n      fn getGlobalIndex() -> i32 {\n        ${Pt(s)?"  return i32(globalId.x);":"  let localInvocationIndex = localId.z * workGroupSizeX * workGroupSizeY +\n                   localId.y * workGroupSizeX + localId.x;\n               let workGroupID = (globalId - localId)/vec3<u32>(\n                   workGroupSizeX, workGroupSizeY, workGroupSizeZ);\n\n               return i32((workGroupID.z * numWorkgroups.x * numWorkgroups.y +\n                   workGroupID.y * numWorkgroups.x + workGroupID.x) *\n                   (workGroupSizeX * workGroupSizeY * workGroupSizeZ) +\n                   localInvocationIndex);\n        "}\n      }\n    `),s.isFromPixels)return i.push(`\n        struct Uniform {\n          size            : i32,\n          numChannels     : i32,\n          outShapeStrides : vec2<i32>,\n        };\n\n        @group(0) @binding(0) var<storage, read_write> result: array<${Et(t.dtype,s.isVec4)}>;\n        @group(0) @binding(2) var<uniform> uniforms: Uniform;\n      `),[At,i.join("\n"),Tt(t.shape),s.getUserCode()].join("\n");let a="struct Uniforms { NAN : f32, ";s.variableNames.forEach(((t,n)=>{const r=vt(e[n].shape.length);a+=`${t.charAt(0).toLowerCase()+t.slice(1)}Shape : ${r}, `}));const o=vt(t.shape.length);a+=`outShape : ${o}, `;const u=vt(t.shape.length-1);a+=`\n         outShapeStrides: ${u}, `,s.size&&(a+="size : i32, ");s.uniforms&&(a+=s.uniforms);a+="};",a=function(e){const t=/(\w+)\s*:\s*vec(5|6)/g;e=e.replace(t,(e=>"@align(16) "+e));const n=/vec(5|6)\s*,\s*(\w+)/g;return e=e.replace(n,((e,t,n)=>`vec${t}, @align(16) ${n}`))}(a),i.push(a),s.atomic?i.push("\n      @group(0) @binding(0) var<storage, read_write> result: array<atomic<i32>>;\n    "):i.push(`\n      @group(0) @binding(0) var<storage, read_write> result: array<${Et(t.dtype,s.isVec4)}>;\n    `);s.variableNames.forEach(((t,n)=>{i.push(`\n      @group(0) @binding(${1+n}) var<storage, read> ${t}: array<${s.variableTypes?s.variableTypes[n]:Et(e[n].dtype,s.isVec4)}>;\n        `)})),""!==a&&i.push(`\n      @group(0) @binding(${1+s.variableNames.length}) var<uniform> uniforms: Uniforms;\n      `);const l=function(e,t){const{x:n,y:r=[],z:s=[]}=t,i=e.length,a=n.length+r.length+s.length;if(a!==i)return"";if(n.length===i){return`fn getOutputCoords() -> ${vt(i)}{\n    let globalIndex = getGlobalIndex();\n    return getCoordsFromIndex(globalIndex);\n  }\n  `}let o="";const u=[n,r,s];for(let e=0;e<u.length;e++){const t=u[e];if(0!==t.length)if(1===t.length)o+=`let d${t[0]} = i32(globalId[${e}]);`;else{const n=kt(t,"uniforms.outShape");o+=`var index${e} = i32(globalId[${e}]);`;for(let r=0;r<n.length;r++)o+=`let d${t[r]} = index${e} / ${n[r]};`,r===n.length-1?o+=`let d${t[r+1]} = index${e} - d${t[r]} * ${n[r]};`:o+=`index${e} = index${e} - d${t[r]} * ${n[r]};`}}const l=[];for(let e=0;e<a;e++)l.push(`d${e}`);const h=vt(a);let d=`fn getOutputCoords() -> ${h} {\n  ${o}\n`;0===l.length?d+=`return ${h}(0); }`:d+=`return ${h}(${l.join(",")}); }`;return d}(t.shape,s.dispatchLayout),h=[At,i.join("\n"),Tt(t.shape),l,zt(t.shape.length)];s.atomic||h.push(function(e,t,n){const r=e.length,s=Et(t,n);let i;i=n?`fn setOutputAtIndex(flatIndex : i32, value : vec4<f32>) {\n      result[flatIndex] = ${s}(value);\n    }\n    fn setOutputAtIndexI32(flatIndex : i32, value : vec4<i32>) {\n      result[flatIndex] = ${s}(value);\n    }`:`fn setOutputAtIndex(flatIndex : i32, value : f32) {\n      result[flatIndex] = ${s}(value);\n    }\n    fn setOutputAtIndexI32(flatIndex : i32, value : i32) {\n      result[flatIndex] = ${s}(value);\n    }`;if(r>=2){const e=["d0","d1","d2","d3","d4","d5"].slice(0,r),t=vt(r);i+=n?`\n      fn setOutputAtCoords(${e.map((e=>`${e} : i32`)).join(", ")}, value : vec4<f32>) {\n        let flatIndex = getOutputIndexFromCoords(${t}(${e.join(", ")}));\n        setOutputAtIndex(flatIndex / 4, value);\n      }\n      fn setOutputAtCoordsI32(${e.map((e=>`${e} : i32`)).join(", ")}, value : vec4<i32>) {\n        let flatIndex = getOutputIndexFromCoords(${t}(${e.join(", ")}));\n        setOutputAtIndexI32(flatIndex / 4, value);\n      }\n    `:`\n      fn setOutputAtCoords(${e.map((e=>`${e} : i32`)).join(", ")}, value : f32) {\n        let flatIndex = getOutputIndexFromCoords(${t}(${e.join(", ")}));\n        setOutputAtIndex(flatIndex, value);\n      }\n      fn setOutputAtCoordsI32(${e.map((e=>`${e} : i32`)).join(", ")}, value : i32) {\n        let flatIndex = getOutputIndexFromCoords(${t}(${e.join(", ")}));\n        setOutputAtIndexI32(flatIndex, value);\n      }\n    `}return i}(t.shape,t.dtype,s.isVec4));const d=e.map(((e,i)=>function(e,t,s,i){let a=function(e,t){const n=e.name,r=e.shape.length,s=vt(r),i="get"+n.charAt(0).toUpperCase()+n.slice(1),a=["d0","d1","d2","d3","d4","d5"].slice(0,r),o=a.map((e=>`${e} : i32`)).join(", ");if(r<1)return t?`\n        fn ${i}() -> vec4<f32> {\n          return vec4<f32>(${n}[0]);\n        }\n      `:`\n      fn ${i}() ->f32 {\n        return f32(${n}[0]);\n      }\n    `;const u=`uniforms.${n.charAt(0).toLowerCase()+n.slice(1)}Shape`;let l=`${r}D`;0===r&&(l="1D");if(t)return`\n      fn ${i}(${o}) -> vec4<f32> {\n        return vec4<f32>(${n}[getIndexFromCoords${l}(${s}(${a.join(",")}),\n          ${u}) / 4]);\n      }\n      `;return`\n    fn ${i}(${o}) -> f32 {\n      return f32(${n}[getIndexFromCoords${l}(${s}(${a.join(",")}),\n        ${u})]);\n    }\n   `}(e,s);e.shape.length<=t.length&&(a+=function(e,t,s,i){const a=e.name,o=a.charAt(0).toUpperCase()+a.slice(1),u="get"+o+"ByOutput",l=e.shape.length,h=t.length,d=vt(h);if(r.arraysEqual(e.shape,t)&&i)return s?`\n      fn ${u}Index(globalIndex : i32) -> vec4<f32> {\n        return vec4<f32>(${a}[globalIndex]);\n      }\n\n      fn ${u}Coords(coords : ${d}) -> vec4<f32> {\n        return vec4<f32>(${a}[${h>1?"getOutputIndexFromCoords(coords)":"coords"} / 4]);\n      }\n      `:`\n    fn ${u}Index(globalIndex : i32) -> f32 {\n      return f32(${a}[globalIndex]);\n    }\n\n    fn ${u}Coords(coords : ${d}) -> f32 {\n      return f32(${a}[${h>1?"getOutputIndexFromCoords(coords)":"coords"}]);\n    }\n    `;const c=n.getBroadcastDims(e.shape,t),p=h-l;let f="";if(0===l)return s?`\n    fn ${u}Index(globalIndex : i32) -> vec4<f32> {\n      return get${o}();\n    }\n\n    fn ${u}Coords(coords : ${d}) -> vec4<f32> {\n      return get${o}();\n    }\n  `:`\n    fn ${u}Index(globalIndex : i32) -> f32{\n      return get${o}();\n    }\n\n    fn ${u}Coords(coords : ${d}) -> f32{\n      return get${o}();\n    }\n  `;f=h<2&&c.length>=1?"coords = 0;":c.map((e=>`coords.${Ct(e+p)} = 0;`)).join("\n");let m="";if(h<2&&l>0)m="coords";else if(h>1){const t=vt(l),n=e.shape.map(((e,t)=>`coords.${Ct(t+p)}`)).join(", ");m=`${t}(${n})`}else m="coords";const g=`uniforms.${a.charAt(0).toLowerCase()+a.slice(1)}Shape`,b=`${l}D`;if(s)return`\n    fn ${u}Index(globalIndex : i32) -> vec4<f32> {\n      var coords = getCoordsFromIndex(globalIndex);\n      ${f}\n      return ${a}[getIndexFromCoords${b}(${m}, ${g}) / 4];\n    }\n\n    fn ${u}Coords(coordsIn : ${d}) -> vec4<f32> {\n      var coords = coordsIn;\n      ${f}\n      return ${a}[getIndexFromCoords${b}(${m}, ${g}) / 4];\n    }\n  `;return`\n  fn ${u}Index(globalIndex : i32) -> f32 {\n    var coords = getCoordsFromIndex(globalIndex);\n    ${f}\n    return f32(${a}[getIndexFromCoords${b}(${m}, ${g})]);\n  }\n\n  fn ${u}Coords(coordsIn : ${d}) -> f32 {\n    var coords = coordsIn;\n    ${f}\n    return f32(${a}[getIndexFromCoords${b}(${m}, ${g})]);\n  }\n`}(e,t,s,i));return a}(e,t.shape,s.variableTypes?"vec4<f32>"===s.variableTypes[i]:s.isVec4,s.dispatchLayout.x.length===t.shape.length))).join("\n");h.push(d),h.push(s.getUserCode());return h.join("\n")}(s,{dtype:i.dtype,shape:i.shape},t),o=e.createShaderModule({code:a,label:t.constructor.name});return e.createComputePipeline({compute:{module:o,entryPoint:"_start"},label:t.constructor.name,layout:"auto"})};function vt(e){if(e<=1)return"i32";if(2===e)return"vec2<i32>";if(3===e)return"vec3<i32>";if(4===e)return"vec4<i32>";if(5===e)return"vec5";if(6===e)return"vec6";throw Error(`GPU for rank ${e} is not yet supported`)}function Ct(e){if(0===e)return"x";if(1===e)return"y";if(2===e)return"z";if(3===e)return"w";if(4===e)return"u";if(5===e)return"v";throw Error(`Index ${e} is not yet supported`)}function $t(...e){let t;switch(e.length){case 0:t=`\n        ${Rt()}\n        fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,\n                  @builtin(global_invocation_id) GlobalId : vec3<u32>,\n                  @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {\n          localId = LocalId;\n          globalId = GlobalId;\n          numWorkgroups = NumWorkgroups;\n          main();\n        }\n\n        fn main()\n      `;break;case 1:t=`\n        ${Rt()}\n        fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,\n                  @builtin(global_invocation_id) GlobalId : vec3<u32>,\n                  @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {\n          localId = LocalId;\n          globalId = GlobalId;\n          numWorkgroups = NumWorkgroups;\n          main(getGlobalIndex());\n        }\n\n        fn main(${e[0]} : i32)\n      `;break;default:throw Error("Unreachable")}return t}function Rt(){return"\n  @compute @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n"}const At="\n  struct vec5 {x: i32, y: i32, z: i32, w: i32, u: i32};\n  struct vec6 {x: i32, y: i32, z: i32, w: i32, u: i32, v: i32};\n\n  // Checks whether coordinates lie within the bounds of the shape.\n  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {\n    return all(coord >= vec2<i32>(0)) && all(coord < shape);\n  }\n  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {\n    return all(coord >= vec3<i32>(0)) && all(coord < shape);\n  }\n  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {\n    return all(coord >= vec4<i32>(0)) && all(coord < shape);\n  }\n\n  fn getIndexFromCoords1D(coord : i32, shape : i32) -> i32 {\n    return coord;\n  }\n  fn getIndexFromCoords2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {\n    return dot(coords, vec2<i32>(shape.y, 1));\n  }\n  fn getIndexFromCoords3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {\n    return dot(coords, vec3<i32>(shape.y * shape.z, shape.z, 1));\n  }\n  fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n    return dot(coords, vec4<i32>(\n        shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\n  }\n  fn getIndexFromCoords5D(coords : vec5, shape : vec5) -> i32 {\n    let shapeStrides: vec5 = vec5(shape.y * shape.z * shape.w * shape.u, shape.z * shape.w * shape.u, shape.w * shape.u, shape.u, 1);\n    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u;\n  }\n  fn getIndexFromCoords6D(coords : vec6, shape : vec6) -> i32 {\n    let shapeStrides: vec6 = vec6(shape.y * shape.z * shape.w * shape.u * shape.v, shape.z * shape.w * shape.u * shape.v, shape.w * shape.u * shape.v, shape.u * shape.v, shape.v, 1);\n    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u + coords.v*shapeStrides.v;\n  }\n\n  fn idiv(a: i32, b: i32, sign: f32) -> i32 {\n    var res: i32 = a / b;\n    let modulo: i32 = a % b;\n    if (sign < 0. && modulo != 0) {\n      res = res - 1;\n    }\n    return res;\n  }\n\n  // NaN defination in IEEE 754-1985 is :\n  //   - sign = either 0 or 1.\n  //   - biased exponent = all 1 bits.\n  //   - fraction = anything except all 0 bits (since all 0 bits represents infinity).\n  // https://en.wikipedia.org/wiki/IEEE_754-1985#Representation_of_non-numbers\n  fn isnan(val: f32) -> bool {\n    let floatToUint: u32 = bitcast<u32>(val);\n    return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n  }\n  fn isnanVec4(val : vec4<f32>) -> vec4<bool> {\n    return vec4<bool>(isnan(val[0]), isnan(val[1]), isnan(val[2]), isnan(val[3]));\n  }\n";function Tt(e){const t=e.length;if(t<=1)return"fn getCoordsFromIndex(index : i32) -> i32 { return index; }";const n=r.computeStrides(e),s=vt(t),i=[];for(let e=0;e<t;e++)i.push(`d${e}`);if(1===n.length)return"    fn getCoordsFromIndex(index : i32) -> vec2<i32> {\n      let d0 = index / uniforms.outShapeStrides; let d1 = index - d0 * uniforms.outShapeStrides;\n      return vec2<i32>(d0, d1);\n    }";let a;return a="var index2 = index;"+n.map(((e,t)=>`${`let ${i[t]} = index2 / uniforms.outShapeStrides.${Ct(t)}`}; ${t===n.length-1?`let ${i[t+1]} = index2 - ${i[t]} * uniforms.outShapeStrides.${Ct(t)}`:`index2 = index2 - ${i[t]} * uniforms.outShapeStrides.${Ct(t)}`};`)).join(""),`\n    fn getCoordsFromIndex(index : i32) -> ${s} {\n      ${a}\n      return ${s}(${i.join(",")});\n    }\n  `}function zt(e){let t="";switch(e){case 0:case 1:t+="\n        fn getOutputIndexFromCoords(coords : i32) -> i32 {\n          return coords;\n        }\n        ";break;case 2:t+="\n        fn getOutputIndexFromCoords(coords : vec2<i32>) -> i32 {\n          return dot(coords, vec2<i32>(uniforms.outShapeStrides, 1));\n        }\n        ";break;case 3:t+="\n        fn getOutputIndexFromCoords(coords : vec3<i32>) -> i32 {\n          return dot(coords, vec3<i32>(uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, 1));\n        }\n        ";break;case 4:t+="\n        fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\n          return dot(coords, vec4<i32>(\n            uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, uniforms.outShapeStrides.z, 1));\n        }\n        ";break;case 5:t+="\n        fn getOutputIndexFromCoords(coords : vec5) -> i32 {\n          return coords.x * uniforms.outShapeStrides.x +\n              coords.y * uniforms.outShapeStrides.y +\n              coords.z * uniforms.outShapeStrides.z +\n              coords.w * uniforms.outShapeStrides.w +\n              coords.u;\n        }\n        ";break;case 6:t+="\n        fn getOutputIndexFromCoords(coords : vec6) -> i32 {\n          return coords.x * uniforms.outShapeStrides.x +\n              coords.y * uniforms.outShapeStrides.y +\n              coords.z * uniforms.outShapeStrides.z +\n              coords.w * uniforms.outShapeStrides.w +\n              coords.u * uniforms.outShapeStrides.u +\n              coords.v;\n        }\n        ";break;default:r.assert(!1,(()=>`Unsupported ${e}D shape`))}return t}function Pt(e){return 1===e.dispatch[1]&&1===e.dispatch[2]}function Et(e,t){return"float32"===e?t?"vec4<f32>":"f32":"int32"===e||"bool"===e?t?"vec4<i32>":"i32":e}const Nt=e=>{let t=1;for(let n=0;n<e.length;n++)t*=e[n];return t};function Bt(e,t,n=[1,1,1],r=[1,1,1]){const[s,i,a]=[Math.ceil(Nt(e.x.map((e=>t[e])))/(n[0]*r[0])),e.y?Math.ceil(Nt(e.y.map((e=>t[e])))/(n[1]*r[1])):1,e.z?Math.ceil(Nt(e.z.map((e=>t[e])))/(n[2]*r[2])):1];return[s,i,a]}function _t(e,t,n,r=!1){const s=[8,8,1],i=[4,4,1];return r||(e<=8&&(i[1]=1),t<=16&&n<=16&&(s[0]=4)),{workGroupSize:s,elementsPerThread:i}}function Ft(e,t,n=!1){if(n)return[8,8,1];const r=Nt(e.x.map((e=>t[e]))),s=Nt(e.y.map((e=>t[e])));return r<=4?[4,16,1]:s<=4?[16,4,1]:[16,16,1]}function Ot(e,t,n=!1){if(n)return[4,4,1];const r=Nt(e.x.map((e=>t[e]))),s=Nt(e.y.map((e=>t[e])));return r<=4?[1,2,1]:s<=4?[2,1,1]:[2,2,1]}function Gt(e){return{x:e.map(((e,t)=>t))}}function Lt(e){if("float32"===e||"int32"===e||"bool"===e||"string"===e)return 4;if("complex64"===e)return 8;throw new Error(`Unknown dtype ${e}`)}function Dt(e,t){if("float32"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t||"string"===t)return Uint8Array.from(new Int32Array(e));throw new Error(`Unknown dtype ${t}`)}function Ut(){return("undefined"!=typeof window||"undefined"!=typeof WorkerGlobalScope)&&!!navigator.gpu}var Wt;!function(e){e[e.MatMulReduceProgram=0]="MatMulReduceProgram",e[e.MatMulSplitKProgram=1]="MatMulSplitKProgram",e[e.MatMulSmallOutputSizeProgram=2]="MatMulSmallOutputSizeProgram",e[e.MatMulPackedProgram=3]="MatMulPackedProgram",e[e.MatMulMax=4]="MatMulMax"}(Wt||(Wt={}));var Mt={__proto__:null,tilesFitEvenlyIntoShape:function(e,t){if(e.length!==t.length)throw new Error(`Cannot compute whether rank ${e.length} tiles fit evenly into rank ${t.length} shape - ranks must match.`);return t.every(((t,n)=>t%e[n]==0))},computeDispatch:Bt,computeWorkGroupInfoForMatMul:_t,computeWorkGroupSizeForConv2d:Ft,computeWorkPerThreadForConv2d:Ot,flatDispatchLayout:Gt,GPUBytesPerElement:Lt,ArrayBufferToTypedArray:Dt,isWebGPUSupported:Ut,get MatMulProgramType(){return Wt}};const Vt=t().getNumber("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD");class Ht extends s{constructor(e,n){if(super(),this.commandQueueOwnedIds=new WeakSet,this.dispatchNumberInEncoder=0,this.disposed=!1,this.downloadWaitMs=0,this.tensorDataPendingDisposal=[],this.stagingPendingDisposal=[],this.uniformPendingDisposal=[],this.uploadWaitMs=0,!Ut())throw new Error("WebGPU is not supported on this device");this.pipelineCache={},this.device=e,this.queue=e.queue,this.currentCommandEncoder=null,this.currentComputePass=null,this.supportTimeQuery=e.features.has("timestamp-query"),this.adapterInfo=new gt(n),this.bufferManager=new bt(this.device),this.textureManager=new wt(this.device),this.tensorMap=new i(this,a()),this.supportTimeQuery&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:2})),t().getBool("WEBGPU_USE_PROFILE_TOOL")&&(this.dummyCanvas=document.createElement("canvas"),this.dummyCanvas.width=1,this.dummyCanvas.height=1,this.dummyContext=this.dummyCanvas.getContext("webgpu"),this.dummyContext.configure({device:e,format:"bgra8unorm"}),document.body.appendChild(this.dummyCanvas))}nextDataId(){return Ht.nextDataId++}floatPrecision(){return 32}defaultGpuBufferUsage(){return GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST}disposeData(e,t=!1){if(this.tensorDataPendingDisposal.indexOf(e)>=0)return!1;if(!this.tensorMap.has(e))return!0;const n=this.tensorMap.get(e);if(this.decRef(e),!t&&n.refCount>0)return!1;if(this.commandQueueOwnedIds.has(e))return this.tensorDataPendingDisposal.push(e),!1;const{complexTensorInfos:r}=this.tensorMap.get(e);return null!=r&&(this.disposeData(r.real.dataId,t),this.disposeData(r.imag.dataId,t)),this.releaseResource(e),this.tensorMap.delete(e),!0}memory(){return{numBytesInGPU:this.bufferManager.numBytesUsed,numBytesAllocatedInGPU:this.bufferManager.numBytesAllocated,unreliable:!1}}releaseResource(e){const t=this.tensorMap.get(e);if(t&&t.resourceInfo){if("texture"in t.resourceInfo){const e=t.resourceInfo;e.texture instanceof GPUTexture&&this.textureManager.releaseTexture(e.texture,e.width,e.height,e.format,e.usage),e.texture=null}else{const e=t.resourceInfo;this.bufferManager.releaseBuffer(e.buffer,e.size,e.usage),e.buffer=null}t.resourceInfo=null}}refCount(e){if(this.tensorMap.has(e)){return this.tensorMap.get(e).refCount}return 0}incRef(e){this.tensorMap.get(e).refCount++}decRef(e){if(this.tensorMap.has(e)){this.tensorMap.get(e).refCount--}}write(e,t,n){if("complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.tensorMap.set(r,{dtype:n,shape:t,values:e,refCount:1}),r}move(e,t,n,r,s){if("complex64"===r)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.tensorMap.set(e,{dtype:r,shape:n,values:t,refCount:s})}submitQueue(){this.ensureComputePassEnded(),this.queue.submit([this.currentCommandEncoder.finish()]),this.currentCommandEncoder=null,this.dispatchNumberInEncoder=0,this.commandQueueOwnedIds=new WeakSet,this.tensorDataPendingDisposal.forEach((e=>{this.releaseResource(e),this.tensorMap.delete(e)})),this.uniformPendingDisposal.forEach((e=>this.bufferManager.releaseBuffer(e.buffer,e.size,e.usage))),this.stagingPendingDisposal.forEach((e=>this.bufferManager.releaseUploadBuffer(e.buffer,e.size,e.usage))),this.tensorDataPendingDisposal=[],this.uniformPendingDisposal=[],this.stagingPendingDisposal=[]}ensureCommandEncoderReady(){this.currentCommandEncoder||(this.currentCommandEncoder=this.device.createCommandEncoder())}ensureComputePassEnded(){this.currentComputePass&&(this.currentComputePass.end(),this.currentComputePass=null)}getComputePass(){return this.currentComputePass||(this.currentComputePass=this.currentCommandEncoder.beginComputePass()),this.currentComputePass}async getBufferData(e,n){const s=this.bufferManager.acquireBuffer(n,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ);this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.copyBufferToBuffer(e,0,s,0,n),this.submitQueue(),await s.mapAsync(GPUMapMode.READ);const i=s.getMappedRange().slice(0);return s.unmap(),null!=s&&this.bufferManager.releaseBuffer(s,n,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ),t().getBool("WEBGPU_USE_PROFILE_TOOL")&&(r.assert(void 0!==this.dummyContext,(()=>"Fail to get context for profiling tool")),this.dummyContext.getCurrentTexture()),i}convertAndCacheOnCPU(e,t){const n=this.tensorMap.get(e);return this.releaseResource(e),n.values=t,n.values}readSync(e){const t=this.tensorMap.get(e),{values:n}=t;if(null==n)throw new Error("WebGPU readSync is only available for CPU-resident tensors.");return n}async read(e){if(!this.tensorMap.has(e))throw new Error(`Tensor ${e} was not registered!`);const t=this.tensorMap.get(e),{values:r}=t;if(null!=r)return this.convertAndCacheOnCPU(e,r);let s;if("complex64"===t.dtype){const e=await Promise.all([this.read(t.complexTensorInfos.real.dataId),this.read(t.complexTensorInfos.imag.dataId)]),r=e[0],i=e[1];s=n.mergeRealAndImagArrays(r,i)}else{const e=t.resourceInfo;s=Dt(await this.getBufferData(e.buffer,e.size),t.dtype)}return this.convertAndCacheOnCPU(e,s),s}readToGPU(e){const t=this.tensorMap.get(e),{values:n,dtype:r,shape:s,resourceInfo:i}=t;if("complex64"===r)throw new Error("Does not support reading buffer for complex64 dtype.");if(null==i)throw null!=n?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const o=i.size,u=this.bufferManager.acquireBuffer(o,i.usage);this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.copyBufferToBuffer(i.buffer,0,u,0,o),this.submitQueue();const l=this.makeTensorInfo(s,r),h=a().makeTensorFromTensorInfo(l);return this.tensorMap.get(l.dataId).resourceInfo={size:o,usage:this.defaultGpuBufferUsage(),buffer:u},{tensorRef:h,buffer:u,bufSize:o}}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map((e=>r.decodeString(e)));return o(e.shape,e.dtype,n)}catch(e){throw new Error("Failed to decode encoded string bytes into utf-8")}return o(e.shape,e.dtype,t)}async time(e){this.supportTimeQuery||console.warn("This device doesn't support timestamp-query extension. Start Chrome browser with flag --disable-dawn-features=disallow_unsafe_apis then try again. Otherwise, zero will be shown for the kernel time when profiling mode is enabled. Using performance.now is not workable for webgpu since it doesn't support synchronous data read from GPU.");const t=this.activeTimers,n=[];let s=!1;null==this.programTimersStack?(this.programTimersStack=n,s=!0):this.activeTimers.push(n),this.activeTimers=n,e();const i=r.flatten(this.activeTimers.map((e=>e.query))).filter((e=>null!=e)),a=r.flatten(this.activeTimers.map((e=>e.name))).filter((e=>null!=e));this.activeTimers=t,s&&(this.programTimersStack=null);const o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null},u=await Promise.all(i);return o.kernelMs=r.sum(u),o.getExtraProfileInfo=()=>u.map(((e,t)=>({name:a[t],ms:e}))).map((e=>`${e.name}: ${e.ms}`)).join(", "),this.uploadWaitMs=0,this.downloadWaitMs=0,o}makeTensorInfo(e,t,n){"string"===t&&null!=n&&n.length>0&&r.isString(n[0])&&(n=n.map((e=>r.encodeString(e))));return{dataId:this.write(n,e,t),shape:e,dtype:t}}tensorToBinding(e){if(!e)return null;const t=this.tensorMap.get(e.dataId);if("texture"in t.resourceInfo){const e=t.resourceInfo;return e.texture instanceof GPUExternalTexture?e.texture:e.texture.createView()}const n=t.resourceInfo;return{offset:0,size:n.size,buffer:n.buffer}}async getQueryTime(e){return this.supportTimeQuery?this.getTimeFromQuerySet(e):0}uploadToGPU(e){const t=this.tensorMap.get(e);if(t.resourceInfo)return;const n=Lt(t.dtype)*r.sizeFromShape(t.shape),s=this.bufferManager.acquireBuffer(n,this.defaultGpuBufferUsage());if(t.resourceInfo={size:n,usage:this.defaultGpuBufferUsage(),buffer:s},t.values){const e=this.bufferManager.acquireUploadBuffer(n,GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC),r=e.getMappedRange();"int32"===t.dtype||"bool"===t.dtype?new Int32Array(r).set(t.values):new Float32Array(r).set(t.values),e.unmap(),this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.copyBufferToBuffer(e,0,s,0,n);const i={size:n,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC,buffer:e};this.stagingPendingDisposal.push(i)}}makeUniforms(e){let t=0,n=0;const s=[];e.forEach((e=>{let i;switch(0===e.data.length&&(e.data=[1]),e.data.length){case 1:i=4;break;case 2:i=8;break;case 3:case 4:case 5:case 6:i=16;break;default:r.assert(!1,(()=>`Unsupported ${e.data.length}D shape`))}5!==n&&6!==n||(i=16),t=Math.ceil(t/i)*i,n=e.data.length,s.push(t),t+=4*e.data.length}));const i=new ArrayBuffer(t);e.forEach(((e,t)=>{const n=s[t];"int32"===e.type?new Int32Array(i,n,e.data.length).set(e.data):"uint32"===e.type?new Uint32Array(i,n,e.data.length).set(e.data):new Float32Array(i,n,e.data.length).set(e.data)}));const a=this.bufferManager.acquireBuffer(t,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.queue.writeBuffer(a,0,i,0,t);const o={size:t,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM,buffer:a};return this.uniformPendingDisposal.push(o),{offset:0,size:t,buffer:a}}runWebGPUProgram(e,s,i,a,o){if(o||(o=this.makeTensorInfo(e.outputShape,i)),0===r.sizeFromShape(o.shape))return this.tensorMap.get(o.dataId).values=r.getTypedArrayFromDType(o.dtype,0),o;this.uploadToGPU(o.dataId),e.dispatch=((e,t)=>{const n=e.limits.maxComputeWorkgroupsPerDimension,s=t.dispatchLayout,i=t.dispatch;if(i.every((e=>e<=n)))return i;r.assert(i[0]>n&&void 0===s.y&&void 0===s.z,(()=>"Dispatch size exceeds WebGPU limits in Y or Z dimension."));let a=Math.ceil(Math.sqrt(i[0]));return a>n?(a=Math.ceil(Math.cbrt(i[0])),r.assert(a<=n,(()=>"Total dispatch size exceeds WebGPU maximum.")),[a,a,a]):[a,a,1]})(this.device,e);let u=[],l=[];if(!e.isFromPixels){u.push({type:"float32",data:[NaN]}),l=s.concat(o).map((e=>e.shape));const t="int32";l.map((e=>{u.push({type:t,data:e})}));const n=r.computeStrides(o.shape);if(u.push({type:t,data:n}),e.size){const n=r.sizeFromShape(e.outputShape);u.push({type:t,data:[e.isVec4?n/4:n]})}}const h=s.map(((t,n)=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");return this.uploadToGPU(t.dataId),{dtype:this.tensorMap.get(t.dataId).dtype,shape:t.shape,name:e.variableNames[n]}})),d=function(e,t,s,i){let a=e.shaderKey;if(e.isFromPixels)return a;const o=s.map((e=>e.dtype)).concat(i.dtype),u=s.map((e=>n.getBroadcastDims(e.shape,i.shape))),l=s.map((e=>r.arraysEqual(e.shape,i.shape))).join("_"),h=u.map((e=>e.join("_"))).join(";"),d=Pt(e)?"flatDispatch":"";return a+="_"+(e.workGroupSize?e.workGroupSize.join(","):"")+t.map((e=>e.length)).join(",")+o.join(",")+e.variableNames.join(",")+h+l+d,a}(e,l,h,o);let c;d in this.pipelineCache?c=this.pipelineCache[d]:(c=St(this.device,e,h,o),this.pipelineCache[d]=c),a&&(u=[...u,...a]);const p=[this.tensorToBinding(o),...s.map((e=>this.tensorToBinding(e))),this.makeUniforms(u)],f=this.device.createBindGroup({layout:c.getBindGroupLayout(0),entries:p.map(((e,t)=>({binding:t,resource:e})))});this.ensureCommandEncoderReady();const m=this.getComputePass(),g=null!=this.activeTimers;return g&&this.supportTimeQuery&&m.writeTimestamp(this.querySet,0),m.setPipeline(c),m.setBindGroup(0,f),m.dispatchWorkgroups(e.dispatch[0],e.dispatch[1],e.dispatch[2]),g&&this.supportTimeQuery&&m.writeTimestamp(this.querySet,1),this.dispatchNumberInEncoder++,s.forEach((e=>{this.commandQueueOwnedIds.add(e.dataId)})),this.commandQueueOwnedIds.add(o.dataId),t().get("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE")<=this.dispatchNumberInEncoder&&this.submitQueue(),g&&this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(this.querySet)}),o}async getTimeFromQuerySet(e){const t=this.bufferManager.acquireBuffer(16,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE),n=this.bufferManager.acquireBuffer(16,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.resolveQuerySet(e,0,2,t,0),this.currentCommandEncoder.copyBufferToBuffer(t,0,n,0,16),this.submitQueue(),await n.mapAsync(GPUMapMode.READ);const r=new BigUint64Array(n.getMappedRange()),s=Number(r[1]-r[0]);return n.unmap(),this.bufferManager.releaseBuffer(n,16,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST),this.bufferManager.releaseBuffer(t,16,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE),s/1e6}shouldExecuteOnCPU(e,n=Vt){return t().getBool("WEBGPU_CPU_FORWARD")&&e.every((e=>null==this.tensorMap.get(e.dataId).resourceInfo&&r.sizeFromShape(e.shape)<n))}numDataIds(){return this.tensorMap.numDataIds()-this.tensorDataPendingDisposal.length}dispose(){this.disposed||(this.bufferManager.dispose(),this.textureManager.dispose(),this.disposed=!0)}}var Xt;Ht.nextDataId=0,Ut()&&u("webgpu",(async()=>{t().set("CHECK_COMPUTATION_FOR_ERRORS",!1);const e={powerPreference:t().get("WEBGPU_USE_LOW_POWER_GPU")?"low-power":"high-performance"},n=await navigator.gpu.requestAdapter(e),r=n.limits,s={},i=n.features.has("timestamp-query");s.requiredLimits={maxComputeWorkgroupStorageSize:r.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:r.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:r.maxStorageBufferBindingSize},i&&(s.requiredFeatures=["timestamp-query"]);const a=await n.requestDevice(s),o=await n.requestAdapterInfo();return new Ht(a,o)}),3),function(e){e[e.MUL=0]="MUL",e[e.ADD=1]="ADD",e[e.ATAN2=2]="ATAN2",e[e.SUB=3]="SUB",e[e.DIV=4]="DIV",e[e.EQUAL=5]="EQUAL",e[e.GREATER=6]="GREATER",e[e.GREATER_EQUAL=7]="GREATER_EQUAL",e[e.LESS=8]="LESS",e[e.LESS_EQUAL=9]="LESS_EQUAL",e[e.LOGICAL_AND=10]="LOGICAL_AND",e[e.NOT_EQUAL=11]="NOT_EQUAL",e[e.SQUARED_DIFFERENCE=12]="SQUARED_DIFFERENCE",e[e.INT_DIV=13]="INT_DIV",e[e.POW=14]="POW",e[e.PRELU=15]="PRELU",e[e.MAX=16]="MAX",e[e.MIN=17]="MIN",e[e.COMPLEX_MULTIPLY_REAL=18]="COMPLEX_MULTIPLY_REAL",e[e.COMPLEX_MULTIPLY_IMAG=19]="COMPLEX_MULTIPLY_IMAG"}(Xt||(Xt={}));const qt="\n  if (isNaN.r) {\n    resultTemp.r = valueForNaN;\n  }\n  if (isNaN.g) {\n    resultTemp.g = valueForNaN;\n  }\n  if (isNaN.b) {\n    resultTemp.b = valueForNaN;\n  }\n  if (isNaN.a) {\n    resultTemp.a = valueForNaN;\n  }\n  ",Kt=`\n  let isNaN = isnanVec4(a) | isnanVec4(b);\n  ${qt}\n  `,Yt=`\n  var resultTemp = vec4<f32>(a != b);\n  let valueForNaN = 1.0;\n  ${Kt}\n\n  return resultTemp;\n`,jt=`\n  let isModRound1Bool = vec4<i32>(round(abs(b) % vec4<f32>(2.0))) == vec4<i32>(1);\n  let isModRound1 = vec4<f32>(isModRound1Bool);\n  let multiplier = sign(a) * isModRound1 + (vec4<f32>(1.0) - isModRound1);\n  var resultTemp = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  let isExpZero = b == vec4<f32>(0.0);\n  if (isExpZero.r) {\n    resultTemp.r = 1.0;\n  }\n  if (isExpZero.g) {\n    resultTemp.g = 1.0;\n  }\n  if (isExpZero.b) {\n    resultTemp.b = 1.0;\n  }\n  if (isExpZero.a) {\n    resultTemp.a = 1.0;\n  }\n  let isNaN = (a < vec4<f32>(0.0)) & (floor(b) < b);\n  let valueForNaN = uniforms.NAN;\n  ${qt}\n  return resultTemp;\n  `;function Qt(e,t,n="uniforms.NAN"){const r=t?Kt:"\n  if (isnan(a)) { return a; }\n  if (isnan(b)) { return b; }\n  ";return t?`\n    let valueForNaN = ${n};\n    var resultTemp = vec4<f32>(${e}(a, b));\n    `+r+"\n    return resultTemp;\n  ":r+`\n    return ${e}(a, b);\n  `}function Zt(e,t){switch(e){case Xt.MUL:return"return a * b;";case Xt.ADD:return"return a + b;";case Xt.ATAN2:return Qt("atan2",t);case Xt.SUB:return"return a - b;";case Xt.DIV:return"return a / b;";case Xt.EQUAL:return t?"return vec4<f32>(a == b);":"return f32(a == b);";case Xt.GREATER:return t?"return vec4<f32>(a > b);":"return f32(a > b);";case Xt.GREATER_EQUAL:return t?"return vec4<f32>(a >= b);":"return f32(a >= b);";case Xt.LESS:return t?"return vec4<f32>(a < b);":"return f32(a < b);";case Xt.LESS_EQUAL:return t?"return vec4<f32>(a <= b);":"return f32(a <= b);";case Xt.LOGICAL_AND:return t?"return (vec4<f32>(a >= vec4<f32>(1.0)) *\n  vec4<f32>(b >= vec4<f32>(1.0)));":"return f32(f32(a) >= 1.0 && f32(b) >= 1.0);";case Xt.NOT_EQUAL:return t?Yt:"\n  if (isnan(a) || isnan(b)) {\n    return 1.0;\n  }\n  return f32(a != b);\n";case Xt.SQUARED_DIFFERENCE:return"return (a - b) * (a - b);";case Xt.INT_DIV:return t?"\n  let ia = vec4<i32>(round(a));\n  let ib = vec4<i32>(round(b));\n  let cond = ib != vec4<i32>(0);\n  var resultTemp = vec4<i32>(0);\n  let s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    resultTemp[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    resultTemp[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    resultTemp[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    resultTemp[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4<f32>(resultTemp);\n  ":"\n  let s = sign(a) * sign(b);\n  let ia = i32(round(a));\n  let ib = i32(round(b));\n  return f32(idiv(ia, ib, s));\n  ";case Xt.PRELU:return t?"\n  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));\n  return (aLessThanZero * (b * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);\n  ":"if (a < 0.0) { return b * a; }  return a;";case Xt.MAX:return Qt("max",t);case Xt.MIN:return Qt("min",t);case Xt.POW:return t?jt:"\n  if(a < 0.0 && floor(b) < b) {\n    return uniforms.NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  if (round(abs(b) % 2.0) != 1.0) {\n    return pow(abs(a), b);\n  }\n  return sign(a) * pow(abs(a), b);\n  ";case Xt.COMPLEX_MULTIPLY_REAL:return"return areal * breal - aimag * bimag;";case Xt.COMPLEX_MULTIPLY_IMAG:return"return areal * bimag + aimag * breal;";default:throw new Error(`BinaryType ${e} is not implemented!`)}}var Jt;!function(e){e[e.ABS=0]="ABS",e[e.CEIL=1]="CEIL",e[e.COS=2]="COS",e[e.COSH=3]="COSH",e[e.ELU=4]="ELU",e[e.EXP=5]="EXP",e[e.EXPM1=6]="EXPM1",e[e.FLOOR=7]="FLOOR",e[e.IS_NAN=8]="IS_NAN",e[e.LINEAR=9]="LINEAR",e[e.LOG=10]="LOG",e[e.LOGICAL_NOT=11]="LOGICAL_NOT",e[e.NEG=12]="NEG",e[e.RELU=13]="RELU",e[e.RELU6=14]="RELU6",e[e.LEAKYRELU=15]="LEAKYRELU",e[e.RECIPROCAL=16]="RECIPROCAL",e[e.RSQRT=17]="RSQRT",e[e.SIN=18]="SIN",e[e.SINH=19]="SINH",e[e.SIGMOID=20]="SIGMOID",e[e.SQRT=21]="SQRT",e[e.SQUARE=22]="SQUARE",e[e.TANH=23]="TANH",e[e.TO_INT=24]="TO_INT"}(Jt||(Jt={}));function en(e,t){switch(e){case Jt.ABS:return"return abs(a);";case Jt.COS:return"return cos(a);";case Jt.COSH:return"\n  let e2x = exp(-a);\n  return (e2x + 1.0 / e2x) / 2.0;\n";case Jt.CEIL:return"return ceil(a);";case Jt.ELU:return t?"\n  var resFloat = exp(a) - vec4<f32>(1.0);\n  if (a.r >= 0.0) {\n    resFloat.r = a.r;\n  }\n  if (a.g >= 0.0) {\n    resFloat.g = a.g;\n  }\n  if (a.b >= 0.0) {\n    resFloat.b = a.b;\n  }\n  if (a.a >= 0.0) {\n    resFloat.a = a.a;\n  }\n  return resFloat;\n":"if (a >= 0.0) { return a; }  return (exp(a) - 1.0);";case Jt.EXP:return"return exp(a);";case Jt.EXPM1:return"return exp(a) - 1.0;";case Jt.FLOOR:return"return floor(a);";case Jt.IS_NAN:return"return f32(isnan(a));";case Jt.LINEAR:return"return a;";case Jt.LOG:return"if (a < 0.0) { return uniforms.NAN; }\n  return log(a);";case Jt.LOGICAL_NOT:return"return f32(!(a >= 1.0));";case Jt.NEG:return"return -a;";case Jt.LEAKYRELU:return t?"\n  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));\n  return (aLessThanZero * (uniforms.alpha * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);\n":"if (a < 0.0) { return uniforms.alpha * a; } return a;";case Jt.RECIPROCAL:return"return 1.0 / a;";case Jt.RELU:return t?"\n  return select(a, vec4<f32>(0.0), a < vec4<f32>(0.0));\n":"return select(a, 0.0, a < 0.0);";case Jt.RELU6:return t?"return clamp(a, vec4<f32>(0.0, 0.0, 0.0, 0.0), vec4<f32>(6.0, 6.0, 6.0, 6.0));":"return clamp(a, 0.0, 6.0);";case Jt.RSQRT:return"return 1.0/sqrt(a);";case Jt.SIGMOID:return"return 1.0 / (1.0 + exp(-1.0 * a));";case Jt.SIN:return"return sin(a);";case Jt.SINH:return"\n  let e2x = exp(a);\n  return (e2x - 1.0 / e2x) / 2.0;\n";case Jt.SQRT:return"return sqrt(a);";case Jt.SQUARE:return"return a * a;";case Jt.TANH:return"\n  let e2x = exp(-2.0 * abs(a));\n  return sign(a) * (1.0 - e2x) / (1.0 + e2x);\n";case Jt.TO_INT:return"return f32(i32((a)));";default:throw new Error(`BinaryType ${e} is not implemented!`)}}const tn=e=>{switch(e){case 1:return"f32";case 2:return"vec2<f32>";case 3:return"vec3<f32>";case 4:return"vec4<f32>";default:throw new Error(`${e}-component is not supported.`)}};function nn(e,t=!1,n=!1,r=3){if(null===e)return"";let s="";if("linear"===e)s=en(Jt.LINEAR);else if("relu"===e)s=en(Jt.RELU,n);else if("elu"===e)s=en(Jt.ELU,n);else if("relu6"===e)s=en(Jt.RELU6,n);else if("prelu"===e)s=Zt(Xt.PRELU,n);else if("sigmoid"===e)s=en(Jt.SIGMOID,n);else{if("leakyrelu"!==e)throw new Error(`Activation ${e} has not been implemented for the WebGPU backend.`);s=en(Jt.LEAKYRELU,n)}const i=tn(n?4:1);let a="";return a=t?`\n      fn activation(a : ${i}, coords : vec${r}<i32>) -> ${i} {\n        let b = getPreluActivationWeightsByOutputCoords(coords);\n        ${s}\n      }`:`\n      fn activation(a : ${i}, coords : vec${r}<i32>) -> ${i} {\n        ${s}\n      }`,a}function rn(e,t){return`\n      ${e?"value = value + getBiasByOutputCoords(coords);":""}\n      ${t?"value = activation(value, coords);":""}\n      `}function sn(e,t,n,s,i=!1,a=!1,o=!1,u=1){r.assert(n&&1===u||!n,(()=>`transposeA ${n} is not compatible with component size ${u}`));const l=`\n      let batch = ${e?"0":"batchIn"};\n      ${n?"value = getA(batch, col, row);":"value = getA(batch, row, col);"}\n\n    `,h=s?"value = getB(batch, col, row);":"value = getB(batch, row, col);";return`\n  fn mm_readA(batchIn: i32, row: i32, colIn: i32) -> ${tn(u)} {\n    var value = ${tn(u)}(0.0);\n    let col = colIn * ${u};\n    ${i&&o?l:`\n    ${n?"if(row < uniforms.dimAOuter && col < uniforms.dimInner)":"if(row < uniforms.aShape[1] && col < uniforms.aShape[2])"}\n    {\n      ${l}\n    }\n    `}\n    return value;\n  }\n\n  fn mm_readB(batchIn: i32, row: i32, colIn: i32) -> ${tn(u)} {\n    let col = colIn * ${u};\n    let batch = ${t?"0":"batchIn"};\n    var value = ${tn(u)}(0.0);\n    ${h}\n    return value;\n  }\n  `}function an(e,t,n,r,s,i,a=!1,o=!1,u=!1,l=1){return`\n  ${sn(n,r,s,i,a,o,u,l)}\n  fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${tn(l)}) {\n    let col = colIn * ${l};\n    ${a&&o?"":"if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)"}\n    {\n      var value = valueIn;\n      let coords = vec3<i32>(batch, row, col);\n      ${rn(e,t)}\n      setOutputAtCoords(coords[0], coords[1], coords[2], value);\n    }\n  }\n  `}function on(e,t,n=!1,s=32,i=!1,a=32,o=!1){const u=t[1]*e[1],l=t[0]*e[0],h=n?u:s,d=n?s:u,c=h/t[0],p=s/t[1];return r.assert((n&&4===c&&4===e[1]||!n&&(3===c||4===c))&&h%t[0]==0&&s%t[1]==0&&4===e[0],(()=>`If transposeA ${n} is true, innerElementSize ${c} and workPerThread[1] ${e[1]} must be 4.\n          Otherwise, innerElementSize ${c} must be 3 or 4.\n      tileAWidth ${h} must be divisible by workGroupSize[0]${t[0]}. tileInner ${s} must be divisible by workGroupSize[1] ${t[1]}. ColPerThread ${e[0]} must be 4.`)),`\n  var<workgroup> mm_Asub : array<array<vec${c}<f32>, ${h/c}>, ${d}>;\n  var<workgroup> mm_Bsub : array<array<vec4<f32>, ${l/e[0]}>, ${s}>;\n\n  const RowPerThread = ${e[1]};\n  const ColPerThread = ${e[0]};\n  const InnerElementSize = ${c};\n  const TileInner = ${s};\n\n  @compute @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n  fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,\n            @builtin(global_invocation_id) GlobalId : vec3<u32>,\n            @builtin(num_workgroups) NumWorkgroups: vec3<u32>,\n            @builtin(workgroup_id) workgroupId: vec3<u32>) {\n    localId = LocalId;\n    globalId = GlobalId;\n    numWorkgroups = NumWorkgroups;\n\n    let localRow = i32(localId.y);\n    let tileRow = ${o?"0":"localRow * RowPerThread"};\n    let tileCol = i32(localId.x);\n\n    let globalRow = ${o?"0":"i32(globalId.y) * RowPerThread"};\n    let globalCol = i32(globalId.x);\n    let batch = ${i?"0":"i32(globalId.z)"};\n    let globalRowStart = i32(workgroupId.y) * ${u};\n\n    let numTiles = ${i?`${Math.ceil(a/s)}`:"(uniforms.dimInner - 1) / TileInner + 1"};\n    var kStart = ${i?`i32(globalId.z) * ${a}`:"0"};\n\n    var acc: array<vec4<f32>, RowPerThread>;\n\n    // Loop over shared dimension.\n    let tileRowB = localRow * ${p};\n    for (var t = 0; t < numTiles; t = t + 1) {\n        // Load one tile of A into local memory.\n        for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {\n            let inputRow = tileRow + innerRow;\n            let inputCol = tileCol;\n            ${(e=>e?"\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          kStart + inputRow,\n          globalRowStart / InnerElementSize + inputCol);\n        ":"\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          globalRow + innerRow,\n          kStart / InnerElementSize + inputCol);\n        ")(n)}\n        }\n\n        // Load one tile of B into local memory.\n        for (var innerRow = 0; innerRow < ${p}; innerRow = innerRow + 1) {\n            let inputRow = tileRowB + innerRow;\n            let inputCol = tileCol;\n            mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol);\n        }\n        kStart = kStart + TileInner;\n        workgroupBarrier();\n\n        // Compute acc values for a single thread.\n        for (var k = 0; k < TileInner / InnerElementSize; k = k + 1) {\n            let BCached0 = mm_Bsub[k * InnerElementSize][tileCol];\n            let BCached1 = mm_Bsub[k * InnerElementSize + 1][tileCol];\n            let BCached2 = mm_Bsub[k * InnerElementSize + 2][tileCol];\n            ${3===c?"":"let BCached3 = mm_Bsub[k * InnerElementSize + 3][tileCol];"}\n\n            ${((e,t)=>e?`\n        let ACached0 = mm_Asub[k * InnerElementSize][localRow];\n        let ACached1 = mm_Asub[k * InnerElementSize + 1][localRow];\n        let ACached2 = mm_Asub[k * InnerElementSize + 2][localRow];\n        ${3===t?"":"let ACached3 = mm_Asub[k * InnerElementSize + 3][localRow];"}\n        for (var i = 0; i < RowPerThread; i = i + 1) {\n          acc[i] = BCached0 * ACached0[i] + acc[i];\n          acc[i] = BCached1 * ACached1[i] + acc[i];\n          acc[i] = BCached2 * ACached2[i] + acc[i];\n          ${3===t?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}\n        }`:`\n        for (var i = 0; i < RowPerThread; i = i + 1) {\n          let ACached = mm_Asub[tileRow + i][k];\n          acc[i] = BCached0 * ACached.x + acc[i];\n          acc[i] = BCached1 * ACached.y + acc[i];\n          acc[i] = BCached2 * ACached.z + acc[i];\n          ${3===t?"":"acc[i] = BCached3 * ACached.w + acc[i];"}\n        }`)(n,c)}\n        }\n\n        workgroupBarrier();\n    }\n\n    for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {\n        mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);\n    }\n  }`}const un=e=>e?"\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          kStart + inputRow,\n          globalRowStart + inputCol);\n        ":"\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          globalRowStart + inputRow,\n          kStart + inputCol);\n        ";function ln(e,t,n=!1,s=32,i=!1,a=32,o=!1){const u=e[1]*t[1],l=e[0]*t[0],h=n?u:s,d=n?s:u;r.assert(d%t[1]==0&&h%t[0]==0&&s%t[1]==0,(()=>`tileAHight ${d} must be divisible by workGroupSize[1]${t[1]}, tileAWidth ${h} must be divisible by workGroupSize[0]${t[0]}, tileInner ${s} must be divisible by workGroupSize[1]${t[1]}`));const c=d/t[1],p=h/t[0],f=s/t[1],m=o?`\n      let localRow = i32(localId.y);\n      let localCol = i32(localId.x);\n      let globalRowStart = i32(workgroupId.y) * ${u};\n      let globalColStart = i32(workgroupId.x) * ${l};\n\n      // Loop over shared dimension.\n      for (var t = 0; t < numTiles; t = t + 1) {\n        // Load one tile of A into local memory.\n        for (var inputRow = localRow; inputRow < ${d}; inputRow = inputRow + ${t[1]}) {\n          for (var inputCol = localCol; inputCol < ${h}; inputCol = inputCol + ${t[0]}) {\n            ${un(n)}\n          }\n        }\n        // Load one tile of B into local memory.\n        for (var inputRow = localRow; inputRow < ${s}; inputRow = inputRow + ${t[1]}) {\n              for (var inputCol = localCol; inputCol < ${l}; inputCol = inputCol + ${t[0]}) {\n            mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n              kStart + inputRow,\n              globalColStart + inputCol);\n          }\n        }\n        kStart = kStart + TileInner;\n        workgroupBarrier();\n\n        // Compute acc values for a single thread.\n        var BCached : array<f32, ColPerThread>;\n        for (var k = 0; k < TileInner; k = k + 1) {\n          for (var inner = 0; inner < ColPerThread; inner = inner + 1) {\n            BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];\n          }\n          for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {\n            let ACached = ${n?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}\n            for (var innerCol = 0; innerCol < ColPerThread; innerCol = innerCol + 1) {\n              acc[innerRow][innerCol] = acc[innerRow][innerCol] +\n                  ACached * BCached[innerCol];\n            }\n          }\n        }\n        workgroupBarrier();\n      }\n      for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {\n        let gRow = globalRowStart + localRow + innerRow * ${t[1]};\n        for (var innerCol = 0; innerCol < ColPerThread; innerCol = innerCol + 1) {\n          let gCol = globalColStart + localCol + innerCol * ${t[0]};\n          mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);\n        }\n      }\n      `:`\n  let tileRow = i32(localId.y) * RowPerThread;\n  let tileCol = i32(localId.x) * ColPerThread;\n\n  let globalRow = i32(globalId.y) * RowPerThread;\n  let globalCol = i32(globalId.x) * ColPerThread;\n  let globalRowStart = i32(workgroupId.y) * ${u};\n\n  let tileRowA = i32(localId.y) * ${c};\n  let tileColA = i32(localId.x) * ${p};\n  let tileRowB = i32(localId.y) * ${f};\n  // Loop over shared dimension.\n  for (var t = 0; t < numTiles; t = t + 1) {\n    // Load one tile of A into local memory.\n    for (var innerRow = 0; innerRow < ${c}; innerRow = innerRow + 1) {\n      for (var innerCol = 0; innerCol < ${p}; innerCol = innerCol + 1) {\n        let inputRow = tileRowA + innerRow;\n        let inputCol = tileColA + innerCol;\n        ${un(n)}\n      }\n    }\n\n    // Load one tile of B into local memory.\n    for (var innerRow = 0; innerRow < ${f}; innerRow = innerRow + 1) {\n      for (var innerCol = 0; innerCol < ColPerThread; innerCol = innerCol + 1) {\n        let inputRow = tileRowB + innerRow;\n        let inputCol = tileCol + innerCol;\n        mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n          kStart + inputRow,\n          globalCol + innerCol);\n      }\n    }\n    kStart = kStart + TileInner;\n    workgroupBarrier();\n\n    // Compute acc values for a single thread.\n    var BCached : array<f32, ColPerThread>;\n    for (var k = 0; k < TileInner; k = k + 1) {\n      for (var inner = 0; inner < ColPerThread; inner = inner + 1) {\n        BCached[inner] = mm_Bsub[k][tileCol + inner];\n      }\n\n      for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {\n        ${(e=>e?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];")(n)}\n        for (var innerCol = 0; innerCol < ColPerThread; innerCol = innerCol + 1) {\n          acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];\n        }\n      }\n    }\n\n    workgroupBarrier();\n  }\n\n  for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < ColPerThread; innerCol = innerCol + 1) {\n      mm_write(batch, globalRow + innerRow, globalCol + innerCol,\n          acc[innerRow][innerCol]);\n    }\n  }\n  `;return`\n    var<workgroup> mm_Asub : array<array<f32, ${h}>, ${d}>;\n    var<workgroup> mm_Bsub : array<array<f32, ${l}>, ${s}>;\n    const RowPerThread = ${e[1]};\n    const ColPerThread = ${e[0]};\n    const TileInner = ${s};\n\n    @compute @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n    fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,\n              @builtin(global_invocation_id) GlobalId : vec3<u32>,\n              @builtin(num_workgroups) NumWorkgroups: vec3<u32>,\n              @builtin(workgroup_id) workgroupId: vec3<u32>) {\n      localId = LocalId;\n      globalId = GlobalId;\n      numWorkgroups = NumWorkgroups;\n\n      let batch = ${i?"0":"i32(globalId.z)"};\n      let numTiles = ${i?`${Math.ceil(a/s)}`:"(uniforms.dimInner - 1) / TileInner + 1"};\n      var kStart = ${i?`i32(globalId.z) * ${a}`:"0"};\n\n      var acc : array<array<f32, ColPerThread>, RowPerThread>;\n\n      // Without this initialization strange values show up in acc.\n      for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {\n        for (var innerCol = 0; innerCol < ColPerThread; innerCol = innerCol + 1) {\n          acc[innerRow][innerCol] = 0.0;\n        }\n      }\n      ${m}\n    }\n  `}class hn{constructor(e,t,n,r,s=!1,i=!1,a=null,o=null,u=null,l=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=t,this.dispatchLayout={x:[2],y:[1],z:[0]};const h=s?e[1]:e[2];if(this.isVec4=(h%4==0&&!s||t[1]%4==0&&s)&&t[2]%4==0&&!i,this.isVectorA=1===t[1]&&!s,!this.isVec4&&this.isVectorA)this.elementsPerThread=[1,1,1],this.workGroupSize=[32,1,1];else{const e=_t(t[1],h,t[2],s);this.workGroupSize=e.workGroupSize,this.elementsPerThread=e.elementsPerThread}this.dispatch=Bt(this.dispatchLayout,this.outputShape,this.workGroupSize,this.elementsPerThread);const d=null!=a,c=null!=u;d&&this.variableNames.push("bias"),c&&this.variableNames.push("preluActivationWeights"),this.sequentialAccessByThreads=l,this.transposeA=s,this.transposeB=i,this.addBias=d,this.activation=o,this.hasPreluActivationWeights=c,this.batchAEqualOne=n,this.batchBEqualOne=r,[this.fitAOuter,this.fitBOuter,this.fitInner]=this.getShapeFit(t[1],t[2],h),this.shaderKey=`matMulPacked_${this.elementsPerThread}_${s}_${i}_${this.activation}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.isVectorA}_${this.batchAEqualOne}_${this.batchBEqualOne}_${this.sequentialAccessByThreads}`}getShapeFit(e,t,n){const r=this.workGroupSize[1]*this.elementsPerThread[1],s=this.workGroupSize[0]*this.elementsPerThread[0];!this.isVec4&&this.isVectorA?this.tileInner=4*this.workGroupSize[0]:this.tileInner=s;return[e%r==0,t%s==0,n%this.tileInner==0]}getUserCode(){const e=`\n      ${nn(this.activation,this.hasPreluActivationWeights,this.isVec4)}\n      ${an(this.addBias,this.activation,this.batchAEqualOne,this.batchBEqualOne,!1,this.transposeB,this.fitAOuter,this.fitBOuter,this.fitInner,this.isVec4?4:1)}\n      ${this.isVec4?on(this.elementsPerThread,this.workGroupSize,this.transposeA,this.tileInner,!1,null,this.isVectorA):this.isVectorA?function(e,t=!1){return r.assert(1===e[1]&&1===e[2],(()=>`A linear work group size is required. But got ${e}.`)),`\n    const TileSize = ${4*e[0]};\n    var<workgroup> mm_Asub : array<vec4<f32>, ${e[0]}>;\n\n    ${$t()} {\n      let tileCol = i32(localId.x);\n      let globalCol = i32(globalId.x);\n      let globalRow = i32(globalId.y);\n\n      let numTiles = (uniforms.dimInner - 1) / TileSize + 1;\n      let batch = i32(globalId.z);\n      // Without this initialization strange values show up in acc.\n      var acc = 0.0;\n\n      // Loop over shared dimension.\n      for (var t = 0; t < numTiles; t = t + 1) {\n        // Load one tile of A into local memory.\n        let colA = t * TileSize + tileCol * 4;\n        mm_Asub[tileCol] = vec4<f32>(${(e=>e?"\n      mm_readA(batch, colA, globalRow),\n      mm_readA(batch, colA + 1, globalRow),\n      mm_readA(batch, colA + 2, globalRow),\n      mm_readA(batch, colA + 3, globalRow)\n  ":"\n      mm_readA(batch, globalRow, colA),\n      mm_readA(batch, globalRow, colA + 1),\n      mm_readA(batch, globalRow, colA + 2),\n      mm_readA(batch, globalRow, colA + 3)\n  ")(t)});\n        workgroupBarrier();\n\n        // Compute acc values for a single thread.\n        for (var k = 0; k < TileSize / 4; k = k + 1) {\n          let rowB = t * TileSize + k * 4;\n          let BCached = vec4<f32>(mm_readB(batch, rowB, globalCol),\n                              mm_readB(batch, rowB + 1, globalCol),\n                              mm_readB(batch, rowB + 2, globalCol),\n                              mm_readB(batch, rowB + 3, globalCol));\n\n          let ACached = mm_Asub[k];\n          acc = acc + dot(ACached, BCached);\n        }\n\n        workgroupBarrier();\n      }\n\n      mm_write(batch, globalRow, globalCol, acc);\n    }\n  `}(this.workGroupSize,this.transposeA):ln(this.elementsPerThread,this.workGroupSize,this.transposeA,this.tileInner,!1,null,this.sequentialAccessByThreads)}\n    `;return e}}class dn{constructor(e,t,n,r=!1,s=!1,i=null,a=null,o=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workGroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout={x:[],y:[1,2],z:[0]},this.dispatch=Bt(this.dispatchLayout,this.outputShape,this.workGroupSize);const u=null!=i,l=null!=o;u&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),this.transposeA=r,this.transposeB=s,this.addBias=u,this.activation=a,this.hasPreluActivationWeights=l,this.batchAEqualOne=t,this.batchBEqualOne=n,this.shaderKey=`matMulReduce_${this.activation}_${r}_${s}_${this.batchAEqualOne}_${this.batchBEqualOne}`}getUserCode(){return`\n      ${nn(this.activation,this.hasPreluActivationWeights)}\n      ${an(this.addBias,this.activation,this.batchAEqualOne,this.batchBEqualOne,this.transposeA,this.transposeB)}\n      \n    var<workgroup> sumValues : array<f32, workGroupSizeX>;\n    ${$t()} {\n      let coords = getOutputCoords();\n      let batch = coords[0];\n      let row = coords[1];\n      let col = coords[2];\n      var sum = 0.0;\n      let Length = uniforms.dimInner;\n      for (var k = i32(localId.x); k < Length; k = k + i32(workGroupSizeX)) {\n        let dataA = mm_readA(batch, row, k);\n        let dataB = mm_readB(batch, k, col);\n        sum = sum + dataA * dataB;\n      }\n      sumValues[localId.x] = sum;\n      workgroupBarrier();\n\n      for(var currentSize = workGroupSizeX / 2u; currentSize > 1u;\n          currentSize = currentSize / 2u) {\n        if (localId.x < currentSize)\n        {\n          sumValues[localId.x] = sumValues[localId.x] + sumValues[localId.x + currentSize];\n        }\n        workgroupBarrier();\n      }\n\n      if (localId.x == 0u) {\n        sum = sumValues[0] + sumValues[1];\n        mm_write(batch, row, col, sum);\n      }\n    }\n  \n    `}}class cn{constructor(e,t,n,r=!1,s=!1,i=null,a=null,o=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workGroupSize=[16,8,1],this.outputShape=n,this.dispatchLayout={x:[2],y:[1],z:[0]},this.dispatch=[Math.ceil(n[2]/this.workGroupSize[0]),Math.ceil(n[1]/this.workGroupSize[1]),n[0]];const u=null!=i;u&&this.variableNames.push("bias");const l=null!=o;l&&this.variableNames.push("preluActivationWeights"),this.transposeA=r,this.transposeB=s,this.addBias=u,this.activation=a,this.hasPreluActivationWeights=l,this.batchAEqualOne=1===e[0],this.batchBEqualOne=1===t[0],this.shaderKey=`matMulSmallOutputSize_${this.activation}_${r}_${s}_${this.batchAEqualOne}_${this.batchBEqualOne}`}getUserCode(){return`\n      ${nn(this.activation,this.hasPreluActivationWeights)}\n      ${an(this.addBias,this.activation,this.batchAEqualOne,this.batchBEqualOne,this.transposeA,this.transposeB)}\n      ${function(e){const t=e[1],n=e[0],r=t>n?t:n;return`\n  var<workgroup> mm_Asub : array<array<f32, ${r}>, ${t}>;\n  var<workgroup> mm_Bsub : array<array<f32, ${n}>, ${r}>;\n\n  // If the output size is small for matrix multiplication, avoid to use vec4\n  // and handle some elements per thread to optimally utilize the ALU.\n  // Read data from global memory to registers firstly, then store them into\n  // shared memory, so it is instruction-Level parallelism for arithmetic\n  // operations and others handle IO operations between barrier api, makes ALU\n  // and load/store units work simultaneously, could improves the performance.\n  ${$t()} {\n    let tileRow = i32(localId.y);\n    let tileCol = i32(localId.x);\n    let globalRow = i32(globalId.y);\n    let globalCol = i32(globalId.x);\n    let batch = i32(globalId.z);\n\n    // uniforms.dimInner should be greater than 0.\n    let numTiles = (uniforms.dimInner - 1) / ${r} + 1;\n    var acc = 0.0;\n\n    var globalColA = tileCol;\n    var globalRowB = 0;\n    var regA = mm_readA(batch, globalRow, globalColA);\n    var regB0 = mm_readB(batch, globalRowB + 2 * tileRow, globalCol);\n    var regB1 = mm_readB(batch, globalRowB + 2 * tileRow + 1, globalCol);\n    globalColA = globalColA + ${r};\n    globalRowB = globalRowB + ${r};\n\n    for (var t = 0; t < numTiles; t = t + 1) {\n      mm_Asub[tileRow][tileCol] = regA;\n      mm_Bsub[2 * tileRow][tileCol] = regB0;\n      mm_Bsub[2 * tileRow + 1][tileCol] = regB1;\n\n      workgroupBarrier();\n\n      regA = mm_readA(batch, globalRow, globalColA);\n      regB0 = mm_readB(batch, globalRowB + 2 * tileRow, globalCol);\n      regB1 = mm_readB(batch, globalRowB + 2 * tileRow + 1, globalCol);\n      globalColA = globalColA + ${r};\n      globalRowB = globalRowB + ${r};\n\n      for (var k = 0; k < ${r}; k = k + 1) {\n        acc = acc + mm_Asub[tileRow][k] * mm_Bsub[k][tileCol];\n      }\n      workgroupBarrier();\n    }\n\n    mm_write(batch, globalRow, globalCol, acc);\n  }\n  `}(this.workGroupSize)}\n    `}}class pn{constructor(e,t,n,s,i=!1,a=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workGroupSize=[8,8,1],this.atomic=!0,this.isVec4=!1,this.splitedDimInner=128,r.assert(1===e[0],(()=>"MatMulSplitKProgram only supports batch = 1.")),this.outputShape=e,this.dispatchLayout={x:[2],y:[1],z:[0,3]},this.isVec4=(i&&this.outputShape[1]%4==0||!i&&t%4==0)&&this.outputShape[2]%4==0,this.elementsPerThread=[4,4,this.splitedDimInner],this.isVec4||(this.outputShape[1]<16&&(this.elementsPerThread[1]=1),this.outputShape[2]<16&&(this.elementsPerThread[0]=1)),this.dispatch=Bt(this.dispatchLayout,[this.outputShape[0],this.outputShape[1],this.outputShape[2],t],this.workGroupSize,this.elementsPerThread),this.transposeA=i,this.transposeB=a,this.batchAEqualOne=n,this.batchBEqualOne=s,this.shaderKey=`matMulSplitK_${i}_${a}_${n}_${s}_${this.elementsPerThread}_${this.isVec4}`}getUserCode(){const e=this.isVec4?4:1,t=`\n      ${sn(this.batchAEqualOne,this.batchBEqualOne,!1,this.transposeB,!1,!1,!1,e)}\n      fn mm_write(batch: i32, row : i32, colIn : i32, value : ${tn(e)}) {\n        let col = colIn * ${e};\n        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {\n          let coords = vec3<i32>(batch, row, col);\n          let flatIndex = getOutputIndexFromCoords(coords);\n          // The problem is that we should initialize output to zero before using.\n          // Otherwise, the original value will be added to the result.\n          ${(e=>`\n      for (var i = 0; i < ${e}; i = i + 1)\n      {\n        var oldValue = atomicLoad(&(result[flatIndex + i]));\n        var exchanged = false;\n        for (; !exchanged;) {\n          let newValueF32 = bitcast<f32>(oldValue) + ${e>1?"value[i]":"value"};\n          let newValue = bitcast<i32>(newValueF32);\n          let res = atomicCompareExchangeWeak(&(result[flatIndex + i]), oldValue, newValue);\n          oldValue = res.old_value;\n          exchanged = res.exchanged;\n        }\n      }\n      `)(e)}\n        }\n      }\n      ${this.isVec4?on(this.elementsPerThread,this.workGroupSize,this.transposeA,32,!0,this.splitedDimInner):ln(this.elementsPerThread,this.workGroupSize,this.transposeA,32,!0,this.splitedDimInner)}\n    `;return t}}class fn{constructor(e,t=null,n=null,r=null){this.uniforms="",this.variableNames=["x"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Bt(this.dispatchLayout,this.outputShape,this.workGroupSize),this.addBias=null!=t,this.hasPreluActivationWeights=null!=r,this.activation=n,this.addBias&&this.variableNames.push("bias"),this.hasPreluActivationWeights&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`biasActivation_${n}`}getUserCode(){return`\n    ${nn(this.activation,this.hasPreluActivationWeights)}\n    ${$t("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        var value = getXByOutputIndex(index);\n        ${rn(this.addBias,this.activation)}\n        setOutputAtIndex(index, value);\n      }\n    }\n    `}}class mn{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="value : f32,",this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Bt(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="fill"}getUserCode(){return`\n    ${$t("index")} {\n      if (index < uniforms.size) {\n        setOutputAtIndex(index, uniforms.value);\n      }\n    }\n  `}}function gn(e){const{backend:t,attrs:n}=e,{shape:s,value:i}=n;let{dtype:a}=n;if(a=a||r.inferDtype(i),"string"===a){const e=r.getArrayFromDType(a,r.sizeFromShape(s));return e.fill(i),t.makeTensorInfo(s,a,e)}{const e=new mn(s),n=[{type:"float32",data:[i]}];return t.runWebGPUProgram(e,[],a,n)}}const bn={kernelName:l,backendName:"webgpu",kernelFunc:gn};function xn(e){const{inputs:t,attrs:n}=e,{x:s}=t,{shape:i}=n,a=r.sizeFromShape(s.shape),o=r.inferFromImplicitShape(i,a),u=r.sizeFromShape(o);return r.assert(a===u,(()=>`The new shape (${o}) has ${u} elements and the old shape (${s.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`)),e.backend.incRef(s.dataId),{dataId:s.dataId,shape:o,dtype:s.dtype}}const wn={kernelName:h,backendName:"webgpu",kernelFunc:xn};function In({a:e,b:n,transposeA:s,transposeB:i,backend:a,bias:o=null,preluActivationWeights:u=null,leakyreluAlpha:l=0,activation:h=null}){const c=e.shape.length,p=n.shape.length,f=s?e.shape[c-2]:e.shape[c-1],m=i?n.shape[p-1]:n.shape[p-2],g=s?e.shape[c-1]:e.shape[c-2],b=i?n.shape[p-2]:n.shape[p-1],x=e.shape.slice(0,-2),w=n.shape.slice(0,-2),I=r.sizeFromShape(x),y=r.sizeFromShape(w),k=d.assertAndGetBroadcastShape(e.shape.slice(0,-2),n.shape.slice(0,-2)).concat([g,b]);r.assert(f===m,(()=>`Error in matMul: inner shapes (${f}) and (${m}) of Tensors with shapes ${e.shape} and ${n.shape} and transposeA=${s} and transposeB=${i} must match.`));const S=s?[I,f,g]:[I,g,f],v=i?[y,b,m]:[y,m,b],C=xn({inputs:{x:e},backend:a,attrs:{shape:S}}),$=xn({inputs:{x:n},backend:a,attrs:{shape:v}}),R=[C,$],A=Math.max(I,y),T=1===I,z=1===y,P=[C,$],E=[{type:"int32",data:[g]},{type:"int32",data:[b]},{type:"int32",data:[f]}];let N,B;const _=[A,g,b];let F=t().get("WEBGPU_MATMUL_PROGRAM_TYPE");switch(F<0&&(F=g*b<=128?Wt.MatMulReduceProgram:1===A&&g<=128&&b<=48&&m>=2e3?Wt.MatMulSplitKProgram:g<=16&&(b<=512||m>=2*b)||b<=16&&(g<=512||f>=2*g)?Wt.MatMulSmallOutputSizeProgram:Wt.MatMulPackedProgram),F){case Wt.MatMulReduceProgram:N=new dn(_,T,z,s,i,o,h,u);break;case Wt.MatMulSplitKProgram:if(B=gn({backend:a,attrs:{shape:_,value:0,dtype:e.dtype}}),N=new pn(_,m,T,z,s,i),o||h){B=a.runWebGPUProgram(N,P,e.dtype,E,B);const t=new fn(B.shape,o,h,u);let n=null;const r=[B];o&&r.push(o),u&&r.push(u),"leakyrelu"===h&&(n=[{type:"float32",data:[l]}],t.uniforms+=" alpha : f32,");const s=a.runWebGPUProgram(t,r,B.dtype,n);R.push(B);const i=xn({inputs:{x:s},backend:a,attrs:{shape:k}});R.push(s);for(const e of R)a.disposeData(e.dataId);return i}break;case Wt.MatMulSmallOutputSizeProgram:N=new cn(S,v,_,s,i,o,h,u);break;case Wt.MatMulPackedProgram:const t=a.adapterInfo.isIntel();N=new hn(S,_,T,z,s,i,o,h,u,t);break;default:throw new Error(`Unsupported MatMulProgramType ${F}.`)}o&&P.push(o),u&&P.push(u),"leakyrelu"===h&&(E.push({type:"float32",data:[l]}),N.uniforms+=" alpha : f32,"),B=a.runWebGPUProgram(N,P,e.dtype,E,B);const O=xn({inputs:{x:B},backend:a,attrs:{shape:k}});R.push(B);for(const e of R)a.disposeData(e.dataId);return O}const yn={kernelName:c,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:i,bias:a,preluActivationWeights:o}=t,{transposeA:u,transposeB:l,activation:h,leakyreluAlpha:d}=r;return In({a:s,b:i,transposeA:u,transposeB:l,backend:n,bias:a,preluActivationWeights:o,leakyreluAlpha:d,activation:h})}};class kn{constructor(e,t,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.workGroupSize=[128,1,1],this.size=!0,this.outputShape=n.assertAndGetBroadcastShape(t,r),this.dispatchLayout=Gt(this.outputShape),this.dispatch=Bt(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey=`binaryOpComplex_${e}`,this.op=e}getUserCode(){return`\n      fn binaryOpComplex(\n          areal : f32, aimag : f32, breal : f32, bimag : f32) -> f32 {\n        ${Zt(this.op,!1)}\n      }\n\n      ${$t("index")} {\n        if(index < uniforms.size) {\n          let areal = getARealByOutputIndex(index);\n          let aimag = getAImagByOutputIndex(index);\n          let breal = getBRealByOutputIndex(index);\n          let bimag = getBImagByOutputIndex(index);\n          setOutputAtIndex(index, binaryOpComplex(areal, aimag, breal, bimag));\n        }\n      }\n    `}}class Sn{constructor(e,t,s){this.size=!0,this.variableNames=["A","B"],this.outputShape=n.assertAndGetBroadcastShape(t,s),this.dispatchLayout=Gt(this.outputShape),this.op=e,this.useSharedMemoryWithA=t.length<=1&&s.length>1&&t[0]<128,this.useSharedMemoryWithB=s.length<=1&&t.length>1&&s[0]<128,this.useSharedMemoryWithA||this.useSharedMemoryWithB?(this.isVec4=!1,this.lastDimensionSize=this.useSharedMemoryWithB?s[0]:t[0],this.shaderKey=`binary_${this.type}_${e}_${this.lastDimensionSize}_${this.useSharedMemoryWithB}`,this.type="shared",this.workGroupSize=[256,1,1],this.workPerThread=1):(r.arraysEqual(t,s)&&r.sizeFromShape(t)%4==0?(this.isVec4=!0,this.type="vec4",this.workPerThread=4):(this.isVec4=!1,this.type="plain",this.workPerThread=1),this.shaderKey=`binary_${this.type}_${e}`,this.workGroupSize=[128,1,1]),this.dispatch=Bt(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1])}getUserCode(){let e;const t=this.isVec4?"vec4<f32>":"f32",n=`\n    fn binaryOperation(a : ${t}, b : ${t}) -> ${t} {\n      ${Zt(this.op,this.isVec4)}\n    };\n    `;if("shared"===this.type){const t=this.lastDimensionSize>1?`coords[${this.outputShape.length-1}]`:"0",r=this.useSharedMemoryWithB?`let a = getAByOutputIndex(index);\n          let b = sharedBuf[${t}];`:`let a = sharedBuf[${t}];\n          let b = getBByOutputIndex(index);`;e=`\n        ${n}\n        var<workgroup> sharedBuf : array<f32, ${this.lastDimensionSize}>;\n        ${$t("index")} {\n          // Fill in the shared memory buffer.\n          let localIndex = i32(localId.x);\n          if(localIndex < ${this.lastDimensionSize}) {\n            sharedBuf[localIndex] = f32(${this.useSharedMemoryWithB?"B":"A"}[localIndex]);\n          }\n          workgroupBarrier();\n\n          if(index < uniforms.size) {\n            let coords = getCoordsFromIndex(index);\n            ${r}\n            setOutputAtIndex(index, binaryOperation(a, b));\n          }\n        }\n        `}else e=`\n       ${n}\n       ${$t("index")} {\n         if (index < uniforms.size) {\n           let a = getAByOutputIndex(index);\n           let b = getBByOutputIndex(index);\n           setOutputAtIndex(index, binaryOperation(a, b));\n         }\n       }\n       `;return e}}function vn(e){const{inputs:t}=e,{x:n}=t;return e.backend.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}const Cn={kernelName:p,backendName:"webgpu",kernelFunc:vn};function $n(e){const{inputs:t,backend:n}=e,{real:r,imag:s}=t,i=n.makeTensorInfo(r.shape,"complex64"),a=n.tensorMap.get(i.dataId),o=vn({inputs:{x:r},backend:n}),u=vn({inputs:{x:s},backend:n});return a.complexTensorInfos={real:o,imag:u},i}const Rn={kernelName:f,backendName:"webgpu",kernelFunc:$n};class An{constructor(e,t){this.variableNames=["A"],this.size=!0;this.workGroupSize=[128,1,1],this.outputShape=e,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Bt(this.dispatchLayout,this.outputShape,this.workGroupSize),this.op=t,this.shaderKey=`unary_${t}`}getUserCode(){return`\n      fn unaryOperation(a : f32) -> f32 {\n        ${en(this.op,!1)}\n      }\n      ${$t("index")} {\n        if (index < uniforms.size) {\n          let a = getAByOutputIndex(index);\n          setOutputAtIndex(index, unaryOperation(a));\n        }\n      }\n      `}}function Tn({opType:e,cpuKernelImpl:t,dtype:n}){return({inputs:r,backend:s})=>{const{x:i}=r,a=s,o=n||i.dtype;if(a.shouldExecuteOnCPU([i])&&null!=t){const e=a.tensorMap.get(i.dataId),n=t(e.values,o);return a.makeTensorInfo(i.shape,o,n)}const u=new An(i.shape,e);return a.runWebGPUProgram(u,[i],o)}}function zn({opType:e,cpuKernelImpl:t,supportsComplex:r=!1,dtype:s}){return({inputs:i,backend:a})=>{const{a:o,b:u}=i,l=a;if(r&&"complex64"===o.dtype){const t=l.tensorMap.get(o.dataId),n=l.tensorMap.get(u.dataId);let r,s;if(e!==Xt.MUL)[r,s]=[[t.complexTensorInfos.real,n.complexTensorInfos.real],[t.complexTensorInfos.imag,n.complexTensorInfos.imag]].map((t=>{const[n,r]=t,s={dataId:n.dataId,dtype:n.dtype,shape:o.shape},i={dataId:r.dataId,dtype:r.dtype,shape:u.shape},a=new Sn(e,o.shape,u.shape);return l.runWebGPUProgram(a,[s,i],m(n.dtype,r.dtype))}));else{const e=new kn(Xt.COMPLEX_MULTIPLY_REAL,o.shape,u.shape),i=new kn(Xt.COMPLEX_MULTIPLY_IMAG,o.shape,u.shape),a=[{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:o.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:o.shape},{dataId:n.complexTensorInfos.real.dataId,dtype:n.complexTensorInfos.real.dtype,shape:u.shape},{dataId:n.complexTensorInfos.imag.dataId,dtype:n.complexTensorInfos.imag.dtype,shape:u.shape}];r=l.runWebGPUProgram(e,a,"float32"),s=l.runWebGPUProgram(i,a,"float32")}const i=$n({inputs:{real:r,imag:s},backend:l});return l.disposeData(r.dataId),l.disposeData(s.dataId),i}const h=s||m(o.dtype,u.dtype);if(("string"===o.dtype||"string"===u.dtype||l.shouldExecuteOnCPU([o,u]))&&null!=t){const e=l.tensorMap.get(o.dataId).values,r=l.tensorMap.get(u.dataId).values,s="string"===o.dtype?n.fromUint8ToStringArray(e):e,i="string"===o.dtype?n.fromUint8ToStringArray(r):r,[a,d]=t(o.shape,u.shape,s,i,h);return l.makeTensorInfo(d,h,a)}const d=new Sn(e,o.shape,u.shape);return l.runWebGPUProgram(d,[o,u],h)}}function Pn(e){return(t,s,i,a,o)=>{const u=n.assertAndGetBroadcastShape(t,s),l=u.length,h=r.computeStrides(u),d=r.sizeFromShape(u),c=r.getTypedArrayFromDType(o,d),p=t.length,f=s.length,m=r.computeStrides(t),g=r.computeStrides(s),b=n.getBroadcastDims(t,u),x=n.getBroadcastDims(s,u);if(b.length+x.length===0)for(let t=0;t<c.length;++t)c[t]=e(i[t%i.length],a[t%a.length]);else for(let t=0;t<c.length;++t){const n=r.indexToLoc(t,l,h),s=n.slice(-p);b.forEach((e=>s[e]=0));const o=r.locToIndex(s,p,m),u=n.slice(-f);x.forEach((e=>u[e]=0));const d=r.locToIndex(u,f,g);c[t]=e(i[o],a[d])}return[c,u]}}const En=Pn(((e,t)=>e+t));function Nn(e){return(t,n,s)=>{const i=r.getTypedArrayFromDType(n,t.length);for(let n=0;n<t.length;++n)i[n]=e(t[n],s);return i}}const Bn=Nn((e=>Math.ceil(e)));const _n=Pn(((e,t)=>e===t?1:0)),Fn=Nn((e=>Math.exp(e))),On=Nn((e=>Math.expm1(e))),Gn=Nn((e=>Math.floor(e)));const Ln=Pn(((e,t)=>e>t?1:0)),Dn=Pn(((e,t)=>e>=t?1:0)),Un=Pn(((e,t)=>e<t?1:0)),Wn=Pn(((e,t)=>e<=t?1:0));const Mn=Nn((e=>Math.log(e)));const Vn=Pn(((e,t)=>Math.max(e,t))),Hn=Pn(((e,t)=>Math.min(e,t))),Xn=Pn(((e,t)=>e*t));const qn=Pn(((e,t)=>e!==t?1:0));function Kn(e,t,n,r){const s=[];let i=0;const a=t.length-1+n.length,o=new Array(a).fill(null).map((()=>[0]));!function(e,t){for(let n=0;n<e.length;++n){const r=e[n],s=n===e.length-1?t:e[n+1].length;if(0===r.length)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>s)throw new Error("Ragged splits must not point past values");for(let e=1;e<r.length;++e)if(r[e-1]>r[e])throw new Error("Ragged splits must be sorted in ascending order")}}(n,r);let u=1;for(let e=0;e<t.length-1;++e){u*=t[e];const n=t[e+1];for(let t=1;t<u+1;++t)o[e].push(t*n)}for(let r=0;r<e.length;++r){let a=e[r],u=e[r]+1;for(let e=0;e<n.length;++e){const r=n[e],s=e+t.length-1;if(s>=0){const e=o[s],t=e[e.length-1]-r[a];for(let e=a;e<u;++e)o[s].push(r[e+1]+t)}a=r[a],u=r[u]}u!==a&&(s.push([a,u]),i+=u-a)}return{outSplits:o,valueSlices:s,numValues:i}}function Yn(e,t){const n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let r=t;r<e.length;r++)n[t-1]*=e[r];return n}function jn(e,t,n,s,i){const a=t.slice();a[0]=i;const o=r.getArrayFromDType(n,r.sizeFromShape(a)),u=e.length;return function(e,t,n,r,s,i){const a=Yn(t,2)[1],o=Yn(i,2)[1];let u=0;for(const t of n)for(let n=t[0];n<t[1];++n){for(let t=0;t<r;++t)s[u*o+t]=e[n*a+t];++u}}(e,t,s,0===u?0:u/t[0],o,a),[o,a]}var Qn=n.RowPartitionType;class Zn{constructor(e,t,r,s,i,a,o,u,l,h){this.shape=e,this.shapeShape=t,this.values=r,this.valuesShape=s,this.valuesDType=i,this.defaultValue=a,this.defaultValueShape=o,this.rowPartitionValues=u,this.rowPartitionValuesShapes=l,this.rowPartitionTypes=n.getRowPartitionTypesHelper(h),this.raggedRank=n.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===Qn.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===Qn.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case Qn.VALUE_ROWIDS:return Zn.getMaxWidthValueRowID(t);case Qn.ROW_SPLITS:return Zn.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${Qn[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const t=e.length;if(0===t||1===t)return 0;let n=0;for(let r=0;r<t-1;++r){const t=e[r+1]-e[r];t>n&&(n=t)}return n}static getMaxWidthValueRowID(e){const t=e.length;if(0===t)return 0;let n=0,r=e[0],s=0;for(let i=1;i<t;++i){const t=e[i];t!==r&&(r=t,s=Math.max(i-n,s),n=i)}return Math.max(t-n,s)}tensorShapeFromTensor(e,t,n=!0){if(0===t.length){if(-1===e[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return er(e,n)}calculateOutputSize(e){const t=this.valuesShape,r=this.defaultValueShape;n.validateDefaultValueShape(r,t);const s=this.tensorShapeFromTensor(this.shape,this.shapeShape),i=n.combineRaggedTensorToTensorShapes(this.raggedRank,s,t);i[0]<0&&(i[0]=e);for(let e=1;e<=this.raggedRank;++e)i[e]<0&&(i[e]=this.getMaxWidth(e));return i}calculateFirstParentOutputIndex(e,t,n){const s=Math.min(e,n),i=[];let a=0;for(let e=0;e<s;++e,a+=t)i.push(a);for(let t=s;t<e;++t)i.push(-1);return r.assert(i.length===e,(()=>"Final length of result must be equal to firstDimension.")),i}calculateOutputIndexRowSplit(e,t,n,r){const s=e.length,i=[];for(let a=0;a<s-1;++a){const s=e[a+1]-e[a];let o=Math.min(r,s),u=t[a];-1===u&&(o=0);for(let e=0;e<o;++e)i.push(u),u+=n;for(let e=0;e<s-o;++e)i.push(-1)}if(s>0&&i.length!==e[s-1])throw new Error("Invalid row split size.");return i}calculateOutputIndexValueRowID(e,t,n,r){const s=e.length,i=[];if(0===s)return[];let a=0,o=e[0];if(o>=t.length)throw new Error(`Got currentValueRowId=${o}, which is not less than ${t.length}`);let u=t[o];i.push(u);for(let l=1;l<s;++l){const s=e[l];if(s===o)u>=0&&(++a,a<r?u+=n:u=-1);else{if(a=0,o=s,s>=t.length)throw new Error(`Got nextValueRowId=${s} which is not less than ${t.length}`);u=t[s]}i.push(u)}if(i.length!==e.length)throw new Error("Invalid row ids.");return i}calculateOutputIndex(e,t,n,r){const s=this.getRowPartitionTensor(e),i=this.getRowPartitionTypeByDimension(e);switch(i){case Qn.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(s,t,n,r);case Qn.ROW_SPLITS:if(s.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${s.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(s,t,n,r);default:throw new Error(`Unsupported partition type: ${Qn[i]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case Qn.FIRST_DIM_SIZE:return e[0];case Qn.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Qn.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Qn[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),t=this.calculateOutputSize(e),n=new Array(this.raggedRank+1);n[n.length-1]=1;for(let e=n.length-2;e>=0;--e)n[e]=n[e+1]*t[e+1];const s=er(t,!1),i=r.getArrayFromDType(this.valuesDType,r.sizeFromShape(s));if(n[0]*t[0]>0){let r=this.calculateFirstParentOutputIndex(e,n[0],t[0]);for(let e=1;e<=this.raggedRank;++e){r=this.calculateOutputIndex(e-1,r,n[e],t[e])}this.setOutput(this.raggedRank,r,i,s)}return[s,i]}setOutput(e,t,n,s){if(0===n.length)return;const i=this.values,a=n;let o=s.slice();o=o.slice(e+1);const u=r.sizeFromShape(o),l=t.length;let h=this.defaultValue;if(h.length!==u&&1!==h.length){const e=this.defaultValueShape;g((()=>{const t=b(h,e),n=x(t,o);h=n.dataSync()}))}let d=0,c=0,p=0;for(let e=0;e<=l;++e){let r=e<l?t[e]:-1;if(r!==p){if(c<p){const e=i.subarray(d*u);Jn(a.subarray(c*u),e,(p-c)*u)}if(e>=l){const e=n.length;r=Math.floor(e/u)}if(r>p)if(1===this.defaultValue.length)a.subarray(p*u,r*u).fill(this.defaultValue[0]),p=r;else for(;r>p;){Jn(a.slice(p*u),h,u),++p}r<0?(d=e+1,c=p):(d=e,c=p,p=c+1)}else++p}}}function Jn(e,t,n){for(let r=0;r<n;r++)e[r]=t[r]}function er(e,t){const n=[];for(let r of e){if(r<0){if(!t)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}n.push(r)}return n}const tr=Nn((e=>1/Math.sqrt(e)));const nr=Nn((e=>1/(1+Math.exp(-e))));const rr=Nn((e=>Math.sqrt(e))),sr=Pn(((e,t)=>{const n=e-t;return n*n}));class ir{constructor(e,t,n,s,i,a){this.separator=r.encodeString(e),this.nGramWidths=t,this.leftPad=r.encodeString(n),this.rightPad=r.encodeString(s),this.padWidth=i,this.preserveShort=a}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,r,s,i){for(let a=0;a<s;++a){const o=this.getPadWidth(i),u=Math.max(0,o-a),l=Math.max(0,o-(s-(a+1))),h=i-(u+l),d=t+(u>0?0:a-o);let c=0;c+=u*this.leftPad.length;for(let t=0;t<h;++t)c+=e[d+t].length;c+=l*this.rightPad.length;c+=(u+l+h-1)*this.separator.length,n[r+a]=new Uint8Array(c);const p=n[r+a];let f=0;const m=e=>e.forEach((e=>p[f++]=e));for(let e=0;e<u;++e)m(this.leftPad),m(this.separator);for(let t=0;t<h-1;++t)m(e[d+t]),m(this.separator);if(h>0){m(e[d+h-1]);for(let e=0;e<l;++e)m(this.separator),m(this.rightPad)}else{for(let e=0;e<l-1;++e)m(this.rightPad),m(this.separator);m(this.rightPad)}}}compute(e,t){const n=e.length,s=t.length;if(s>0){let e=t[0];if(0!==e)throw new Error(`First split value must be 0, got ${e}`);for(let r=1;r<s;++r){let s=t[r]>=e;if(s=s&&t[r]<=n,!s)throw new Error(`Invalid split value ${t[r]}, must be in [${e}, ${n}]`);e=t[r]}if(e!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${e}`)}const i=s-1,a=r.getArrayFromDType("int32",s);if(0===n||0===s){const e=new Array(n);for(let e=0;e<=i;++e)a[e]=0;return[e,a]}a[0]=0;for(let e=1;e<=i;++e){const n=t[e]-t[e-1];let r=0;this.nGramWidths.forEach((e=>{r+=this.getNumNGrams(n,e)})),this.preserveShort&&n>0&&0===r&&(r=1),a[e]=a[e-1]+r}const o=new Array(a[i]);for(let n=0;n<i;++n){const r=t[n];let s=a[n];if(this.nGramWidths.forEach((i=>{const a=t[n+1]-t[n],u=this.getNumNGrams(a,i);this.createNGrams(e,r,o,s,u,i),s+=u})),this.preserveShort&&s===a[n]){const i=t[n+1]-t[n];if(0===i)continue;const a=i+2*this.padWidth,u=1;this.createNGrams(e,r,o,s,u,a)}}return[o,a]}}function ar(e,t,n,r){if(!e.length)return;if(0===t.length){for(let t=0;t<e.length;++t)r.push(e.subarray(t,t+1));return}if(1===t.length){const s=t[0];let i=e.indexOf(s);for(;-1!==i;){const t=e.subarray(0,i);n&&0===t.length||r.push(t),i=(e=e.subarray(i+1)).indexOf(s)}return void(n&&0===e.length||r.push(e))}let s=0;for(let i=0;i<e.length+1;i++)if(i===e.length||-1!==t.indexOf(e[i])){const t=e.subarray(s,i);n&&0===t.length||r.push(t),s=i+1}}const or=Pn(((e,t)=>e-t));const ur=(e,t)=>{const n=t.value-e.value;return 0===n?e.index-t.index:n};function lr(e,t,n=0,s=e.length-1){for(;s>n;){if(s-n>600){const r=s-n+1,i=t-n+1,a=Math.log(r),o=.5*Math.exp(2*a/3),u=.5*Math.sqrt(a*o*(r-o)/r)*Math.sign(i-r/2);lr(e,t,Math.max(n,Math.floor(t-i*o/r+u)),Math.min(s,Math.floor(t+(r-i)*o/r+u)))}const i=e[t];let a=n,o=s;for(r.swap(e,n,t),ur(e[s],i)>0&&r.swap(e,n,s);a<o;){for(r.swap(e,a,o),a++,o--;ur(e[a],i)<0;)a+=1;for(;ur(e[o],i)>0;)o-=1}0===ur(e[n],i)?r.swap(e,n,o):(o+=1,r.swap(e,o,s)),o<=t&&(n=o+1),t<=o&&(s=o-1)}}var hr={__proto__:null,simpleAbsImpl:function(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t},addImpl:En,bincountImpl:function(e,t,n,s,i){const a=r.sizeFromShape(s),o=r.makeZerosTypedArray(i,n);for(let n=0;n<e.length;n++){const r=e[n];if(r<0)throw new Error("Input x must be non-negative!");r>=i||(o[r]+=a>0?t[n]:1)}return o},bincountReduceImpl:function(e,t,n,r=!1){const s=e.shape[0],i=e.shape[1],a=o([s,n],t.dtype);for(let o=0;o<s;o++)for(let s=0;s<i;s++){const i=e.get(o,s);if(i<0)throw new Error("Input x must be non-negative!");i>=n||(r?a.set(1,o,i):t.size>0?a.set(a.get(o,i)+t.get(o,s),o,i):a.set(a.get(o,i)+1,o,i))}return a},castImpl:function(e,t,n,s){if("int32"===s){return[t,"int32",Int32Array.from(e)]}if("bool"===s){const s=r.toTypedArray([0],n),[i,a]=Pn(((e,t)=>e!==t?1:0))(t,[],e,s,"bool");return[a,"bool",i]}throw new Error(`Error in Cast: failed to cast ${n} to ${s}`)},ceilImpl:Bn,concatImpl:function(e,t,s,i){const a=r.getArrayFromDType(s,r.sizeFromShape(t));if(i&&"string"!==s){let t=0;e.forEach((e=>{const n=r.sizeFromShape(e.shape);a.set(e.vals,t),t+=n}))}else{let r=0;e.forEach((e=>{const i="string"===s?n.fromUint8ToStringArray(e.vals):e.vals;let o=0;for(let n=0;n<e.shape[0];++n){const s=n*t[1]+r;for(let t=0;t<e.shape[1];++t)a[s+t]=i[o++]}r+=e.shape[1]}))}return a},equalImpl:_n,expImpl:Fn,expm1Impl:On,floorImpl:Gn,gatherNdImpl:function(e,t,n,r,s,i,a,u,l){const h=o([r,i],n);for(let n=0;n<r;n++){const r=[];let o=0;for(let t=0;t<s;t++){const i=e[n*s+t];o+=i*a[t],r.push(i)}if(o<0||o>=l/i)throw new Error(`Invalid indices: ${r} does not index into ${u}`);for(let e=0;e<i;e++)h.values[n*i+e]=t.get(...t.indexToLoc(o*i+e))}return h},gatherV2Impl:function(e,t,n){const r=o(n,e.dtype);for(let n=0;n<r.size;++n){const s=r.indexToLoc(n).slice(),i=s[0],a=s[2],o=t.locToIndex([i,a]);s[2]=t.values[o];const u=e.locToIndex(s);0<=u&&u<e.values.length&&(r.values[n]=e.values[u])}return r},greaterImpl:Ln,greaterEqualImpl:Dn,lessImpl:Un,lessEqualImpl:Wn,linSpaceImpl:function(e,t,n){const s=(t-e)/(n-1),i=r.makeZerosTypedArray(n,"float32");i[0]=e;for(let e=1;e<i.length;e++)i[e]=i[e-1]+s;return i},logImpl:Mn,maxImpl:function(e,t,n,s){const i=r.getTypedArrayFromDType(s,r.sizeFromShape(n));for(let n=0;n<i.length;++n){const r=n*t;let s=e[r];for(let n=0;n<t;++n){const t=e[r+n];(Number.isNaN(t)||t>s)&&(s=t)}i[n]=s}return i},maximumImpl:Vn,minimumImpl:Hn,multiplyImpl:Xn,negImpl:function(e,t,n){const s=r.createScalarValue(-1,n);return Xn([],t,s,e,n)},notEqualImpl:qn,prodImpl:function(e,t,s,i){const[a,o]=n.computeOutAndReduceShapes(e,i),u=m(t,"int32"),l=r.makeZerosTypedArray(r.sizeFromShape(a),u),h=r.sizeFromShape(o);for(let e=0;e<l.length;++e){const t=e*h;let n=1;for(let e=0;e<h;++e)n*=s[t+e];l[e]=n}return{outVals:l,outShape:a,outDtype:u}},raggedGatherImpl:function(e,t,n,s,i,a,o,u){if(0===e.length)throw new Error("paramsNestedSplits must be non empty");if(0===t[0].length)throw new Error("Split tensors must not be scalars");if(function(e,t,n){e.forEach(((e,s)=>{if(e<0||e>=n){const i=r.indexToLoc(s,t.length,r.computeStrides(t)).join(",");throw new Error(`indices[${i}] = ${e} is not in [0, ${n})`)}}))}(a,o,t[0][0]-1),0===s.length)throw new Error("params.rank must be nonzero");const l=s[0],{outSplits:h,valueSlices:d,numValues:c}=Kn(a,o,e,l),p=function(e){const t=[];for(let n=0;n<e.length;++n){const s=e[n].length,i=r.getArrayFromDType("int32",s);t.push(i),e[n].forEach(((e,t)=>i[t]=e))}return t}(h),f=jn(n,s,i,d,c);return[p,f[0],f[1]]},raggedTensorToTensorImpl:function(e,t,n,r,s,i,a,o,u,l){return new Zn(e,t,n,r,s,i,a,o,u,l).compute()},rangeImpl:function(e,t,n,s){if(e===t||e<t&&n<0||t<e&&n>1)return r.makeZerosTypedArray(0,s);const i=Math.abs(Math.ceil((t-e)/n)),a=r.makeZerosTypedArray(i,s);t<e&&1===n&&(n=-1),a[0]=e;for(let e=1;e<a.length;e++)a[e]=a[e-1]+n;return a},rsqrtImpl:tr,scatterImpl:function(e,t,n,r,s,i,a,u,l,h){const d=[r/s,s],c=e.values,p=t.values;if(0===r)return o(n,t.dtype);const f=o(d,t.dtype);"string"==typeof l||"number"==typeof l?f.values.fill(l):"boolean"==typeof l&&f.values.fill(+l);for(let e=0;e<i;e++){const i=[];let o=0;for(let t=0;t<a;t++){const n=c[e*a+t];i.push(n),o+=n*u[t]}if(o<0||o>=r/s)throw new Error(`Invalid indices: ${i} does not index into ${n}`);for(let n=0;n<s;n++)h?f.values[o*s+n]+=p[e*s+n]:f.values[o*s+n]=0===t.rank?p[0]:p[e*s+n]}return f},sigmoidImpl:nr,sliceImpl:function(e,t,s,i,a){const u=w.isSliceContinous(i,t,s),l=r.sizeFromShape(s),h=r.computeStrides(i);if(u){const n=w.computeFlatOffset(t,h);return"string"===a?e.slice(n,n+l):e.subarray(n,n+l)}const d="string"===a?n.fromUint8ToStringArray(e):e,c=o(i,a,d),p=o(s,a);for(let e=0;e<p.size;++e){const n=p.indexToLoc(e),r=n.map(((e,n)=>e+t[n]));p.set(c.get(...r),...n)}return"string"===a?n.fromStringArrayToUint8(p.values):p.values},sparseFillEmptyRowsImpl:function(e,t,s,i,a,o,u){const l=t[0],h=o[0],d=new Array(h),c=new Array(l),p=t[1];if(0===h){if(0!==l)throw new Error(n.getSparseFillEmptyRowsIndicesDenseShapeMismatch(l));return[r.getArrayFromDType(s,0),[0,p],r.getArrayFromDType(a,0),d,c]}let f=!0,m=0;const g=new Array(h).fill(0);for(let t=0;t<l;++t){const r=e[t*p];if(r<0)throw new Error(n.getSparseFillEmptyRowsNegativeIndexErrorMessage(t,r));if(r>=h)throw new Error(n.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(t,r,h));++g[r],f=f&&r>=m,m=r}let b=!0;for(let e=0;e<h;++e){const t=0===g[e];d[e]=t,b=b&&!t,g[e]=Math.max(g[e],1),e>0&&(g[e]+=g[e-1])}if(b&&f){const t=e,n=i;for(let e=0;e<l;++e)c[e]=e;return[t,[l,p],n,d,c]}{const t=g[h-1],n=r.getArrayFromDType(s,t*p),o=r.getArrayFromDType(a,t),f=new Array(h).fill(0);for(let t=0;t<l;++t){const r=e[t*p],s=f[r],a=(0===r?0:g[r-1])+s;f[r]++;for(let r=0;r<p;++r)n[a*p+r]=e[t*p+r];o[a]=i[t],c[t]=a}for(let e=0;e<h;++e){if(0===f[e]){const t=0===e?0:g[e-1];n[t*p+0]=e;for(let e=1;e<p;++e)n[t*p+e]=0;o[t]=u}}return[n,[t,p],o,d,c]}},sparseReshapeImpl:function(e,t,s,i,a){const o=r.sizeFromShape(i),u=t[0],l=a.length,h=[];let d=1,c=-1;for(let e=0;e<l;++e){const t=a[e];if(-1===t){if(-1!==c)throw new Error(n.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(c,e));c=e,h.push(1)}else{if(t<0)throw new Error(n.getSparseReshapeNegativeOutputDimErrorMessage(e,t));d*=t,h.push(t)}}if(-1!==c){if(d<=0)throw new Error(n.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());const e=Math.trunc(o/d);if(d*e!==o)throw new Error(n.getSparseReshapeInputOutputMultipleErrorMessage(i,h));h[c]=e}if(r.sizeFromShape(h)!==o)throw new Error(n.getSparseReshapeInputOutputMismatchErrorMessage(i,h));const p=i.length,f=[];if(p>0){f[p-1]=1;for(let e=p-2;e>=0;--e)f[e]=f[e+1]*i[e+1]}const m=[];if(l>0){m[l-1]=1;for(let e=l-2;e>=0;--e)m[e]=m[e+1]*h[e+1]}const g=r.getArrayFromDType(s,u*l);for(let t=0;t<u;++t){let n=0;for(let r=0;r<p;++r)n+=e[t*p+r]*f[r];for(let e=0;e<l;++e)g[t*l+e]=Math.trunc(n/m[e]),n%=m[e]}return[g,[u,l],h]},sparseSegmentReductionImpl:function(e,t,s,i,a,o=!1,u=0){const l=i.length,h=[t[0],e.length/t[0]],d=h[1],c=l>0?a[l-1]+1:0;if(c<0)throw new Error(n.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());const p=t.slice();p[0]=c;const f=p.reduce(((e,t)=>e*t),1),m=r.getArrayFromDType(s,f);if(0===l)return c>0&&m.fill(u),[m,p];if(c<=0)throw new Error(n.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let g=0,b=1,x=0,w=a[g];for(;;){let t=0;if(b<l){if(t=a[b],w===t){++b;continue}if(w>=t)throw new Error(n.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(w<0||w>=c)throw new Error(n.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(w,c));w>x&&m.fill(u,x*d,w*d);for(let t=g;t<b;++t){const r=i[t];if(r<0||r>=h[0])throw new Error(n.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(t,i[t],h[0]));for(let t=0;t<d;t++)m[w*d+t]+=e[r*d+t]}if(o)for(let e=0;e<d;e++)m[w*d+e]/=b-g;if(g=b,++b,x=w+1,w=t,b>l)break}return x<c&&m.fill(u,x*d,c*d),[m,p]},sqrtImpl:rr,squaredDifferenceImpl:sr,stridedSliceImpl:function(e,t,n,r){const s=o(e,t.dtype);for(let e=0;e<s.size;e++){const i=s.indexToLoc(e),a=new Array(i.length);for(let e=0;e<a.length;e++)a[e]=i[e]*n[e]+r[e];s.set(t.get(...a),...i)}return s},stringNGramsImpl:function(e,t,n,r,s,i,a,o){return new ir(n,r,s,i,a,o).compute(e,t)},stringSplitImpl:function(e,t,n){const s=e.length,i=[];let a=0,o=0;const u=new Array(s);for(let r=0;r<s;++r){const s=i.length;ar(e[r],t,n,i);const l=i.length-s;u[r]=l,a+=l,o=Math.max(o,l)}const l=r.getArrayFromDType("int32",2*a),h=new Array(a),d=[s,o];let c=0;for(let e=0;e<s;++e)for(let t=0;t<u[e];++t)l[2*c]=e,l[2*c+1]=t,h[c]=i[c],++c;return[l,h,d]},stringToHashBucketFastImpl:function(e,t){const n=r.getArrayFromDType("int32",e.length);for(let s=0;s<e.length;++s)n[s]=r.fingerPrint64(e[s]).modulo(t).getLowBitsUnsigned();return n},subImpl:or,tileImpl:function(e,t){const n=new Array(e.rank);for(let r=0;r<n.length;r++)n[r]=e.shape[r]*t[r];const r=o(n,e.dtype);for(let t=0;t<r.values.length;++t){const n=r.indexToLoc(t),s=new Array(e.rank);for(let t=0;t<s.length;t++)s[t]=n[t]%e.shape[t];const i=e.locToIndex(s);r.values[t]=e.values[i]}return r},topKImpl:function(e,t,n,s,i){const a=t[t.length-1],[u,l]=[e.length/a,a],h=r.getTypedArrayFromDType(n,u*s),d=r.getTypedArrayFromDType("int32",u*s);for(let t=0;t<u;t++){const n=t*l,r=e.subarray(n,n+l);let a=new Array(r.length);r.forEach(((e,t)=>a[t]={value:e,index:t})),s<a.length&&(lr(a,s),a=a.slice(0,s)),i&&a.sort(ur);const o=t*s,u=h.subarray(o,o+s),c=d.subarray(o,o+s);for(let e=0;e<s;e++)u[e]=a[e].value,c[e]=a[e].index}const c=t.slice();return c[c.length-1]=s,[o(c,n,h),o(c,"int32",d)]},transposeImpl:function(e,t,n,s,i){const a=t.length,o=r.sizeFromShape(t),u=r.computeStrides(t),l=r.computeStrides(i),h=r.getTypedArrayFromDType(n,r.sizeFromShape(i));for(let t=0;t<o;++t){const n=r.indexToLoc(t,a,u),i=new Array(n.length);for(let e=0;e<i.length;e++)i[e]=n[s[e]];h[r.locToIndex(i,a,l)]=e[t]}return h},uniqueImpl:function(e,t,n,s){const i=r.parseAxisParam(t,n)[0],a=[1,n[0],1];for(let e=0;e<i;e++)a[0]*=n[e];a[1]=n[i];for(let e=i+1;e<n.length;e++)a[2]*=n[e];const o={},u=new Int32Array(n[i]),l=new I(a,s,e),h=[],d=1===a[0]&&1===a[2];for(let t=0;t<n[i];t++){let n;if(d)n=e[t].toString();else{const e=[];for(let n=0;n<a[0];n++)for(let r=0;r<a[2];r++)e.push(l.get(n,t,r));n=e.join(",")}if(void 0!==o[n])u[t]=o[n];else{const e=Object.keys(o).length;o[n]=e,u[t]=e,h.push(t)}}const c=a.slice();c[1]=Object.keys(o).length;const p=new I(c,s);h.forEach(((e,t)=>{for(let n=0;n<a[0];n++)for(let r=0;r<a[2];r++)p.set(l.get(n,e,r),n,t,r)}));const f=n.slice();return f[i]=c[1],{outputValues:p.values,outputShape:f,indices:u}}};const{addImpl:dr,castImpl:cr,ceilImpl:pr,concatImpl:fr,equalImpl:mr,expImpl:gr,expm1Impl:br,floorImpl:xr,gatherNdImpl:wr,gatherV2Impl:Ir,greaterEqualImpl:yr,greaterImpl:kr,lessEqualImpl:Sr,lessImpl:vr,logImpl:Cr,maxImpl:$r,maximumImpl:Rr,minimumImpl:Ar,multiplyImpl:Tr,negImpl:zr,notEqualImpl:Pr,prodImpl:Er,rangeImpl:Nr,rsqrtImpl:Br,scatterImpl:_r,simpleAbsImpl:Fr,sliceImpl:Or,stridedSliceImpl:Gr,stringNGramsImpl:Lr,subImpl:Dr,tileImpl:Ur,topKImpl:Wr,transposeImpl:Mr,uniqueImpl:Vr}=hr,Hr={kernelName:y,backendName:"webgpu",kernelFunc:Tn({opType:Jt.ABS,cpuKernelImpl:Fr})},Xr={kernelName:k,backendName:"webgpu",kernelFunc:zn({opType:Xt.ADD,cpuKernelImpl:dr,supportsComplex:!0})};class qr{constructor(e){this.workPerThread=1,this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e[0],this.variableNames=e.map(((e,t)=>`T${t}`)),this.dispatchLayout=Gt(this.outputShape),this.dispatch=Bt(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.shaderKey="addN"}getUserCode(){const e=[];this.variableNames.forEach((t=>{e.push(`let v${t} = get${t}ByOutputCoords(coords);`)}));const t=this.variableNames.map((e=>`v${e}`)).join(" + ");return`\n      ${$t("index")} {\n        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {\n          let flatIndex = index * ${this.workPerThread} + i;\n          if (flatIndex < uniforms.size) {\n            let coords = getCoordsFromIndex(flatIndex);\n            ${e.join("\n        ")}\n            setOutputAtIndex(flatIndex, ${t});\n          }\n        }\n      }\n    `}}const Kr={kernelName:S,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,r=t;if(1===r.length)return vn({inputs:{x:r[0]},backend:n});const s=r.map((e=>e.dtype)).reduce(((e,t)=>m(e,t))),i=r.map((e=>e.shape)),a=new qr(i);return n.runWebGPUProgram(a,r,s)}};class Yr{constructor(e,t,s){this.workGroupSize=[64,1,1],this.variableNames=["x"],this.uniforms="infinityValue : f32,",this.size=!0;const i=[t];this.op="min"===s?"<":">";const[a,o]=n.computeOutAndReduceShapes(e,i);this.outputShape=0===a.length?[1]:a,this.dispatchLayout=Gt(this.outputShape),r.sizeFromShape(o)<32||r.sizeFromShape(a)>1e3?(this.type="plain",this.dispatch=Bt(this.dispatchLayout,this.outputShape,this.workGroupSize)):(this.type="shared",this.dispatch=Bt(this.dispatchLayout,this.outputShape,[1,1,1])),this.inputShape=e,this.shaderKey=`argMinMax_${this.op}_${this.type}`}getUserCode(){const e=()=>1===this.inputShape.length?"uniforms.xShape":`uniforms.xShape.${Ct(this.inputShape.length-1)}`,t=()=>{let e="";if(1===this.outputShape.length)1!==this.inputShape.length&&(e+="outputCoords,");else for(let t=0;t<this.outputShape.length;t++)e+=`outputCoords.${Ct(t)},`;return e};if("shared"===this.type){return`\n      fn DIV_CEIL(a : u32, b : u32) -> u32 {\n        return ((a - 1u) / b + 1u);\n      }\n\n      ${`\n      var<workgroup> xBestIndices : array<i32, ${this.workGroupSize[0]}>;\n      var<workgroup> xBestValues : array<f32, ${this.workGroupSize[0]}>;\n    `}\n\n      ${$t("index")} {\n        let outputIndex = index / i32(workGroupSizeX);\n        let reduceLength = ${e()};\n\n        var bestIndex = i32(localId.x);\n        var bestValue = uniforms.infinityValue;\n        let outputCoords = getCoordsFromIndex(outputIndex);\n        for (var k = i32(localId.x); k < reduceLength && outputIndex < uniforms.size;\n            k = k + i32(workGroupSizeX)) {\n          let candidate = getX(${t()} k);\n          if (!isnan(candidate) && candidate ${this.op} bestValue) {\n            bestValue = candidate;\n            bestIndex = k;\n          }\n        }\n        xBestValues[localId.x] = bestValue;\n        xBestIndices[localId.x] = bestIndex;\n        workgroupBarrier();\n\n        var reduceSize = min(u32(reduceLength), workGroupSizeX);\n        for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n            currentSize = reduceSize / 2u) {\n          let interval = DIV_CEIL(reduceSize, 2u);\n          if (localId.x < currentSize) {\n            let candidate = xBestValues[localId.x + interval];\n            if (candidate ${this.op} bestValue) {\n              bestValue = candidate;\n              xBestValues[localId.x] = bestValue;\n              xBestIndices[localId.x] = xBestIndices[localId.x + interval];\n            }\n          }\n          reduceSize = interval;\n          workgroupBarrier();\n        }\n\n        if (localId.x == 0u && outputIndex < uniforms.size) {\n          setOutputAtIndexI32(outputIndex, xBestIndices[localId.x]);\n        }\n      }\n    `}return`\n      ${$t("index")} {\n        if (index < uniforms.size) {\n          let outputCoords = getCoordsFromIndex(index);\n          var bestIndex = 0;\n          var bestValue = getX(${t()} 0);\n          let reduceLength = ${e()};\n          for (var i = 1; i < reduceLength; i++) {\n            let candidate = getX(${t()} i);\n            if (candidate ${this.op} bestValue) {\n              bestValue = candidate;\n              bestIndex = i;\n            }\n          }\n          setOutputAtIndexI32(index, bestIndex);\n        }\n      }\n      `}}class jr{constructor(e,t){this.variableNames=["A"],this.workGroupSize=[16,16,1];const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];this.outputShape=n,this.dispatchLayout={x:[0],y:[1]},this.dispatch=Bt(this.dispatchLayout,this.outputShape,this.workGroupSize,[1,1,1]),this.shaderKey="transposeShared"}getUserCode(){return`\n      const TILE_DIM = ${this.workGroupSize[0]};\n      var<workgroup> tile : array<array<f32, ${this.workGroupSize[0]+1}>, ${this.workGroupSize[0]}>;\n      \n  @compute @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n\n      fn _start(@builtin(local_invocation_id) localId : vec3<u32>,\n                @builtin(workgroup_id) workgroupId : vec3<u32>) {\n        var x = i32(workgroupId.x) * TILE_DIM + i32(localId.x);\n        var y = i32(workgroupId.y) * TILE_DIM + i32(localId.y);\n        let width = uniforms.outShape[0];\n        let height = uniforms.outShape[1];\n        if (x < width && y < height) {\n          tile[localId.y][localId.x] = A[y * width + x];\n        }\n        workgroupBarrier();\n\n        x = i32(workgroupId.y) * TILE_DIM + i32(localId.x);\n        y = i32(workgroupId.x) * TILE_DIM + i32(localId.y);\n        if (x < height && y < width) {\n          setOutputAtIndex((y * height + x), tile[localId.x]\n            [localId.y]);\n        }\n      }\n    `}}class Qr{constructor(e,t){this.variableNames=["A"],this.workPerThread=1,this.workGroupSize=[64,1,1],this.size=!0;const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];this.outputShape=n,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Bt(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.newDim=t,this.shaderKey=`transpose_${t}`}getUserCode(){const e=vt(this.outputShape.length),t=function(e){const t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const n=new Array(t);for(let t=0;t<e.length;t++)n[e[t]]=`resRC.${Ct(t)}`;return n.join()}(this.newDim);return`\n      ${$t("index")} {\n        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {\n          let flatIndex = index * ${this.workPerThread} + i;\n          if(flatIndex < uniforms.size) {\n            let resRC = getCoordsFromIndex(flatIndex);\n            setOutputAtIndex(flatIndex, A[getIndexFromCoords${this.outputShape.length}D(\n              ${e}(${t}), uniforms.aShape)]);\n          }\n        }\n      }\n    `}}function Zr(e){const{inputs:t,backend:n,attrs:s}=e,{x:i}=t,{perm:a}=s,o=n,u=i.shape.length,l=new Array(u);for(let e=0;e<l.length;e++)l[e]=i.shape[a[e]];if(n.shouldExecuteOnCPU([i])){const e=o.tensorMap.get(i.dataId).values,t=Mr(e,i.shape,i.dtype,a,l);return n.makeTensorInfo(l,i.dtype,t)}if(2===i.shape.length&&r.arraysEqual(a,[1,0])){const e=new jr(i.shape,a);return o.runWebGPUProgram(e,[i],i.dtype)}const h=new Qr(i.shape,a);return o.runWebGPUProgram(h,[i],i.dtype)}const Jr={kernelName:v,backendName:"webgpu",kernelFunc:Zr};const es={kernelName:C,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:s,attrs:i}=e,{x:a}=t,{axis:o}=i;let u=r.parseAxisParam(o,a.shape);const l=n.getAxesPermutation(u,a.shape.length);let h=a;const d=[];null!=l&&(h=Zr({inputs:{x:a},backend:s,attrs:{perm:l}}),d.push(h),u=n.getInnerMostAxes(u.length,h.shape.length)),n.assertAxesAreInnerMostDims("argMax",[u[0]],h.shape.length);const c=new Yr(h.shape,u[0],"max"),p=[{type:"float32",data:[Number.NEGATIVE_INFINITY]}],f=s.runWebGPUProgram(c,[h],"int32",p);return d.forEach((e=>s.disposeData(e.dataId))),f}};const ts={kernelName:$,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:s,attrs:i}=e,{x:a}=t,{axis:o}=i;let u=r.parseAxisParam(o,a.shape);const l=n.getAxesPermutation(u,a.shape.length);let h=a;const d=[];null!=l&&(h=Zr({inputs:{x:a},backend:s,attrs:{perm:l}}),d.push(h),u=n.getInnerMostAxes(u.length,h.shape.length)),n.assertAxesAreInnerMostDims("argMin",[u[0]],h.shape.length);const c=new Yr(h.shape,u[0],"min"),p=[{type:"float32",data:[Number.POSITIVE_INFINITY]}],f=s.runWebGPUProgram(c,[h],"int32",p);return d.forEach((e=>s.disposeData(e.dataId))),f}},ns={kernelName:R,backendName:"webgpu",kernelFunc:zn({opType:Xt.ATAN2})};class rs{constructor(e,t){this.variableNames=["x"],this.uniforms="stride : vec2<i32>, pad : vec2<i32>, dilation : vec2<i32>, convDims : vec2<i32>, filterDims : vec2<i32>,",this.workGroupSize=[128,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Bt(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey=`pool2D_${t}`,this.poolType=t}getUserCode(){let e="resultValue = max(value, resultValue);";"avg"===this.poolType&&(e="resultValue = resultValue + value; count = count + 1.0;");let t="resultValue";"avg"===this.poolType&&(t="resultValue / count");return`\n      ${$t("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n          let batch = coords[0];\n          let xRCCorner = vec2<i32>(coords.yz) * uniforms.stride - uniforms.pad;\n          let xRCorner = xRCCorner.x;\n          let xCCorner = xRCCorner.y;\n\n          var resultValue = ${"avg"===this.poolType?"0.0":"-1.0 / pow(10.0, -20.0)"};\n          var count = 0.0;\n\n          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilation.x) {\n            let xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= uniforms.convDims.x) {\n              continue;\n            }\n\n            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilation.y) {\n              let xC = xCCorner + wC;\n              if (xC < 0 || xC >= uniforms.convDims.y) {\n                continue;\n              }\n\n              let value = getX(batch, xR, xC, coords[3]);\n              ${e}\n            }\n          }\n\n          setOutputAtIndex(index, ${t});\n        }\n      }\n    `}}class ss{constructor(e){this.variableNames=["x"],this.uniforms="stride : vec2<i32>,",this.workGroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Bt(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="poolWithFilterSizeEqualsOne"}getUserCode(){return`\n      ${$t("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let batch = coords[0];\n          let d = coords[3];\n\n          let xRCCorner = coords.yz * uniforms.stride;\n          let xRCorner = xRCCorner.x;\n          let xCCorner = xRCCorner.y;\n\n          let value = getX(batch, xRCorner, xCCorner, d);\n          setOutputAtIndex(index, value);\n        }\n      }\n    `}}class is{constructor(e,t){this.workGroupSize=[64,1,1],this.variableNames=["x"],this.uniforms="reduceSize : i32,",this.size=!0,this.inputShape=[e.batchSize,e.inSize];const[r]=n.computeOutAndReduceShapes(this.inputShape,[1]);this.outputShape=0===r.length?[1]:r,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Bt(this.dispatchLayout,this.outputShape,[1,1,1]),this.reduceType=t,this.shaderKey=`reduce_${t}`}getUserCode(){let e="",t="0.0";"min"===this.reduceType||"max"===this.reduceType?(e=`\n         if (isnan(candidate)) {\n          bestValue = uniforms.NAN;\n         } else if (!isnan(bestValue) && candidate ${"min"===this.reduceType?"<":">"} bestValue)\n           {  bestValue = candidate; }`,t="f32(x[offset])"):"sum"===this.reduceType||"mean"===this.reduceType?e=" bestValue = bestValue + candidate; ":"prod"===this.reduceType&&(e=" bestValue = bestValue * candidate; ",t="1.0");const n="mean"===this.reduceType?"setOutputAtIndex(outputIndex, bestValue / f32(uniforms.reduceSize));":"setOutputAtIndex(outputIndex, bestValue);";return`\n       fn DIV_CEIL(a : u32, b : u32) -> u32 {\n        return ((a - 1u) / b + 1u);\n       }\n\n       ${`\n         var<workgroup> xBestValues : array<f32, ${this.workGroupSize[0]}>;\n       `}\n       fn getOffset(outputIndex : i32) -> i32 {\n         let outputCoords = getCoordsFromIndex(outputIndex);\n         let offset = ${1===this.outputShape.length?"outputCoords":"outputCoords[0]"} * uniforms.reduceSize;\n          return offset;\n       }\n       ${$t("index")} {\n         let outputIndex = index / i32(workGroupSizeX);\n         let offset = getOffset(outputIndex);\n         var bestValue = ${t};\n         let Length = uniforms.reduceSize;\n         let WorkPerThread = DIV_CEIL(u32(Length), workGroupSizeX);\n         for (var k = i32(localId.x); k < Length && outputIndex < uniforms.size;\n             k = k + i32(workGroupSizeX)) {\n           let candidate = f32(x[offset + k]);\n           ${e}\n         }\n         xBestValues[localId.x] = bestValue;\n         workgroupBarrier();\n\n         var reduceSize = min(u32(Length), workGroupSizeX);\n         for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n             currentSize = reduceSize / 2u) {\n           let interval = DIV_CEIL(reduceSize, 2u);\n           if (localId.x < currentSize) {\n            let candidate = xBestValues[localId.x + interval];\n            ${e}\n            xBestValues[localId.x] = bestValue;\n           }\n           reduceSize = interval;\n           workgroupBarrier();\n         }\n\n         if (localId.x == 0u && outputIndex < uniforms.size) {\n          ${n}\n        }\n       }\n     `}}function as(e,t,s,i,a){const o=e.shape.length,u=[],l=r.parseAxisParam(t,e.shape);let h=l;const d=n.getAxesPermutation(h,o);let c=e;null!=d&&(c=Zr({inputs:{x:e},attrs:{perm:d},backend:a}),h=n.getInnerMostAxes(h.length,o),u.push(c)),n.assertAxesAreInnerMostDims(i,h,o);const[p,f]=n.computeOutAndReduceShapes(c.shape,h);let m,g=p;if(s&&(g=n.expandShapeToKeepDim(p,l)),"max"!==i&&"prod"!==i||!a.shouldExecuteOnCPU([c])){const t=r.sizeFromShape(f),n={windowSize:t,inSize:t,batchSize:r.sizeFromShape(c.shape)/t,outSize:1},s="mean"===i?"float32":A(e.dtype),o=[{type:"int32",data:[t]}],l=new is(n,i),h=a.runWebGPUProgram(l,[c],s,o);u.push(h),m=xn({inputs:{x:h},attrs:{shape:g},backend:a})}else{const t=a.tensorMap.get(c.dataId).values;switch(i){case"max":const n=$r(t,r.sizeFromShape(f),g,e.dtype);m=a.makeTensorInfo(g,e.dtype,n);break;case"prod":const{outVals:s,outShape:o,outDtype:u}=Er(c.shape,c.dtype,t,h);m=a.makeTensorInfo(o,u,s);break;default:throw new Error(`${i} CPU implementation is not yet supported.`)}}return u.forEach((e=>a.disposeData(e.dataId))),m}function os(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reductionIndices:i,keepDims:a}=r;return as(s,i,a,"max",n)}const us={kernelName:T,backendName:"webgpu",kernelFunc:os};function ls(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{keepDims:i,axis:a}=r;return as(s,a,i,"mean",n)}const hs={kernelName:z,backendName:"webgpu",kernelFunc:ls};function ds(e,t,n,s){if(1===t.filterWidth&&1===t.filterHeight&&r.arraysEqual(t.inShape,t.outShape))return vn({inputs:{x:e},backend:s});if(t.filterWidth===t.inWidth&&t.filterHeight===t.inHeight&&1===t.batchSize&&"VALID"===t.padInfo.type){const i=e.shape.length,a=xn({inputs:{x:e},backend:s,attrs:{shape:[e.shape[i-3]*e.shape[i-2],e.shape[i-1]]}});let o;"avg"===n?o=ls({inputs:{x:a},backend:s,attrs:{axis:0,keepDims:!1}}):(r.assert("max"===n,(()=>`Invalid pool type ${n}`)),o=os({inputs:{x:a},backend:s,attrs:{reductionIndices:0,keepDims:!1}}));const u=xn({inputs:{x:o},backend:s,attrs:{shape:t.outShape}});return s.disposeData(a.dataId),s.disposeData(o.dataId),u}let i;const a=[{type:"int32",data:[t.strideHeight,t.strideWidth]}];return 1===t.filterHeight&&1===t.filterWidth?i=new ss(t):("avg"===n?i=new rs(t,"avg"):(r.assert("max"===n,(()=>`Invalid pool type ${n}`)),i=new rs(t,"max")),a.push({type:"int32",data:[t.padInfo.top,t.padInfo.left]},{type:"int32",data:[t.dilationHeight,t.dilationWidth]},{type:"int32",data:[t.inHeight,t.inWidth]},{type:"int32",data:[t.effectiveFilterHeight,t.effectiveFilterWidth]})),s.runWebGPUProgram(i,[e],e.dtype,a)}const cs={kernelName:P,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:r,attrs:s}=e,{x:i}=t,{filterSize:a,strides:o,pad:u,dimRoundingMode:l}=s;return ds(i,n.computePool2DInfo(i.shape,a,o,1,u,l),"avg",r)}};const ps={kernelName:E,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:i}=t,{transposeA:a,transposeB:o}=r;return In({a:s,b:i,transposeA:a,transposeB:o,backend:n})}};class fs{constructor(e,t){this.variableNames=["source"],this.workPerThread=1,this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.rank=t.length,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Bt(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.start=e,this.uniforms=`start : ${vt(e.length)}, `,this.shaderKey="slice"}getUserCode(){const e=vt(this.rank),t=function(e){if(1===e)return"sourceLoc";if(e<=6)return ms.slice(0,e).map((e=>`sourceLoc.${e}`)).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}(this.rank);let n;n=1===this.start.length?this.outputShape.map(((e,t)=>"sourceLoc = uniforms.start + coords;")):this.outputShape.map(((e,t)=>`sourceLoc.${ms[t]} = uniforms.start.${Ct(t)} + coords.${ms[t]};`));return`\n      ${$t("index")} {\n        if (index < uniforms.size) {\n          var sourceLoc : ${e};\n          let coords = getCoordsFromIndex(index);\n          ${n.join("\n")}\n          setOutputAtIndex(index, getSource(${t}));\n        }\n      }\n    `}}const ms=["x","y","z","w","u","v"];function gs(e){const{inputs:t,backend:n,attrs:s}=e,{x:i}=t,{begin:a,size:o}=s,[u,l]=w.parseSliceParams(i,a,o);if(w.assertParamsValid(i,u,l),n.shouldExecuteOnCPU([i])||"string"===i.dtype){const e=n.tensorMap.get(i.dataId),t=Or(e.values,u,l,i.shape,i.dtype);return n.makeTensorInfo(l,i.dtype,t)}if(0===r.sizeFromShape(l))return n.makeTensorInfo(l,i.dtype,[]);const h=new fs(u,l),d=[{type:"int32",data:u}];return n.runWebGPUProgram(h,[i],i.dtype,d)}const bs={kernelName:N,backendName:"webgpu",kernelFunc:gs},xs={kernelName:B,backendName:"webgpu",kernelFunc:e=>{const{inputs:t,backend:s,attrs:i}=e,{x:a}=t,{blockShape:o,crops:u}=i;r.assert(a.shape.length<=4,(()=>"batchToSpaceND for rank > 4 with a WebGPU backend not implemented yet"));const l=o.reduce(((e,t)=>e*t)),h=n.getReshaped(a.shape,o,l),d=n.getPermuted(h.length,o.length),c=n.getReshapedPermuted(a.shape,o,l),p=n.getSliceBeginCoords(u,o.length),f=n.getSliceSize(c,u,o.length),m=[],g=xn({inputs:{x:a},backend:s,attrs:{shape:h}}),b=Zr({inputs:{x:g},backend:s,attrs:{perm:d}}),x=xn({inputs:{x:b},backend:s,attrs:{shape:c}}),w=gs({inputs:{x:x},backend:s,attrs:{begin:p,size:f}});return m.push(g),m.push(b),m.push(x),m.forEach((e=>s.disposeData(e.dataId))),w}},ws=zn({opType:Xt.NOT_EQUAL,dtype:"bool",cpuKernelImpl:Pr}),Is={kernelName:_,backendName:"webgpu",kernelFunc:ws};function ys(e){const{inputs:t,backend:n}=e,{input:r}=t;return vn({inputs:{x:n.tensorMap.get(r.dataId).complexTensorInfos.real},backend:n})}const ks={kernelName:F,backendName:"webgpu",kernelFunc:ys};const Ss={kernelName:O,backendName:"webgpu",kernelFunc:function t(n){const{inputs:s,backend:i,attrs:a}=n,{x:o}=s,{dtype:u}=a;if("complex64"===u){if("complex64"===o.dtype)return vn({inputs:{x:o},backend:i});const n=e.zeros(o.shape),r=t({inputs:{x:o},backend:i,attrs:{dtype:"float32"}}),s=$n({inputs:{real:r,imag:n},backend:i});return n.dispose(),i.disposeData(r.dataId),s}if("complex64"===o.dtype){const e=ys({inputs:{input:o},backend:i}),n=t({inputs:{x:e},backend:i,attrs:{dtype:u}});return i.disposeData(e.dataId),n}if(!r.hasEncodingLoss(o.dtype,u)){const e=vn({inputs:{x:o},backend:i});return{dataId:e.dataId,shape:e.shape,dtype:u}}if(i.shouldExecuteOnCPU([o])){const e=i.tensorMap.get(o.dataId).values,[t,n,r]=cr(e,o.shape,o.dtype,u);return i.makeTensorInfo(t,n,r)}if("int32"===u)return function(e,t){const n=new An(e.shape,Jt.TO_INT),r=t.runWebGPUProgram(n,[e],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}(o,i);if("bool"===u){const e=i.makeTensorInfo([],"bool",r.getTypedArrayFromDType("bool",1)),t=ws({inputs:{a:o,b:e},backend:i});return i.disposeData(e.dataId),t}throw new Error(`Error in Cast: failed to cast ${o.dtype} to ${u}`)}},vs={kernelName:G,backendName:"webgpu",kernelFunc:Tn({opType:Jt.CEIL,cpuKernelImpl:pr})};class Cs{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workPerThread=4,this.workGroupSize=[64,1,1],this.isVec4=!0,this.size=!0,this.outputShape=e,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Bt(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.shaderKey="clipVec4"}getUserCode(){return`\n      ${$t("index")} {\n        if(index < uniforms.size) {\n          let value = getAByOutputIndex(index);\n          var clampedValue : vec4<f32>;\n          for (var i = 0; i < 4; i = i + 1) {\n            if (isnan(value[i])) {\n              clampedValue[i] = value[i];\n            } else {\n              clampedValue[i] = clamp(value[i], uniforms.minVal, uniforms.maxVal);\n            }\n          }\n\n          setOutputAtIndex(index, clampedValue);\n        }\n      }\n    `}}class $s{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Bt(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="clip"}getUserCode(){return`\n      ${$t("index")} {\n        if(index < uniforms.size) {\n          let value = getAByOutputIndex(index);\n          if (isnan(value)) {\n            setOutputAtIndex(index, value);\n            return;\n          }\n          setOutputAtIndex(index, clamp(value, uniforms.minVal, uniforms.maxVal));\n        }\n      }\n    `}}const Rs={kernelName:L,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:i}=t,{clipValueMin:a,clipValueMax:o}=s;let u;const l=[{type:"float32",data:[a]},{type:"float32",data:[o]}];return u=r.sizeFromShape(i.shape)%4==0?new Cs(i.shape):new $s(i.shape),n.runWebGPUProgram(u,[i],i.dtype,l)}};class As{constructor(e){this.uniforms="",this.workPerThread=1,this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=n.computeOutShape(e,1),this.variableNames=e.map(((e,t)=>`T${t}`)),this.dispatchLayout=Gt(this.outputShape),this.dispatch=Bt(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.offsetLength=e.length-1;for(let e=0;e<this.offsetLength;e++)this.uniforms+=`offset${e} : i32,`;this.shaderKey="concat"}getUserCode(){const e=[];if(this.offsetLength>0){e.push("if (yC < uniforms.offset0){ setOutputAtCoords(coords.x, coords.y, getT0(yR, yC)); }");for(let t=1;t<this.offsetLength;t++)e.push(`else if (yC < uniforms.offset${[t]}){ setOutputAtCoords(coords.x, coords.y, getT${t}(yR, yC - uniforms.offset${t-1})); }`);const t=this.offsetLength,n=this.offsetLength-1;e.push(`else { setOutputAtCoords(coords.x, coords.y, getT${t}(yR, yC - uniforms.offset${n})); }`)}else e.push("setOutputAtCoords(coords.x, coords.y, getT0(yR, yC));");return`\n      ${$t("index")} {\n        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {\n          let flatIndex = index * ${this.workPerThread} + i;\n          if(flatIndex < uniforms.size) {\n            let coords = getCoordsFromIndex(flatIndex);\n            let yR = coords.x;\n            let yC = coords.y;\n\n            ${e.join("\n        ")}\n          }\n        }\n      }\n    `}}function Ts(e){const{inputs:t,backend:n}=e,{input:r}=t;return vn({inputs:{x:n.tensorMap.get(r.dataId).complexTensorInfos.imag},backend:n})}const zs={kernelName:D,backendName:"webgpu",kernelFunc:Ts};function Ps(e,t,s){const i=e[0].dtype;if("complex64"===i){const n=e.map((e=>ys({inputs:{input:e},backend:s}))),r=e.map((e=>Ts({inputs:{input:e},backend:s}))),i=Ps(n,t,s),a=Ps(r,t,s),o=$n({inputs:{real:i,imag:a},backend:s});return n.forEach((e=>s.disposeData(e.dataId))),r.forEach((e=>s.disposeData(e.dataId))),s.disposeData(i.dataId),s.disposeData(a.dataId),o}let a=s.shouldExecuteOnCPU(e);if("string"===i&&(a=!0),a){const a=e.map((e=>{const n=r.sizeFromShape(e.shape.slice(t));return xn({inputs:{x:e},backend:s,attrs:{shape:[-1,n]}})})),o=a.map((e=>({vals:s.readSync(e.dataId),shape:e.shape}))),u=n.computeOutShape(a.map((e=>e.shape)),1),l=1===a[0].shape[0],h=fr(o,u,i,l),d=n.computeOutShape(e.map((e=>e.shape)),t),c=s.makeTensorInfo(d,i,h);return a.forEach((e=>s.disposeData(e.dataId))),c}const o=s.device.limits.maxStorageBuffersPerShaderStage-1;if(e.length>o){const n=[];for(let r=0;r<e.length;r+=o){const i=e.slice(r,r+o);n.push(Ps(i,t,s))}const r=Ps(n,t,s);for(const e of n)s.disposeData(e.dataId);return r}const{tensors2D:u,outShape:l}=function(e,t,s){const i=n.computeOutShape(e.map((e=>e.shape)),t);return{tensors2D:e.map((e=>xn({inputs:{x:e},backend:s,attrs:{shape:[r.sizeFromShape(e.shape.slice(0,t)),r.sizeFromShape(e.shape.slice(t))]}}))),outShape:i}}(e,t,s),h=u.map((e=>e.shape)),d=new As(h),c=[],p=new Array(h.length-1);if(p.length>0){p[0]=h[0][1],c.push({type:"int32",data:[p[0]]});for(let e=1;e<p.length;e++)p[e]=p[e-1]+h[e][1],c.push({type:"int32",data:[p[e]]})}const f=s.runWebGPUProgram(d,u,u[0].dtype,c);u.forEach((e=>s.disposeData(e.dataId)));const m=xn({inputs:{x:f},backend:s,attrs:{shape:l}});return s.disposeData(f.dataId),m}function Es(e){const{inputs:t,backend:s,attrs:i}=e,{axis:a}=i,o=r.parseAxisParam(a,t[0].shape)[0],u=t.map((e=>e.shape));n.assertParamsConsistent(u,o);const l=n.computeOutShape(t.map((e=>e.shape)),o);if(0===r.sizeFromShape(l))return s.makeTensorInfo(l,t[0].dtype,[]);const h=t.filter((e=>r.sizeFromShape(e.shape)>0));return 1===h.length?vn({inputs:{x:h[0]},backend:s}):Ps(h,o,s)}const Ns={kernelName:U,backendName:"webgpu",kernelFunc:Es};class Bs{constructor(e,t,n,r,s=!1,i=null,a=!1,o=!1){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>, dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.outShape,this.isChannelsLast="channelsLast"===e.dataFormat,this.isVec4=((e.inChannels%4==0||e.inChannels%3==0)&&this.isChannelsLast||e.outWidth%4==0&&!this.isChannelsLast)&&e.outChannels%4==0,this.dispatchLayout=this.isChannelsLast?{x:[3],y:[1,2],z:[0]}:{x:[2,3],y:[1],z:[0]},this.workGroupSize=Ft(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=Ot(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=Bt(this.dispatchLayout,this.outputShape,this.workGroupSize,this.elementsPerThread),this.isVec4?(this.isChannelsLast&&e.inChannels%4!=0?(this.innerElementSize=3,this.variableTypes=["f32","vec4<f32>"]):(this.innerElementSize=4,this.variableTypes=["vec4<f32>","vec4<f32>"]),s&&(this.variableNames.push("bias"),this.variableTypes.push("vec4<f32>")),a&&(this.variableNames.push("preluActivationWeights"),this.variableTypes.push("vec4<f32>"))):(this.innerElementSize=this.elementsPerThread[0],s&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights")),this.sequentialAccessByThreads=o,this.addBias=s,this.activation=i,this.hasPreluActivationWeights=a,this.tileAOuter=this.workGroupSize[1]*this.elementsPerThread[1],this.tileBOuter=this.workGroupSize[0]*this.elementsPerThread[0],this.tileInner=Math.max(this.workGroupSize[0]*this.innerElementSize,this.workGroupSize[1]),this.fitAOuter=t%this.tileAOuter==0,this.fitBOuter=n%this.tileBOuter==0,this.fitInner=r%this.tileInner==0,this.shaderKey=`conv2DMM_${this.elementsPerThread}_${this.activation}}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.innerElementSize}_${this.isChannelsLast}_${this.sequentialAccessByThreads}`}getUserCode(){const e=this.isVec4?on(this.elementsPerThread,this.workGroupSize,!this.isChannelsLast,this.tileInner):ln(this.elementsPerThread,this.workGroupSize,!this.isChannelsLast,this.tileInner,!1,null,this.sequentialAccessByThreads),t=this.isVec4?[this.innerElementSize,4,4]:[1,1,1];return`\n    ${function(e,t,n,r,s=!1,i=null,a=!1,o=4,u=4,l=4){const h=e?"\n      let coord = vec4<i32>(batch, xRow, xCol, xCh);\n      ":"\n      let coord = vec4<i32>(batch, xCh, xRow, xCol);\n      ",d=e?"\n      let coords = vec4<i32>(\n        batch,\n        row / outWidth,\n        row % outWidth,\n        col);\n      ":"\n      let coords = vec4<i32>(\n        batch,\n        row,\n        col / outWidth,\n        col % outWidth);\n      ",c=e?"uniforms.xShape[1]":"uniforms.xShape[2]",p=e?"uniforms.xShape[2]":"uniforms.xShape[3]",f=e?"row":"col",m=e?"col":"row",g=`\n      let inChannels = uniforms.wShape[2];\n      let outWidth = ${e?"uniforms.outShape[2]":"uniforms.outShape[3]"};\n      let outRow = ${f} / outWidth;\n      let outCol = ${f} % outWidth;\n\n      let WRow = ${m} / (uniforms.filterDims[1] * inChannels);\n      let WCol = ${m} / inChannels % uniforms.filterDims[1];\n      let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];\n      let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];\n      let xCh = ${m} % inChannels;\n      var resData = ${tn(o)}(0.0);\n      // The bounds checking is always needed since we use it to pad zero for\n      // the 'same' padding type.\n      if (xRow >= 0 && xRow < ${c} && xCol >= 0 && xCol < ${p}) {\n        ${h}\n        let xIndex = getIndexFromCoords4D(coord, uniforms.xShape);\n        ${(e=>{switch(e){case 1:return"resData = x[xIndex];";case 3:return"resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${e} is not supported.`)}})(o)}\n      }\n      return resData;`,b=e?t&&r?`\n      let col = colIn * ${o};\n      ${g}`:`\n      let col = colIn * ${o};\n      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {\n        ${g}\n      }\n      return ${tn(o)}(0.0);`:r&&n?`\n      let col = colIn * ${o};\n      ${g}`:`\n      let col = colIn * ${o};\n      if (row < uniforms.dimInner && col < uniforms.dimBOuter) {\n        ${g}\n      }\n      return ${tn(o)}(0.0);`,x=`${(e=>{switch(e){case 1:return"return W[row * uniforms.wShape[3] + colIn];";case 4:return"return W[row * uniforms.wShape[3] / 4 + colIn];";default:throw new Error(`innerElementSize ${e} is not supported.`)}})(u)}`,w=tn(l),I=tn(e?o:u),y=tn(e?u:o);return`\n      ${nn(i,a,4===l,4)}\n      fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${I} {\n        ${e?b:x}\n      }\n\n      fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${y} {\n        ${e?x:b}\n      }\n\n      fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${w}) {\n        let col = colIn * ${l};\n        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)\n        {\n        var value = valueIn;\n        let outWidth = ${e?"uniforms.outShape[2]":"uniforms.outShape[3]"};\n        ${d}\n        ${rn(s,i)}\n        setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n        }\n      }`}(this.isChannelsLast,this.fitAOuter,this.fitBOuter,this.fitInner,this.addBias,this.activation,this.hasPreluActivationWeights,t[0],t[1],t[2])}\n    ${e}\n  `}}class _s{constructor(e,t=!1,n=null,r=!1){this.variableNames=["x","W"],this.uniforms="filterDims: vec2<i32>, pad: vec2<i32>, stride: vec2<i32>, dilation: vec2<i32>,",this.workGroupSize=[4,4,8],this.outputShape=e.outShape,this.isChannelsLast="channelsLast"===e.dataFormat,this.dispatchLayout=this.isChannelsLast?{x:[2],y:[1],z:[0,3]}:{x:[3],y:[2],z:[0,1]},this.dispatch=Bt(this.dispatchLayout,this.outputShape,this.workGroupSize),this.addBias=t,this.activation=n,this.hasPreluActivationWeights=r,t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`conv2dnaive_${this.activation}_${this.isChannelsLast}`}getUserCode(){return`\n       ${nn(this.activation,this.hasPreluActivationWeights,!1,4)}\n       fn readInp(batch : i32, row : i32, col : i32, chan : i32) -> f32{\n         let coords = vec4<i32>(batch, row, col, chan);\n         if (coordsInBounds4D(coords, uniforms.xShape)) {\n           return  getX(batch, row, col, chan);\n         } else {\n          return 0.0;\n         }\n       }\n       fn readFilt(row : i32, col : i32, xChannel : i32, outChannel : i32) -> f32{\n         let coords = vec4<i32>(row, col, xChannel, outChannel);\n         if(coordsInBounds4D(coords, uniforms.wShape)) {\n           return getW(row, col, xChannel, outChannel);\n          } else {\n            return 0.0;\n          }\n       }\n       fn writeResult(batch : i32, row : i32, col : i32, chan : i32, valueIn : f32) {\n         let coords = ${this.isChannelsLast?"vec4<i32>(batch, row, col, chan);":"vec4<i32>(batch, chan, row, col);"}\n         if (coordsInBounds4D(coords, uniforms.outShape)) {\n           var value = valueIn;\n           ${rn(this.addBias,this.activation)}\n           setOutputAtCoords(coords.x, coords.y, coords.z, coords.w, value);\n         }\n       }\n       ${$t("index")} {\n         let coords = getOutputCoords();\n         let batch = coords[0];\n         let outChannel = ${this.isChannelsLast?"coords[3];":"coords[1];"}\n         let outRow = ${this.isChannelsLast?"coords[1];":"coords[2];"}\n         let outCol = ${this.isChannelsLast?"coords[2];":"coords[3];"}\n         var acc : f32 = 0.0;\n         for (var row = 0; row < uniforms.filterDims[0]; row = row + 1) {\n           for (var col = 0; col < uniforms.filterDims[1]; col = col + 1) {\n             let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * row - uniforms.pad[0];\n             let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * col - uniforms.pad[1];\n             for (var xChannel = 0; xChannel < ${this.isChannelsLast?"uniforms.xShape[3];":"uniforms.xShape[1];"} xChannel = xChannel + 1) {\n               ${this.isChannelsLast?"let v = readInp(batch, xRow, xCol, xChannel);":"let v = readInp(batch, xChannel, xRow, xCol);"}\n               let f = readFilt(row, col, xChannel, outChannel);\n               acc = acc + v * f;\n             }\n           }\n         }\n         writeResult(batch, outRow, outCol, outChannel, acc);\n       }\n     `}}function Fs(e,t){const n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&1===n&&e[0]>1?[e[0],1]:null}function Os({x:e,filter:n,convInfo:r,backend:s,bias:i=null,preluActivationWeights:a=null,leakyreluAlpha:o=0,activation:u=null}){const l=null!=i,h=null!=a,d="channelsLast"===r.dataFormat,c=d&&r.filterHeight===r.inHeight&&r.filterWidth===r.inWidth&&"VALID"===r.padInfo.type,p=t().getBool("WEBGPU_USE_NAIVE_CONV2D_DEBUG");if(!p&&(c||1===r.filterHeight&&1===r.filterWidth&&1===r.dilationHeight&&1===r.dilationWidth&&1===r.strideHeight&&1===r.strideWidth&&("SAME"===r.padInfo.type||"VALID"===r.padInfo.type)))return function({x:e,filter:t,convInfo:n,backend:r,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:o=null}){const u="channelsLast"===n.dataFormat,l=!u,h=[];let d,c;if(u&&n.filterHeight===n.inHeight&&n.filterWidth===n.inWidth&&"VALID"===n.padInfo.type){const s=n.inHeight*n.inWidth*n.inChannels;d=xn({inputs:{x:e},backend:r,attrs:{shape:[1,n.batchSize,s]}}),c=xn({inputs:{x:t},backend:r,attrs:{shape:[1,s,n.outChannels]}})}else d=xn({inputs:{x:e},backend:r,attrs:{shape:u?[n.batchSize,n.inHeight*n.inWidth,n.inChannels]:[n.batchSize,n.inChannels,n.inHeight*n.inWidth]}}),c=xn({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});if(h.push(d),h.push(c),null!=i){const e=Fs(i.shape,u);null!=e&&(i=xn({inputs:{x:i},backend:r,attrs:{shape:e}}),h.push(i))}if(null!=s){const e=Fs(s.shape,u);null!=e&&(s=xn({inputs:{x:s},backend:r,attrs:{shape:e}}),h.push(s))}const p=In({a:u?d:c,b:u?c:d,transposeA:l,transposeB:!1,backend:r,bias:s,activation:o,preluActivationWeights:i,leakyreluAlpha:a}),f=xn({inputs:{x:p},backend:r,attrs:{shape:n.outShape}});h.push(p);for(const e of h)r.disposeData(e.dataId);return f}({x:e,filter:n,convInfo:r,backend:s,bias:i,activation:u,preluActivationWeights:a,leakyreluAlpha:o});let f;const m=[r.padInfo.top,r.padInfo.left],g=[{type:"int32",data:[r.filterHeight,r.filterWidth]},{type:"int32",data:[...m]},{type:"int32",data:[r.strideHeight,r.strideWidth]},{type:"int32",data:[r.dilationHeight,r.dilationWidth]}];if(p)f=new _s(r,l,u,h);else{const e=d?r.outHeight*r.outWidth:r.outChannels,t=d?r.outChannels:r.outHeight*r.outWidth,n=r.filterHeight*r.filterWidth*r.inChannels;g.push({type:"int32",data:[e]},{type:"int32",data:[t]},{type:"int32",data:[n]});const i=s.adapterInfo.isIntel();f=new Bs(r,e,t,n,l,u,h,i)}const b=[],x=[e,n];l&&(d||1!==i.shape.length||(i=xn({inputs:{x:i},backend:s,attrs:{shape:[i.shape[0],1,1]}}),b.push(i)),x.push(i)),h&&(d||1!==a.shape.length||(a=xn({inputs:{x:a},backend:s,attrs:{shape:[a.shape[0],1,1]}}),b.push(a)),x.push(a)),"leakyrelu"===u&&(g.push({type:"float32",data:[o]}),f.uniforms+=" alpha : f32,");const w=s.runWebGPUProgram(f,x,e.dtype,g);for(const e of b)s.disposeData(e.dataId);return w}const Gs={kernelName:W,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,attrs:r,backend:s}=e,{x:i,filter:a}=t,{strides:o,pad:u,dataFormat:l,dilations:h,dimRoundingMode:d}=r,c=n.convertConv2DDataFormat(l);return Os({x:i,filter:a,convInfo:n.computeConv2DInfo(i.shape,a.shape,o,h,u,d,!1,c),backend:s})}};class Ls{constructor(e){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, stride : vec2<i32>, outBackprop : vec4<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.inShape,r.assert("channelsLast"===e.dataFormat,(()=>"TODO: NCHW is unimplemented")),this.isVec4=e.inChannels%4==0&&e.outChannels%4==0,this.dispatchLayout={x:[3],y:[1,2],z:[0]},this.workGroupSize=Ft(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=Ot(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=Bt(this.dispatchLayout,this.outputShape,this.workGroupSize,this.elementsPerThread),this.isVec4&&(this.variableTypes=["vec4<f32>","f32"]),this.shaderKey=`conv2DDerInputMM_${this.isVec4}_${this.elementsPerThread}`}getUserCode(){const e=this.isVec4?on(this.elementsPerThread,this.workGroupSize):ln(this.elementsPerThread,this.workGroupSize);return`\n    ${function(e=4){const t=`if (row < uniforms.dimAOuter && col < uniforms.dimInner) {\n        \n      let outRow = row / uniforms.outShape[2];\n      let outCol = row % uniforms.outShape[2];\n\n      let WRow = col / (uniforms.filterDims[1] * uniforms.outBackprop[3]);\n      let WCol = col / uniforms.outBackprop[3] % uniforms.filterDims[1];\n      let xR = f32(outRow - uniforms.pads[0] + WRow) / f32(uniforms.stride[0]);\n      let xC = f32(outCol - uniforms.pads[1] + WCol) / f32(uniforms.stride[1]);\n      if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {\n        return ${tn(e)}(0.0);\n      }\n      if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {\n        return ${tn(e)}(0.0);\n      }\n      let coord = vec4<i32>(\n          batch,\n          i32(xR),\n          i32(xC),\n          col % uniforms.outBackprop[3]);\n      return x[getIndexFromCoords4D(coord, uniforms.xShape)/${e}];\n      }\n      return ${tn(e)}(0.0);`;return`\n  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${tn(e)} {\n    let col = colIn * ${e};\n    ${t}\n  }\n\n  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${tn(e)} {\n    let col = colIn * ${e};\n    let coordX = uniforms.filterDims.x - 1 -\n        row / (uniforms.filterDims[1] * uniforms.outBackprop[3]);\n    let coordY = uniforms.filterDims.y - 1 -\n        (row / uniforms.outBackprop[3]) % uniforms.filterDims[1];\n    if (row < uniforms.dimInner && col < uniforms.dimBOuter &&\n        coordX >= 0 && coordY >= 0) {\n      let rowInner = row % uniforms.outBackprop[3];\n      let coord = vec4<i32>(coordX, coordY, col, rowInner);\n      ${(e=>{switch(e){case 1:return"return W[getIndexFromCoords4D(coord, uniforms.wShape)];";case 4:return"\n            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);\n            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);\n            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);\n            let v0 = W[getIndexFromCoords4D(coord, uniforms.wShape)];\n            let v1 = W[getIndexFromCoords4D(coord1, uniforms.wShape)];\n            let v2 = W[getIndexFromCoords4D(coord2, uniforms.wShape)];\n            let v3 = W[getIndexFromCoords4D(coord3, uniforms.wShape)];\n            return vec4<f32>(v0, v1, v2, v3);\n            ";default:throw new Error(`innerElementSize ${e} is not supported.`)}})(e)}\n    }\n    return ${tn(e)}(0.0);\n  }\n\n  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${tn(e)}) {\n    let col = colIn * ${e};\n    if (row < uniforms.dimAOuter && (col + ${e-1}) < uniforms.dimBOuter) {\n      var value = valueInput;\n      let outCoord = vec4<i32>(\n          batch,\n          row / uniforms.outShape[2],\n          row % uniforms.outShape[2],\n          col);\n      result[getIndexFromCoords4D(outCoord, uniforms.outShape)/${e}] = value;\n    }\n  }`}(this.isVec4?4:1)}\n    ${e}\n    `}}class Ds{constructor(e){this.variableNames=["dy","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, stride : vec2<i32>, outBackprop : vec4<i32>,",this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Bt(this.dispatchLayout,this.outputShape,this.workGroupSize),this.isChannelsLast="channelsLast"===e.dataFormat,this.shaderKey=`conv2DDerInput_${this.isChannelsLast}`}getUserCode(){const e=this.isChannelsLast?1:2,t=this.isChannelsLast?2:3,n=this.isChannelsLast?3:1;return`\n    ${$t("index")} {\n      if(index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords[0];\n        let d1 = coords[${n}];\n\n        let dyCorner = vec2<i32>(coords[${e}], coords[${t}]) - uniforms.pads;\n        let dyRCorner = dyCorner.x;\n        let dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {\n          let dyR = (f32(dyRCorner) + f32(wR)) / f32(uniforms.stride.x);\n          let wRPerm = uniforms.filterDims.x - 1 - wR;\n          if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) || fract(dyR) > 0.0 ||\n              wRPerm < 0) {\n            continue;\n          }\n          let idyR = i32(dyR);\n\n          for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {\n            let dyC = (f32(dyCCorner) + f32(wC)) / f32(uniforms.stride.y);\n            let wCPerm = uniforms.filterDims.y - 1 - wC;\n            if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||\n                fract(dyC) > 0.0 || wCPerm < 0) {\n              continue;\n            }\n            let idyC = i32(dyC);\n\n            for (var d2 = 0; d2 < uniforms.outBackprop[3]; d2 = d2 + 1) {\n              if (${this.isChannelsLast}) {\n                let xValue = getDy(batch, idyR, idyC, d2);\n                let wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd = dotProd + xValue * wValue;\n              } else {\n                let xValue = getDy(batch, d2, idyR, idyC);\n                let wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd = dotProd + xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n  `}}const Us={kernelName:M,backendName:"webgpu",kernelFunc:function(e){const{inputs:r,backend:s,attrs:i}=e,{dy:a,filter:o}=r,{inputShape:u,strides:l,pad:h,dataFormat:d,dimRoundingMode:c}=i,p=n.convertConv2DDataFormat(d),f=n.computeConv2DInfo(u,o.shape,l,1,h,c,!1,p),m=[{type:"int32",data:[f.filterHeight,f.filterWidth]},{type:"int32",data:[f.filterHeight-1-f.padInfo.top,f.filterWidth-1-f.padInfo.left]},{type:"int32",data:[f.strideHeight,f.strideWidth]},{type:"int32",data:[f.batchSize,f.outHeight,f.outWidth,f.outChannels]}];let g;if(t().getBool("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE")||f.filterHeight<=2&&f.filterWidth<=2&&f.outChannels<=16&&1===f.inChannels)g=new Ds(f);else{g=new Ls(f);const e=f.inHeight*f.inWidth,t=f.inChannels,n=f.filterHeight*f.filterWidth*f.outChannels;m.push({type:"uint32",data:[e]},{type:"uint32",data:[t]},{type:"uint32",data:[n]})}return s.runWebGPUProgram(g,[a,o],"float32",m)}},Ws={kernelName:V,backendName:"webgpu",kernelFunc:Tn({opType:Jt.COS})},Ms={kernelName:H,backendName:"webgpu",kernelFunc:Tn({opType:Jt.COSH})};class Vs{constructor(e,t,n,r){this.variableNames=["Image","Boxes","BoxInd"],this.uniforms="extrapolationValue : f32,",this.workGroupSize=[64,1,1],this.size=!0;const[s]=t;this.outputShape=[s,n[0],n[1],e],this.dispatchLayout=Gt(this.outputShape),this.dispatch=Bt(this.dispatchLayout,this.outputShape,this.workGroupSize),this.methodId="bilinear"===r?1:0,this.cropHeightBiggerThan1=this.outputShape[1]>1,this.cropWidthBiggerThan1=this.outputShape[2]>1,this.shaderKey=`cropAndResize_${this.methodId}_${this.cropHeightBiggerThan1}_${this.cropWidthBiggerThan1}`}getUserCode(){const[e,t]=["f32(uniforms.imageShape[1] - 1)","f32(uniforms.imageShape[2] - 1)"],[n,r,s]=this.cropHeightBiggerThan1?[`(${e} / f32(uniforms.outShape[1] - 1))`,"(y2-y1) * height_ratio",`y1*${e} + f32(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${e}`],[i,a,o]=this.cropWidthBiggerThan1?[`(${t} / f32(uniforms.outShape[2] - 1))`,"(x2-x1) * width_ratio",`x1*${t} + f32(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${t}`];return`\n    ${$t("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let height_ratio = f32(${n});\n        let width_ratio = f32(${i});\n        let b = coords[0];\n        let y = coords[1];\n        let x = coords[2];\n        let d = coords[3];\n        // get box vals\n        let y1 = getBoxes(b, 0);\n        let x1 = getBoxes(b, 1);\n        let y2 = getBoxes(b, 2);\n        let x2 = getBoxes(b, 3);\n        // get image in batch index\n        let bInd = i32(round(getBoxInd(b)));\n        if(bInd < 0 || bInd >= uniforms.outShape[0]) {\n          return;\n        }\n        let height_scale = ${r};\n        let width_scale = ${a};\n        let in_y = ${s};\n        if( in_y < 0.0 || in_y > ${e} ) {\n          setOutputAtIndex(index, uniforms.extrapolationValue);\n          return;\n        }\n        let in_x = ${o};\n        if( in_x < 0.0 || in_x > ${t} ) {\n          setOutputAtIndex(index, uniforms.extrapolationValue);\n          return;\n        }\n        let sourceFracIndexCR = vec2<f32>(in_x,in_y);\n        if(${this.methodId} == 1) {\n          // Compute the four integer indices.\n          let sourceFloorCR = vec2<i32>(sourceFracIndexCR);\n          let sourceCeilCR = vec2<i32>(ceil(sourceFracIndexCR));\n          let topLeft = getImage(bInd, sourceFloorCR.y, sourceFloorCR.x, d);\n          let bottomLeft = getImage(bInd, sourceCeilCR.y, sourceFloorCR.x, d);\n          let topRight = getImage(bInd, sourceFloorCR.y, sourceCeilCR.x, d);\n          let bottomRight = getImage(bInd, sourceCeilCR.y, sourceCeilCR.x, d);\n          let fracCR = sourceFracIndexCR - vec2<f32>(sourceFloorCR);\n          let top = topLeft + (topRight - topLeft) * fracCR.x;\n          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          let newValue = top + (bottom - top) * fracCR.y;\n          setOutputAtIndex(index, newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          let sourceNearestCR = vec2<i32>(floor(\n            sourceFracIndexCR + vec2<f32>(0.5,0.5)));\n          let newValue = getImage(\n            bInd, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutputAtIndex(index, newValue);\n        }\n      }\n    }\n    `}}const Hs={kernelName:X,backendName:"webgpu",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{image:s,boxes:i,boxInd:a}=t,{cropSize:o,method:u,extrapolationValue:l}=r,h=new Vs(s.shape[3],i.shape,o,u),d=[{type:"float32",data:[l]}];return n.runWebGPUProgram(h,[s,i,a],"float32",d)}};var Xs;!function(e){e.Prod="*",e.Sum="+"}(Xs||(Xs={}));class qs{constructor(e,t,n,r){this.variableNames=["x"],this.uniforms="index : f32,",this.size=!0;this.workGroupSize=[128,1,1],this.outputShape=t,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Bt(this.dispatchLayout,this.outputShape,this.workGroupSize),this.exclusive=n,this.reverse=r,this.op=e,this.shaderKey=`cum_${this.op}_${this.exclusive}_${this.reverse}`}getUserCode(){const e=this.outputShape.length,t=this.op===Xs.Prod?"1.0":"0.0",n=this.exclusive?t:`getX(${Ks(e,"coords",this.op)})`,r=this.outputShape[this.outputShape.length-1];let s="",i="";return this.exclusive?(s=this.reverse?"end != "+(r-1):"end != 0",i=this.reverse?"end + 1":"end - 1"):(s=this.reverse?`end + pow2 < ${r}`:"end >= pow2",i=this.reverse?"end + pow2":"end - pow2"),`\n      ${$t("index")} {\n       if (index < uniforms.size) {\n         var coords = getCoordsFromIndex(index);\n\n         let end = ${Ys(e,"coords",this.op)};\n         var val = ${n};\n         let pow2 = i32(pow(2.0, uniforms.index));\n         if (${s}) {\n           let idx = ${i};\n           ${Ys(e,"coords",this.op)} = idx;\n           val ${this.op}= getX(${Ks(e,"coords",this.op)});\n         }\n         setOutputAtIndex(index, val);\n       }\n      }\n    `}}function Ks(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.x, ${t}.y`;if(3===e)return`${t}.x, ${t}.y, ${t}.z`;if(4===e)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function Ys(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.y`;if(3===e)return`${t}.z`;if(4===e)return`${t}.w`;throw Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function js(e,t,r,s,i,a){const o=t.shape.length,u=n.getAxesPermutation([s],o);let l=t;null!=u&&(l=Zr({inputs:{x:t},backend:r,attrs:{perm:u}}));const h=n.getInnerMostAxes(1,o)[0];if(h!==o-1)throw new Error(`WebGPU cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${s}`);const d=l.shape[h];let c=vn({inputs:{x:l},backend:r});for(let t=0;t<=Math.ceil(Math.log2(d))-1;t++){const n=new qs(e,l.shape,!1,a),s=c,i=[{type:"float32",data:[t]}];c=r.runWebGPUProgram(n,[c],c.dtype,i),r.disposeData(s.dataId)}if(i){const t=new qs(e,l.shape,i,a),n=c,s=[{type:"float32",data:[0]}];c=r.runWebGPUProgram(t,[c],c.dtype,s),r.disposeData(n.dataId)}if(null!=u){const e=Zr({inputs:{x:c},backend:r,attrs:{perm:n.getUndoAxesPermutation(u)}});return r.disposeData(c.dataId),r.disposeData(l.dataId),e}return c}const Qs={kernelName:q,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:i,exclusive:a,reverse:o}=r;return js(Xs.Prod,s,n,i,a,o)}};const Zs={kernelName:K,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:i,exclusive:a,reverse:o}=r;return js(Xs.Sum,s,n,i,a,o)}};class Js{constructor(e,t){this.variableNames=["x"],this.workGroupSize=[64,1,1],this.size=!0,this.uniforms="blockSize : i32,",this.outputShape=e,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Bt(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey=`depthToSpace_${t}`,this.dataFormat=t}getUserCode(){return`\n      ${$t("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let b = coords[0];\n          let h = ${this.getHeightCoordString()};\n          let w = ${this.getWidthCoordString()};\n          let d = ${this.getDepthCoordString()};\n\n          let in_h = h / uniforms.blockSize;\n          let offset_h = h % uniforms.blockSize;\n          let in_w = w / uniforms.blockSize;\n          let offset_w = w % uniforms.blockSize;\n          let offset_d = (offset_h * uniforms.blockSize + offset_w) *\n            ${this.getOutputDepthSize()};\n          let in_d = d + offset_d;\n\n          let rlt = ${this.getInputSamplingString()};\n          setOutputAtIndex(index, rlt);\n        }\n      }`}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?"uniforms.outShape[3]":"uniforms.outShape[1]"}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const ei={kernelName:Y,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockSize:i,dataFormat:a}=r,o=s.shape[0],u=("NHWC"===a?s.shape[1]:s.shape[2])*i,l=("NHWC"===a?s.shape[2]:s.shape[3])*i,h=("NHWC"===a?s.shape[3]:s.shape[1])/(i*i),d=[{type:"int32",data:[i]}],c=new Js("NHWC"===a?[o,u,l,h]:[o,h,u,l],a);return n.runWebGPUProgram(c,[s],s.dtype,d)}};class ti{constructor(e,t,n,r=!1,s=null,i=!1){this.variableNames=["x","W"],this.uniforms="pad : vec2<i32>, inDims : vec2<i32>,",this.workGroupSize=[16,16,1],this.outputShape=e,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=Bt(this.dispatchLayout,this.outputShape,this.workGroupSize),r&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),this.addBias=r,this.activation=s,this.hasPreluActivation=i,this.filterHeight=t,this.filterWidth=n,this.shaderKey=`depthwiseNCHW_${this.activation}_${this.filterHeight}_${this.filterWidth}`}getUserCode(){const e=this.filterWidth*this.filterHeight,t=this.workGroupSize[0]*this.workGroupSize[1]*this.workGroupSize[2],n=this.workGroupSize[1]+this.filterHeight-1,r=this.workGroupSize[0]+this.filterWidth-1;return`\n      ${nn(this.activation,this.hasPreluActivation,!1,4)}\n\n      var<workgroup> mm_Asub : array<array<f32, ${r}>, ${n}>;\n      var<workgroup> mm_Bsub : array<array<f32, ${this.filterWidth}>, ${this.filterHeight}>;\n      fn readX(batch : i32, channel : i32, row : i32, col : i32) -> f32 {\n        var value = 0.0;\n        if (row >=0 && row < uniforms.inDims[0] && col >=0 && col < uniforms.inDims[1])\n        {\n          value = getX(batch, channel, row, col);\n        }\n        return value;\n      }\n\n      \n  @compute @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n\n      fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,\n                @builtin(global_invocation_id) GlobalId : vec3<u32>,\n                @builtin(local_invocation_index) LocalIndex: u32,\n                @builtin(num_workgroups) NumWorkgroups: vec3<u32>) {\n        localId = LocalId;\n        globalId = GlobalId;\n        let localIndex = i32(LocalIndex);\n        numWorkgroups = NumWorkgroups;\n        let coords = getOutputCoords();\n        let batch = coords[0];\n        let xRCCorner = vec2<i32>(coords.zw) - uniforms.pad;\n        let channelMul = uniforms.wShape[3];\n        let d1 = coords[1] / channelMul;\n        let q = coords[1] % channelMul;\n\n        let inputRowStart = xRCCorner.x;\n        let inputColStart = xRCCorner.y;\n\n        let localRow = i32(localId.y);\n        let localCol = i32(localId.x);\n\n        // Load one tile of X into local memory.\n        for (var inputRow = localRow; inputRow < ${n}; inputRow = inputRow + ${this.workGroupSize[1]}) {\n          for (var inputCol = localCol; inputCol < ${r}; inputCol = inputCol + ${this.workGroupSize[0]}) {\n            let rowOffset = inputRow - localRow;\n            let colOffset = inputCol - localCol;\n            mm_Asub[inputRow][inputCol] = readX(batch, d1, inputRowStart + rowOffset, inputColStart + colOffset);\n          }\n        }\n\n        // Load one tile of W into local memory.\n        var wIndex = localIndex;\n        ${e<t?`if (wIndex < ${e})`:`for(; wIndex < ${e}; wIndex = wIndex + ${t})`}\n\n        {\n          let wRow = wIndex / ${this.filterWidth};\n          let wCol = wIndex % ${this.filterWidth};\n          mm_Bsub[wRow][wCol] = getW(wRow, wCol, d1, q);\n        }\n\n        workgroupBarrier();\n\n        var value = 0.0;\n        for (var wR = 0; wR < ${this.filterHeight}; wR = wR + 1) {\n          for (var wC = 0; wC < ${this.filterWidth}; wC = wC + 1) {\n            let xVal = mm_Asub[localRow + wR][localCol + wC];\n            let wVal = mm_Bsub[wR][wC];\n            value = fma(xVal, wVal, value);\n          }\n        }\n        ${rn(this.addBias,this.activation)}\n        if (coordsInBounds4D(coords, uniforms.outShape)) {\n          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n        }\n      }\n    `}}class ni{constructor(e,t=!1,n=null,s=!1){this.variableNames=["x","W"],this.uniforms="pad : vec2<i32>, inDims : vec2<i32>,",this.workGroupSize=[4,4,4],this.workPerThread=4,this.isVec4=!0,this.outputShape=e.outShape,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=Bt(this.dispatchLayout,this.outputShape,this.workGroupSize,[4,this.workPerThread,1]),r.assert("channelsLast"===e.dataFormat,(()=>"TODO: NCHW is unimplemented")),t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=n,this.hasPreluActivation=s,this.shaderKey=`depthwiseVec4_${n}_${this.convInfo.filterHeight}_${this.convInfo.filterWidth}_${this.convInfo.strideHeight}_${this.convInfo.strideWidth}_${this.workPerThread}`}getUserCode(){const e=(this.workPerThread-1)*this.convInfo.strideWidth+this.convInfo.filterWidth;return`\n      ${nn(this.activation,this.hasPreluActivation,!0,4)}\n      fn readX(batch : i32, row : i32, col : i32, channel : i32) -> vec4<f32> {\n        var value = vec4<f32>(0.0);\n        if (col >=0 && col < uniforms.inDims[1]) {\n          value = getX(batch, row, col, channel);\n        }\n        return value;\n      }\n\n      const strideHeight = ${this.convInfo.strideHeight};\n      const strideWidth = ${this.convInfo.strideWidth};\n      \n  @compute @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n\n      fn _start(@builtin(global_invocation_id) globalId: vec3<u32>) {\n        let batch = i32(globalId.z) / uniforms.outShape[1];\n        let r = i32(globalId.z) % uniforms.outShape[1];\n        let c = i32(globalId.y) * ${this.workPerThread};\n        let d1 = i32(globalId.x) * 4;\n        let xRCCorner = vec2<i32>(r, c) * vec2<i32>(strideHeight, strideWidth) - uniforms.pad;\n\n        let xRCorner = xRCCorner.x;\n        let xCCorner = xRCCorner.y;\n        var xVals : array<vec4<f32>, ${e}>;\n        var dotProd : array<vec4<f32>, ${this.workPerThread}>;\n        for (var i = 0; i < ${this.workPerThread}; i++) {\n          dotProd[i] = vec4<f32>(0.0);\n        }\n\n        // Use constant instead of uniform can give better performance.\n        for (var wR = 0; wR < ${this.convInfo.filterHeight}; wR = wR + 1) {\n          let xR = xRCorner + wR;\n          if (xR >=0 && xR < uniforms.inDims[0]) {\n            for (var i = 0; i < ${e}; i++) {\n              xVals[i] = readX(batch, xR, xCCorner + i, d1);\n            }\n            for (var wC = 0; wC < ${this.convInfo.filterWidth}; wC = wC + 1) {\n              let wValue = getW(wR, wC, d1, 0);\n              for (var i = 0; i < ${this.workPerThread}; i++) {\n                dotProd[i] = fma(xVals[i * strideWidth + wC], wValue, dotProd[i]);\n              }\n            }\n          }\n        }\n\n        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {\n          let coords = vec4<i32>(batch, r, c + i, d1);\n          if (coordsInBounds4D(coords, uniforms.outShape)) {\n            var value = dotProd[i];\n            ${rn(this.addBias,this.activation)}\n            setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n          }\n        }\n      }\n    `}}class ri{constructor(e,t=!1,n=null,r=!1){this.variableNames=["x","W"],this.uniforms="pad : vec2<i32>, inDims : vec2<i32>, filterHeight : i32,\n      filterWidth : i32, stride : vec2<i32>, dilation : vec2<i32>,",this.workGroupSize=[256,1,1],this.outputShape=e.outShape,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Bt(this.dispatchLayout,this.outputShape,this.workGroupSize),this.isChannelsLast="channelsLast"===e.dataFormat,t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=n,this.hasPreluActivation=r,this.shaderKey=`depthwise_${this.activation}_${this.isChannelsLast}`}getUserCode(){const e=this.isChannelsLast?"getX(batch, xR, xC, d1);":"getX(batch, d1, xR, xC);";return`\n      ${nn(this.activation,this.hasPreluActivation,!1,4)}\n\n      ${$t()} {\n        let coords = getOutputCoords();\n        let batch = coords[0];\n        let xRCCorner = vec2<i32>(coords.${this.isChannelsLast?"yz":"zw"}) * uniforms.stride - uniforms.pad;\n        let d2 = coords[${this.isChannelsLast?3:1}];\n        let channelMul = uniforms.wShape[3];\n        let d1 = d2 / channelMul;\n        let q = d2 % channelMul;\n\n        let inputRowStart = xRCCorner.x;\n        let inputColStart = xRCCorner.y;\n        let inputRowEnd = inputRowStart + uniforms.filterHeight *\n            uniforms.dilation[0];\n        let inputColEnd = inputColStart + uniforms.filterWidth *\n            uniforms.dilation[1];\n\n        // Convolve x(?, ?, d1)|x(d1, ?, ?) with w(:, :, d1, q) to get\n        // y(yR, yC, d2)|y(d2, yR, yC). ? = to be determined. : = across all\n        // values in that axis. x(?, ?, d1) and y(yR, yC, d2) is for NHWC.\n        // x(d1, ?, ?) and y(d2, yR, yC) is for NCHW.\n        var value = 0.0;\n\n        // Extract if checking out of for loop for performance.\n        if (inputRowStart >= 0 && inputColStart >= 0 &&\n          inputRowEnd < uniforms.inDims[0] &&\n              inputColEnd < uniforms.inDims[1]) {\n            for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {\n              let xR = inputRowStart + wR * uniforms.dilation[0];\n\n              for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {\n                let xC = inputColStart + wC * uniforms.dilation[1];\n\n                let xVal = ${e};\n                let wVal = getW(wR, wC, d1, q);\n                value = value + xVal * wVal;\n              }\n            }\n          } else {\n            for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {\n              let xR = inputRowStart + wR * uniforms.dilation[0];\n\n              if (xR < 0 || xR >= uniforms.inDims[0]) {\n                continue;\n              }\n\n              for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {\n                let xC = inputColStart + wC * uniforms.dilation[1];\n\n                if (xC < 0 || xC >= uniforms.inDims[1]) {\n                  continue;\n                }\n\n                let xVal = ${e};\n                let wVal = getW(wR, wC, d1, q);\n                value = value + xVal * wVal;\n              }\n            }\n          }\n          ${rn(this.addBias,this.activation)}\n        if (coordsInBounds4D(coords, uniforms.outShape)) {\n          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n        }\n      }\n    `}}const si={kernelName:j,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:r,attrs:s}=e,{x:i,filter:a}=t,{strides:o,pad:u,dataFormat:l,dilations:h,dimRoundingMode:d}=s,c=n.convertConv2DDataFormat(l);let p=h;null==p&&(p=[1,1]);const f=n.computeConv2DInfo(i.shape,a.shape,o,p,u,d,!0,c),m=[{type:"int32",data:[f.padInfo.top,f.padInfo.left]},{type:"int32",data:[f.inHeight,f.inWidth]}],g="channelsLast"===f.dataFormat;let b;return!g&&f.inHeight>16&&f.inWidth>16&&1===f.strideHeight&&1===f.strideWidth&&1===f.dilationWidth&&1===f.dilationHeight&&f.inChannels===f.outChannels?b=new ti(f.outShape,f.filterHeight,f.filterWidth):g&&f.inHeight>4&&f.inWidth>4&&f.strideWidth<=2&&f.inChannels===f.outChannels&&1===f.dilationHeight&&1===f.dilationWidth&&f.inChannels%4==0?b=new ni(f):(b=new ri(f),m.push({type:"int32",data:[f.filterHeight]},{type:"int32",data:[f.filterWidth]},{type:"int32",data:[f.strideHeight,f.strideWidth]},{type:"int32",data:[f.dilationHeight,f.dilationWidth]})),r.runWebGPUProgram(b,[i,a],i.dtype,m)}},ii=zn({opType:Xt.MUL,cpuKernelImpl:Tr,supportsComplex:!0}),ai={kernelName:Q,backendName:"webgpu",kernelFunc:ii};function oi(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:i,keepDims:a}=r;return as(s,i,a,"sum",n)}const ui={kernelName:Z,backendName:"webgpu",kernelFunc:oi};const li={kernelName:J,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:s,attrs:i}=e,{equation:a}=i,o=t,{allDims:u,summedDims:l,idDims:h}=n.decodeEinsumEquation(a,o.length);n.checkEinsumDimSizes(u.length,h,o);const{path:d,steps:c}=n.getEinsumComputePath(l,h),p=c.length;let f=null,m=u.length;const g=[];for(let e=0;e<p;++e){for(const t of c[e]){const{permutationIndices:e,expandDims:i}=n.getEinsumPermutation(m,h[t]);let a;n.isIdentityPermutation(e)?a=o[t]:(a=Zr({inputs:{x:o[t]},backend:s,attrs:{perm:e}}),g.push(a));const u=a.shape.slice();for(let e=0;e<i.length;++e)u.splice(i[e],0,1);r.arraysEqual(a.shape,u)||(a=xn({inputs:{x:a},backend:s,attrs:{shape:u}}),g.push(a)),null===f?f=a:(f=ii({inputs:{a:a,b:f},backend:s}),g.push(f))}e<p-1&&(d[e]>=0&&(f=oi({inputs:{x:f},backend:s,attrs:{axis:d[e]-(u.length-m),keepDims:!1}}),g.push(f)),m--)}for(const e of g)e!==f&&s.disposeData(e.dataId);return f}},hi={kernelName:ee,backendName:"webgpu",kernelFunc:Tn({opType:Jt.ELU})},di={kernelName:te,backendName:"webgpu",kernelFunc:zn({opType:Xt.EQUAL,dtype:"bool",cpuKernelImpl:mr})},ci=Tn({opType:Jt.EXP,cpuKernelImpl:gr,dtype:"float32"}),pi={kernelName:ne,backendName:"webgpu",kernelFunc:ci};function fi(e){const{inputs:t,attrs:n,backend:s}=e,{dim:i}=n,{input:a}=t,o=a.shape.length,u=a.shape.slice();let l=i;return i<0&&(r.assert(-(o+1)<=i,(()=>`Axis must be in the interval [${-(o+1)}, ${o}]`)),l=o+i+1),u.splice(l,0,1),xn({inputs:{x:a},backend:s,attrs:{shape:u}})}const mi={kernelName:re,backendName:"webgpu",kernelFunc:fi},gi={kernelName:se,backendName:"webgpu",kernelFunc:Tn({opType:Jt.EXPM1,cpuKernelImpl:br})};class bi{constructor(e){this.outputShape=[],this.variableNames=["x"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Bt(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="flipLeftRight"}getUserCode(){return`\n      ${$t("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let coordX = uniforms.xShape[2] - coords[2] - 1;\n          let outputValue = getX(coords[0], coords[1], coordX, coords[3]);\n          setOutputAtIndex(index, outputValue);\n        }\n      }\n    `}}const xi={kernelName:ie,backendName:"webgpu",kernelFunc:({inputs:e,backend:t})=>{const{image:n}=e,r=t,s=new bi(n.shape);return r.runWebGPUProgram(s,[n],n.dtype)}},wi={kernelName:ae,backendName:"webgpu",kernelFunc:Tn({opType:Jt.FLOOR,cpuKernelImpl:xr})},Ii={kernelName:oe,backendName:"webgpu",kernelFunc:zn({opType:Xt.INT_DIV,dtype:"int32"})};class yi{constructor(e,t,n=!1){this.isFromPixels=!0,this.outputShape=[0],this.variableNames=[],this.workGroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Bt(this.dispatchLayout,this.outputShape,this.workGroupSize,[t,1,1]),this.importVideo=n,this.shaderKey=`fromPixels_${this.importVideo}`}getUserCode(){const e=this.importVideo?"textureLoad(src, vec2<i32>(coords.yx));":"textureLoad(src, vec2<i32>(coords.yx), 0)";return`\n      @binding(1) @group(0) var src: ${this.importVideo?"texture_external":"texture_2d<f32>"};\n      ${$t("index")} {\n        let flatIndex = index * uniforms.numChannels;\n        if (flatIndex < uniforms.size) {\n          let coords = getCoordsFromIndex(flatIndex);\n          let values = ${e};\n          for (var i = 0; i < uniforms.numChannels; i = i + 1) {\n            result[flatIndex + i] = i32(floor(255.0 * values[i]));\n          }\n        }\n      }\n  `}}const ki={kernelName:ue,backendName:"webgpu",kernelFunc:function(e){const{inputs:n,backend:s,attrs:i}=e;let{pixels:a}=n;const{numChannels:o}=i;if(null==a)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");const u="undefined"!=typeof HTMLVideoElement&&a instanceof HTMLVideoElement,l="undefined"!=typeof HTMLImageElement&&a instanceof HTMLImageElement,h="undefined"!=typeof HTMLCanvasElement&&a instanceof HTMLCanvasElement||"undefined"!=typeof OffscreenCanvas&&a instanceof OffscreenCanvas,d="undefined"!=typeof ImageBitmap&&a instanceof ImageBitmap,[c,p]=u?[a.videoWidth,a.videoHeight]:[a.width,a.height],f=[p,c,o],m=u||l;if(d||h||m){let e;{if(m){const e=t().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");null!=Si&&e===vi||(vi=e,Si=document.createElement("canvas").getContext("2d",{willReadFrequently:vi})),Si.canvas.width=c,Si.canvas.height=p,Si.drawImage(a,0,0,c,p),a=Si.canvas}const n=GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,r="rgba8unorm",i=s.textureManager.acquireTexture(f[1],f[0],r,n);s.queue.copyExternalImageToTexture({source:a},{texture:i},[f[1],f[0]]),e={width:c,height:p,format:r,usage:n,texture:i}}const n=r.sizeFromShape(f),i=r.computeStrides(f),u=new yi(f,o,false),l=[{type:"uint32",data:[n]},{type:"uint32",data:[o]},{type:"uint32",data:[...i]}],h=s.makeTensorInfo([p,c],"int32");s.tensorMap.get(h.dataId).resourceInfo=e;const d=s.runWebGPUProgram(u,[h],"int32",l);return s.disposeData(h.dataId),d}const g=a.data;let b=g;if(null!=o&&4!==o){b=new Uint8Array(a.width*a.height*o);const e=g.length;let t=0;for(let n=0;n<e;n++)n%4<o&&(b[t++]=g[n])}const x=s.makeTensorInfo(f,"int32",new Int32Array(b));return s.uploadToGPU(x.dataId),x}};let Si,vi=t().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");class Ci{constructor(e,t,r,s,i){this.uniforms="varianceEpsilon : f32,",this.workGroupSize=[128,1,1],this.size=!0,this.variableNames=["x","mean","variance"],n.assertAndGetBroadcastShape(e,t),n.assertAndGetBroadcastShape(e,r),this.outputShape=e,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Bt(this.dispatchLayout,this.outputShape,this.workGroupSize),null!=s&&(n.assertAndGetBroadcastShape(e,s),this.variableNames.push("offset")),null!=i&&(n.assertAndGetBroadcastShape(e,i),this.variableNames.push("scale")),this.offsetShape=s,this.scaleShape=i,this.shaderKey="batchNorm"}getUserCode(){let e="0.0";null!=this.offsetShape&&(e="getOffsetByOutputIndex(index)");let t="1.0";null!=this.scaleShape&&(t="getScaleByOutputIndex(index)");return`\n      ${$t("index")} {\n        if (index < uniforms.size)\n        {\n          let xValue = getXByOutputIndex(index);\n          let meanValue = getMeanByOutputIndex(index);\n          let varianValue = getVarianceByOutputIndex(index);\n          let offsetValue = ${e};\n          let scaleValue = ${t};\n          let inv = scaleValue * inverseSqrt(varianValue + f32(uniforms.varianceEpsilon));\n          setOutputAtIndex(index,dot(vec3<f32>(xValue, -meanValue, offsetValue), vec3<f32>(inv, inv, 1.0)));\n        }\n      }\n  `}}const $i={kernelName:le,backendName:"webgpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r,scale:s,offset:i,mean:a,variance:o}=e,{varianceEpsilon:u}=t,l=n,h=[r,a,o];let d=null;null!=i&&(d=i.shape,h.push(i));let c=null;null!=s&&(c=s.shape,h.push(s));const p=new Ci(r.shape,a.shape,o.shape,d,c),f=[{type:"float32",data:[u]}];return l.runWebGPUProgram(p,h,r.dtype,f)}};const Ri={kernelName:he,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:r,attrs:s}=e,{x:i,filter:a,bias:o,preluActivationWeights:u}=t,{strides:l,pad:h,dataFormat:d,dilations:c,dimRoundingMode:p,activation:f,leakyreluAlpha:m}=s,g=n.convertConv2DDataFormat(d);return Os({x:i,filter:a,convInfo:n.computeConv2DInfo(i.shape,a.shape,l,c,h,p,!1,g),backend:r,bias:o,preluActivationWeights:u,leakyreluAlpha:m,activation:f})}};const Ai={kernelName:de,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:s,attrs:i}=e,{x:a,filter:o,bias:u,preluActivationWeights:l}=t,{strides:h,pad:d,dilations:c,dimRoundingMode:p,activation:f,leakyreluAlpha:m}=i;let g=c;null==g&&(g=[1,1]),r.assert(n.eitherStridesOrDilationsAreOne(h,g),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${h} and dilations '${g}'`));const b=n.computeConv2DInfo(a.shape,o.shape,h,g,d,p,!0),x=[a,o],w=null!=u,I=null!=l;w&&x.push(u),I&&x.push(l);const y=[{type:"int32",data:[b.padInfo.top,b.padInfo.left]},{type:"int32",data:[b.inHeight,b.inWidth]}];let k;return b.inHeight>4&&b.inWidth>4&&b.strideWidth<=2&&b.inChannels===b.outChannels&&1===b.dilationHeight&&1===b.dilationWidth&&b.inChannels%4==0?k=new ni(b,w,f,I):(k=new ri(b,w,f,I),y.push({type:"int32",data:[b.filterHeight]},{type:"int32",data:[b.filterWidth]},{type:"int32",data:[b.strideHeight,b.strideWidth]},{type:"int32",data:[b.dilationHeight,b.dilationWidth]})),"leakyrelu"===f&&(y.push({type:"float32",data:[m]}),k.uniforms+=" alpha : f32,"),s.runWebGPUProgram(k,x,"float32",y)}};class Ti{constructor(e,t){this.variableNames=["A","indices"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Bt(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey=`gathernd_${e}`,this.sliceDim=e,this.uniforms=`sliceDim : i32, strides : ${vt(e)},`}getUserCode(){let e;e=this.sliceDim>1?"uniforms.strides[j]":"uniforms.strides";return`\n      ${$t("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          var flattenIndex = 0;\n          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {\n            let indexTemp = i32(round(getIndices(coords[0], j)));\n            let strideNum = ${e};\n            flattenIndex = flattenIndex + indexTemp * strideNum;\n          }\n\n          setOutputAtIndex(index, getA(flattenIndex, coords[1]));\n        }\n      }\n      `}}const zi={kernelName:ce,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:s}=e,{params:i,indices:a}=t,o=a.shape,u=o[o.length-1],l=r.sizeFromShape(i.shape),[h,d,c,p]=n.prepareAndValidate(i,a),f=xn({inputs:{x:a},backend:s,attrs:{shape:[d,u]}}),m=xn({inputs:{x:i},backend:s,attrs:{shape:[r.sizeFromShape(i.shape)/c,c]}});if(s.shouldExecuteOnCPU([i,a])||"string"===i.dtype){const e=s.readSync(a.dataId),t=s.bufferSync(i),n=wr(e,t,i.dtype,d,u,c,p,i.shape,l);return s.makeTensorInfo(h,i.dtype,n.values)}const g=new Ti(u,[d,c]),b=[{type:"int32",data:[u]},{type:"int32",data:p}],x=s.runWebGPUProgram(g,[m,f],m.dtype,b),w=xn({inputs:{x:x},backend:s,attrs:{shape:h}});return s.disposeData(f.dataId),s.disposeData(m.dataId),s.disposeData(x.dataId),w}};class Pi{constructor(e,t){this.variableNames=["A","indices"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e.slice(),this.aShape=e,this.outputShape=t,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Bt(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="gather"}getUserCode(){const e=function(e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let r=0;r<e.length;r++)2===r?n.push("indexZ"):n.push(`${t[r]}`);return n.join()}(this.aShape);return`\n      ${$t("index")} {\n        if (index < uniforms.size) {\n          let resRC = getCoordsFromIndex(index);\n          let indexZ = i32(getIndices(resRC.x, resRC.z));\n          let inBounds = select(0.0, 1.0, indexZ >= 0 && indexZ < uniforms.aShape[2]);\n          setOutputAtIndex(index, inBounds * getA(${e}));\n        }\n      }\n    `}}function Ei(e){const{inputs:t,backend:s,attrs:i}=e,{x:a,indices:u}=t,{axis:l,batchDims:h}=i,d=r.parseAxisParam(l,a.shape)[0],c=n.segment_util.collectGatherOpShapeInfo(a,u,d,h),p=r.sizeFromShape(u.shape),f=[],m=xn({inputs:{x:a},backend:s,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),g=xn({inputs:{x:u},backend:s,attrs:{shape:[c.batchSize,p/c.batchSize]}});f.push(m),f.push(g);const b=[c.batchSize,c.outerSize,p/c.batchSize,c.sliceSize];if(s.shouldExecuteOnCPU([a,u])){const e=s.tensorMap.get(g.dataId).values,t=o(g.shape,g.dtype,e),n=s.tensorMap.get(m.dataId).values,r=o(m.shape,m.dtype,n),i=Ir(r,t,b);return f.forEach((e=>s.disposeData(e.dataId))),s.makeTensorInfo(c.outputShape,i.dtype,i.values)}const x=new Pi(m.shape,b),w=s.runWebGPUProgram(x,[m,g],m.dtype);f.push(w);const I=xn({inputs:{x:w},backend:s,attrs:{shape:c.outputShape}});return f.forEach((e=>s.disposeData(e.dataId))),I}const Ni={kernelName:pe,backendName:"webgpu",kernelFunc:Ei},Bi={kernelName:fe,backendName:"webgpu",kernelFunc:zn({opType:Xt.GREATER,cpuKernelImpl:kr,dtype:"bool"})},_i={kernelName:me,backendName:"webgpu",kernelFunc:zn({opType:Xt.GREATER_EQUAL,dtype:"bool",cpuKernelImpl:yr})},Fi={kernelName:ge,backendName:"webgpu",kernelFunc:Tn({opType:Jt.IS_NAN,dtype:"bool"})};const Oi={kernelName:be,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{alpha:i}=r,a=[{type:"float32",data:[i]}],o=new An(s.shape,Jt.LEAKYRELU);return o.uniforms="alpha : f32,",n.runWebGPUProgram(o,[s],"float32",a)}},Gi={kernelName:xe,backendName:"webgpu",kernelFunc:zn({opType:Xt.LESS,dtype:"bool",cpuKernelImpl:vr})},Li={kernelName:we,backendName:"webgpu",kernelFunc:zn({opType:Xt.LESS_EQUAL,dtype:"bool",cpuKernelImpl:Sr})},Di={kernelName:Ie,backendName:"webgpu",kernelFunc:Tn({opType:Jt.LOG,cpuKernelImpl:Cr})},Ui={kernelName:ye,backendName:"webgpu",kernelFunc:zn({opType:Xt.LOGICAL_AND,dtype:"bool"})},Wi={kernelName:ke,backendName:"webgpu",kernelFunc:Tn({opType:Jt.LOGICAL_NOT})},Mi={kernelName:Se,backendName:"webgpu",kernelFunc:zn({opType:Xt.MAX,cpuKernelImpl:Rr})};const Vi={kernelName:ve,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:r,attrs:s}=e,{x:i}=t,{filterSize:a,strides:o,pad:u,dimRoundingMode:l}=s;return ds(i,n.computePool2DInfo(i.shape,a,o,1,u,l),"max",r)}};const Hi={kernelName:Ce,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:i,keepDims:a}=r;return as(s,i,a,"min",n)}},Xi={kernelName:$e,backendName:"webgpu",kernelFunc:zn({opType:Xt.MIN,cpuKernelImpl:Ar})};class qi{constructor(e,t,n){this.uniforms="",this.variableNames=["x"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1])),this.dispatchLayout=Gt(this.outputShape),this.dispatch=Bt(this.dispatchLayout,this.outputShape,this.workGroupSize),this.xShape=e,t.map(((e,t)=>{this.uniforms+=` pad${t} : vec2<i32>,`})),this.offset="reflect"===n?0:1,this.shaderKey=`mirrorPad_${n}`}getUserCode(){const e=this.xShape.length,t=this.xShape.map(((e,t)=>`uniforms.pad${t}[0]`)).join(","),n=this.xShape.map(((t,n)=>`uniforms.pad${n}[0] + uniforms.xShape${e>1?`[${n}]`:""}`)).join(","),r=1===e?"start":"start[i]",s=1===e?"end":"end[i]",i=1===e?"outC":"outC[i]",a=vt(e),o=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return`\n      ${$t("index")} {\n        if (index < uniforms.size) {\n          let start = ${a}(${t});\n          let end = ${a}(${n});\n          var outC = getCoordsFromIndex(index);\n          for (var i = 0; i < ${e}; i = i + 1) {\n            if (${i} < ${r}) {\n              ${i} = ${r} * 2 - ${i} - ${this.offset};\n            } else if(${i} >= ${s}) {\n              ${i} = (${s} - 1) * 2 - ${i} + ${this.offset};\n            }\n          }\n          let coords = outC - start;\n          setOutputAtIndex(index, getX(${o}));\n        }\n      }\n    `}}const Ki={kernelName:Re,backendName:"webgpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{paddings:s,mode:i}=t,a=n,o=s.map((e=>({type:"int32",data:[e[0],e[1]]}))),u=new qi(r.shape,s,i);return a.runWebGPUProgram(u,[r],r.dtype,o)}};const Yi={kernelName:Ae,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])){const e=n.tensorMap.get(r.dataId),[t,s]=zr(e.values,r.shape,r.dtype);return n.makeTensorInfo(s,r.dtype,t)}const s=new An(r.shape,Jt.NEG);return n.runWebGPUProgram(s,[r],r.dtype)}};const ji={kernelName:Te,backendName:"webgpu",kernelFunc:function(e){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:i}=t,{maxOutputSize:a,iouThreshold:o,scoreThreshold:u}=r,l=n.readSync(s.dataId),h=n.readSync(i.dataId),{selectedIndices:d}=ze.nonMaxSuppressionV3Impl(l,h,a,o,u);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}};const Qi={kernelName:Pe,backendName:"webgpu",kernelFunc:function(e){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:i}=t,{maxOutputSize:a,iouThreshold:o,scoreThreshold:u,softNmsSigma:l}=r,h=n.readSync(s.dataId),d=n.readSync(i.dataId),c=a,p=o,f=u,m=l,{selectedIndices:g,selectedScores:b}=ze.nonMaxSuppressionV5Impl(h,d,c,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([b.length],"float32",new Float32Array(b))]}};function Zi(e){const{inputs:t,backend:n}=e,{x:r}=t;if("complex64"===r.dtype){const e=ys({inputs:{input:r},backend:n}),t=Zi({inputs:{x:e},backend:n}),s=Ts({inputs:{input:r},backend:n}),i=Zi({inputs:{x:s},backend:n}),a=$n({inputs:{real:t,imag:i},backend:n});return n.disposeData(e.dataId),n.disposeData(t.dataId),n.disposeData(s.dataId),n.disposeData(i.dataId),a}return gn({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:n})}const Ji={kernelName:Ee,backendName:"webgpu",kernelFunc:Zi};const ea={kernelName:Ne,backendName:"webgpu",kernelFunc:function e(t){const{inputs:n,backend:r}=t,{x:s}=n;if("string"===s.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===s.dtype){const t=ys({inputs:{input:s},backend:r}),n=e({inputs:{x:t},backend:r}),i=Ts({inputs:{input:s},backend:r}),a=Zi({inputs:{x:i},backend:r}),o=$n({inputs:{real:n,imag:a},backend:r});return r.disposeData(t.dataId),r.disposeData(n.dataId),r.disposeData(i.dataId),r.disposeData(a.dataId),o}return gn({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:r})}};const ta={kernelName:Be,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{axis:i}=s;if(1===t.length)return fi({inputs:{input:t[0]},backend:n,attrs:{dim:i}});const a=t[0].shape,o=t[0].dtype;t.forEach((e=>{r.assertShapesMatch(a,e.shape,"All tensors passed to stack must have matching shapes"),r.assert(o===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const u=[],l=Es({inputs:t.map((e=>{const t=fi({inputs:{input:e},backend:n,attrs:{dim:i}});return u.push(t),t})),backend:n,attrs:{axis:i}});return u.forEach((e=>n.disposeData(e.dataId))),l}};class na{constructor(e,t){this.variableNames=["x"],this.uniforms="constantValue : f32,",this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1])),this.dispatchLayout=Gt(this.outputShape),this.dispatch=Bt(this.dispatchLayout,this.outputShape,this.workGroupSize),t.map(((e,t)=>{this.uniforms+=` pad${t} : vec2<i32>,`})),this.xShape=e,this.shaderKey="pad"}getUserCode(){const e=this.xShape.length,t=vt(e),n=this.xShape.map(((e,t)=>`uniforms.pad${t}[0]`)).join(","),r=this.xShape.map(((t,n)=>`uniforms.pad${n}[0] + uniforms.xShape${e>1?`[${n}]`:""}`)).join(","),s=e>1?`${t}(${n})`:`${n}`,i=e>1?`${t}(${r})`:`${r}`,a=e>1?"any(outC < start)":"outC < start",o=e>1?"any(outC >= end)":"outC >= end",u=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return`\n      ${$t("index")} {\n        if (index < uniforms.size) {\n          let start = ${s};\n          let end = ${i};\n          let outC = getCoordsFromIndex(index);\n\n          if (${a} || ${o}) {\n            setOutputAtIndex(index, uniforms.constantValue);\n          } else {\n            let coords = outC - start;\n            setOutputAtIndex(index, getX(${u}));\n          }\n        }\n      }\n    `}}const ra=e=>{const{inputs:t,backend:n,attrs:s}=e,{x:i}=t,{paddings:a,constantValue:o}=s;if(a.every((e=>r.arraysEqual(e,[0,0]))))return vn({inputs:{x:i},backend:n});if(0===r.sizeFromShape(i.shape)){return gn({backend:n,attrs:{shape:a.map(((e,t)=>e[0]+i.shape[t]+e[1])),value:o,dtype:i.dtype}})}const u=[{type:"float32",data:[o]}];a.map((e=>u.push({type:"int32",data:[e[0],e[1]]})));const l=new na(i.shape,a);return n.runWebGPUProgram(l,[i],i.dtype,u)},sa={kernelName:_e,backendName:"webgpu",kernelFunc:ra},ia={kernelName:Fe,backendName:"webgpu",kernelFunc:zn({opType:Xt.POW})};const aa={kernelName:Oe,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r,alpha:s}=t,i=new Sn(Xt.PRELU,r.shape,s.shape);return n.runWebGPUProgram(i,[r,s],"float32")}};const oa={kernelName:Ge,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:i,keepDims:a}=r;return as(s,i,a,"prod",n)}},ua={kernelName:Le,backendName:"webgpu",kernelFunc:e=>{const{backend:t,attrs:n}=e,{start:r,stop:s,step:i,dtype:a}=n,o=Nr(r,s,i,a);return t.makeTensorInfo([o.length],a,o)}},la=zn({opType:Xt.DIV}),ha={kernelName:De,backendName:"webgpu",kernelFunc:la},da={kernelName:Ue,backendName:"webgpu",kernelFunc:Tn({opType:Jt.RECIPROCAL})},ca={kernelName:We,backendName:"webgpu",kernelFunc:Tn({opType:Jt.RELU})},pa={kernelName:Me,backendName:"webgpu",kernelFunc:Tn({opType:Jt.RELU6})};class fa{constructor(e,t,n){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, halfPixelCenters : f32,",this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],t,n,e[3]],this.dispatchLayout=Gt(this.outputShape),this.dispatch=Bt(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="resizeBilinear"}getUserCode(){return`\n      ${$t("index")} {\n        if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n          let b = coords[0];\n          let d = coords[3];\n          let rc = coords.yz;\n\n          let effectiveInSize = vec2<f32>(\n            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveOutSize = vec2<f32>(\n            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveInputOverOutputRatioRC =\n              effectiveInSize / effectiveOutSize;\n\n          // Fractional source index\n          let sourceFracIndexRC =\n            (vec2<f32>(rc) + vec2<f32>(uniforms.halfPixelCenters)) *\n            effectiveInputOverOutputRatioRC - vec2<f32>(uniforms.halfPixelCenters);\n\n          // Compute the four integer indices.\n          let sourceFloorRC = vec2<i32>(sourceFracIndexRC);\n          let sourceCeilRC = vec2<i32>(\n            min(vec2<f32>(uniforms.xShape.yz) - vec2<f32>(1.0), ceil(sourceFracIndexRC)));\n\n          let topLeft = getX(b, sourceFloorRC.x, sourceFloorRC.y, d);\n          let bottomLeft = getX(b, sourceCeilRC.x, sourceFloorRC.y, d);\n          let topRight = getX(b, sourceFloorRC.x, sourceCeilRC.y, d);\n          let bottomRight = getX(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n          let fracRC = sourceFracIndexRC - vec2<f32>(sourceFloorRC);\n\n          let top = topLeft + (topRight - topLeft) * fracRC.y;\n          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n          let newValue = top + (bottom - top) * fracRC.x;\n\n          setOutputAtIndex(index, newValue);\n        }\n      }\n    `}}const ma={kernelName:Ve,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:i,size:a,halfPixelCenters:o}=r,[u,l]=a,h=[{type:"float32",data:[i&&u>1?1:0,i&&l>1?1:0]},{type:"float32",data:[o?.5:0]}],d=new fa(s.shape,u,l);return n.runWebGPUProgram(d,[s],"float32",h)}};class ga{constructor(e,t,n,r){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, roundBase : f32,",this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],t,n,e[3]],this.dispatchLayout=Gt(this.outputShape),this.dispatch=Bt(this.dispatchLayout,this.outputShape,this.workGroupSize),this.halfPixelCenters=r,this.shaderKey=`resizeNearest_${r}`}getUserCode(){let e;e=this.halfPixelCenters?"max((vec2<f32>(rc) + vec2<f32>(0.5)) * effectiveInputOverOutputRatioRC, vec2<f32>(0.0))":"vec2<f32>(rc) * effectiveInputOverOutputRatioRC";return`\n      ${$t("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let b = coords[0];\n          let d = coords[3];\n          let rc = coords.yz;\n\n          let effectiveInSize = vec2<f32>(\n            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveOutSize = vec2<f32>(\n            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveInputOverOutputRatioRC =\n              effectiveInSize / effectiveOutSize;\n\n          // Fractional source index\n          let sourceFracIndexRC = ${e};\n\n          // Compute the coordinators of nearest neighbor point.\n          let inputShapeRC = vec2<f32>(f32(uniforms.xShape.y), f32(uniforms.xShape.z));\n          let sourceNearestRC = vec2<i32>(\n            min(inputShapeRC - 1.0, floor(sourceFracIndexRC + uniforms.roundBase)));\n          let newValue = getX(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n          setOutputAtIndex(index, newValue);\n        }\n      }\n    `}}const ba={kernelName:He,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:i,halfPixelCenters:a,size:o}=r,[u,l]=o,h=[{type:"float32",data:[i&&u>1?1:0,i&&l>1?1:0]},{type:"float32",data:[i?.5:0]}],d=new ga(s.shape,u,l,a);return n.runWebGPUProgram(d,[s],s.dtype,h)}};class xa{constructor(e,t){this.outputShape=[],this.variableNames=["x"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Bt(this.dispatchLayout,this.outputShape,this.workGroupSize),this.uniforms="centerX : f32, centerY : f32, sinRadians : f32,\n          cosRadians : f32,",this.shaderKey="rotate",this.outputShape=e,"number"==typeof t?(this.uniforms+=" fillValue : f32,",this.fillSnippet="var outputValue = uniforms.fillValue;",this.shaderKey+="_float"):(this.uniforms+=" fillValue : vec3<f32>,",this.fillSnippet="var outputValue = uniforms.fillValue[coords[3]];",this.shaderKey+="_vec3")}getUserCode(){return`\n        ${$t("index")} {\n          if (index < uniforms.size) {\n            let coords = getCoordsFromIndex(index);\n            let coordXFloat = (f32(coords[2]) - uniforms.centerX) *\n                uniforms.cosRadians - (f32(coords[1]) - uniforms.centerY) *\n                uniforms.sinRadians;\n            let coordYFloat = (f32(coords[2]) - uniforms.centerX) *\n                uniforms.sinRadians + (f32(coords[1]) - uniforms.centerY) *\n                uniforms.cosRadians;\n            let coordX = i32(round(coordXFloat + uniforms.centerX));\n            let coordY = i32(round(coordYFloat + uniforms.centerY));\n            ${this.fillSnippet}\n            if(coordX >= 0 && coordX < uniforms.xShape[2] && coordY >= 0 &&\n                coordY < uniforms.xShape[1]) {\n              outputValue = getX(coords[0], coordY, coordX, coords[3]);\n            }\n            setOutputAtIndex(index, outputValue);\n          }\n        }\n      `}}const wa={kernelName:Xe,backendName:"webgpu",kernelFunc:({inputs:e,attrs:t,backend:r})=>{const{image:s}=e,{radians:i,fillValue:a,center:o}=t,u=r,l=new xa(s.shape,a),[h,d]=n.getImageCenter(o,s.shape[1],s.shape[2]),c=[{type:"float32",data:[h]},{type:"float32",data:[d]},{type:"float32",data:[Math.sin(i)]},{type:"float32",data:[Math.cos(i)]}];"number"==typeof a?c.push({type:"float32",data:[Number.parseFloat(a.toFixed(2))]}):c.push({type:"float32",data:a});return u.runWebGPUProgram(l,[s],s.dtype,c)}},Ia={kernelName:qe,backendName:"webgpu",kernelFunc:Tn({opType:Jt.RSQRT,cpuKernelImpl:Br})};class ya{constructor(e,t,n,r,s,i,a,o=!0){this.variableNames=["updates","indices"],this.workGroupSize=[64,1,1],this.atomic=!0,this.outputShape=i,this.type=a,this.sumDupeIndices=o,this.dispatchLayout=Gt(e),this.dispatch=Bt(this.dispatchLayout,e,this.workGroupSize),this.sliceDimGreaterThanOne=t>1,this.shaderKey=`scatter_${n}_${r}_${this.sliceDimGreaterThanOne}_${a}_${o}`;const u=vt(s.length);this.uniforms=`sliceDim : i32, strides: ${u}, size: i32,`,this.updatesRank=r,this.indicesRank=n}getUserCode(){let e="";1===this.indicesRank?e="coords[0]":2===this.indicesRank&&(e="coords[0], j");const t=`getIndices(${e})`,n=this.sliceDimGreaterThanOne?"uniforms.strides[j]":"uniforms.strides";let r="",s="";1===this.dispatchLayout.x.length?(r="flattenedIndex",s="\n      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {\n        return index;\n      }\n      "):2===this.dispatchLayout.x.length&&(r="vec2<i32>(flattenedIndex, coords[1])",s="\n      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {\n        // N.B. |updates| could be a scalar tensor, conceptually representing a\n        // 2D tensor with all values equal to that. By design, its size must be\n        // the same as |outShape[1]| in one dimension, and |indicesShape[0]|\n        // gives the other.\n        let sliceSize = uniforms.outShape[1];\n        let d0 = index / sliceSize;\n        let d1 = index - d0 * sliceSize;\n        return vec2<i32>(d0, d1);\n      }\n      ");const i=`getUpdates(${Array.from({length:this.updatesRank},((e,t)=>`coords[${t}]`)).join(", ")})`;return`\n    ${s}\n\n      ${$t("index")} {\n        if (index < uniforms.size) {\n          let coords = getUpdatesCoordsFromFlatIndex(index);\n          var flattenedIndex = 0;\n          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {\n            let indexInside = i32(round(${t}));\n            flattenedIndex = flattenedIndex + indexInside * ${n};\n          }\n          let updateValue =\n              ${Et(this.type,!1)}(${i});\n          let flatIndex = getOutputIndexFromCoords(${r});\n\n          ${((e,t)=>{let n=`atomicAdd(${e}, bitcast<i32>(${t}))`;"float32"===this.type&&(n=`\n          {\n            var oldBits = 0;\n            var newBits = bitcast<i32>(${t});\n            loop {\n              let info = atomicCompareExchangeWeak(${e}, oldBits, newBits);\n              if (info.exchanged) {\n                break;\n              }\n              oldBits = info.old_value;\n              let oldValue = bitcast<f32>(oldBits);\n              let newValue = oldValue + (${t});\n              newBits = bitcast<i32>(newValue);\n            }\n          }\n        `);const r=`atomicStore(${e}, bitcast<i32>(${t}));`;return this.sumDupeIndices?n:r})("&result[flatIndex]","updateValue")};\n        }\n      }`}}const ka={kernelName:Ke,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:s,attrs:i}=e,{indices:a,updates:o}=t,{shape:u}=i,{sliceRank:l,numUpdates:h,sliceSize:d,strides:c,outputSize:p}=n.calculateShapes(o,a,u),f=[p/d,d];if(0===p)return s.makeTensorInfo(u,a.dtype);const m=xn({inputs:{x:a},backend:s,attrs:{shape:[h,l]}}),g=xn({inputs:{x:o},backend:s,attrs:{shape:[h,d]}}),b=g.dtype,x=gn({backend:s,attrs:{shape:f,value:0,dtype:b}}),w=[{type:"int32",data:[l]},{type:"int32",data:c},{type:"int32",data:[r.sizeFromShape(g.shape)]}],I=new ya(g.shape,l,m.shape.length,g.shape.length,c,f,b),y=s.runWebGPUProgram(I,[g,m],b,w,x),k=xn({inputs:{x:y},backend:s,attrs:{shape:u}});return s.disposeData(m.dataId),s.disposeData(g.dataId),s.disposeData(y.dataId),k}};class Sa{constructor(e,t,n){this.variableNames=["c","a","b"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Bt(this.dispatchLayout,this.outputShape,this.workGroupSize),this.cRank=e,this.rank=n,this.shaderKey="select"}getUserCode(){let e,t;if(this.rank>4)throw Error(`Where for rank ${this.rank} is not yet supported`);if(1===this.rank)t="resRC",e="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[],s=[];for(let e=0;e<this.outputShape.length;e++)s.push(`${n[e]}`),e<this.cRank&&r.push(`${n[e]}`);e=r.join(),t=s.join()}return`\n      ${$t("index")} {\n        if (index < uniforms.size) {\n          let resRC = getCoordsFromIndex(index);\n          let cVal = getC(${e});\n          if (cVal >= 1.0) {\n            setOutputAtIndex(index, getA(${t}));\n          } else {\n            setOutputAtIndex(index, getB(${t}));\n          }\n        }\n      }\n    `}}const va={kernelName:Ye,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:r,t:s,e:i}=t,a=new Sa(r.shape.length,s.shape,s.shape.length);return n.runWebGPUProgram(a,[r,s,i],m(s.dtype,i.dtype))}},Ca={kernelName:je,backendName:"webgpu",kernelFunc:Tn({opType:Jt.SIGMOID})},$a={kernelName:Qe,backendName:"webgpu",kernelFunc:Tn({opType:Jt.SIN})},Ra={kernelName:Ze,backendName:"webgpu",kernelFunc:Tn({opType:Jt.SINH})},Aa=zn({opType:Xt.SUB,cpuKernelImpl:Dr,supportsComplex:!0}),Ta={kernelName:Je,backendName:"webgpu",kernelFunc:Aa};const za={kernelName:et,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:s,attrs:i}=e,{logits:a}=t,{dim:o}=i,u=r.parseAxisParam([o],a.shape),l=os({inputs:{x:a},backend:s,attrs:{reductionIndices:u,keepDims:!1}}),h=n.expandShapeToKeepDim(l.shape,u),d=xn({inputs:{x:l},backend:s,attrs:{shape:h}}),c=Aa({inputs:{a:a,b:d},backend:s}),p=ci({inputs:{x:c},backend:s}),f=oi({inputs:{x:p},backend:s,attrs:{axis:u,keepDims:!1}}),m=xn({inputs:{x:f},backend:s,attrs:{shape:h}}),g=la({inputs:{a:p,b:m},backend:s});return s.disposeData(l.dataId),s.disposeData(d.dataId),s.disposeData(c.dataId),s.disposeData(p.dataId),s.disposeData(f.dataId),s.disposeData(m.dataId),g}},Pa={kernelName:tt,backendName:"webgpu",kernelFunc:e=>{const{inputs:t,backend:s,attrs:i}=e,{x:a}=t,{blockShape:o,paddings:u}=i;r.assert(a.shape.length<=4,(()=>"spaceToBatchND for rank > 4 with a WebGPU backend not implemented yet"));const l=o.reduce(((e,t)=>e*t)),h=[[0,0]];h.push(...u);for(let e=1+o.length;e<a.shape.length;++e)h.push([0,0]);const d=[],c=ra({inputs:{x:a},backend:s,attrs:{paddings:h,constantValue:0}}),p=n.getReshaped(c.shape,o,l,!1),f=n.getPermuted(p.length,o.length,!1),m=n.getReshapedPermuted(c.shape,o,l,!1),g=xn({inputs:{x:c},backend:s,attrs:{shape:p}}),b=Zr({inputs:{x:g},backend:s,attrs:{perm:f}}),x=xn({inputs:{x:b},backend:s,attrs:{shape:m}});return d.push(c),d.push(g),d.push(b),d.forEach((e=>s.disposeData(e.dataId))),x}};class Ea{constructor(e,t){this.variableNames=["A"],this.workGroupSize=[64,1,1],this.size=!0;const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[r]*t[r];this.outputShape=n,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Bt(this.dispatchLayout,this.outputShape,this.workGroupSize),this.rank=this.outputShape.length,this.shaderKey="tile"}getUserCode(){const e=function(e,t=""){if(e>=5)throw Error(`Tile for rank ${e} is not yet supported`);if(1===e)return`(resRC % ${t}aShape)`;const n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let s=0;s<e;s++)r.push(`(${n[s]} % ${t}aShape[${s}])`);return r.join()}(this.rank,"uniforms.");return`\n      ${$t("index")} {\n        if (index < uniforms.size) {\n          let resRC = getCoordsFromIndex(index);\n          setOutputAtIndex(index, getA(${e}));\n        }\n      }\n    `}}function Na(e){const{inputs:t,backend:n,attrs:s}=e,{x:i}=t,{reps:a}=s;if(n.shouldExecuteOnCPU([i])||"string"===i.dtype||i.shape.length>=5){const e=n.readSync(i.dataId),t="string"===i.dtype?e.map((e=>r.decodeString(e))):e,s=o(i.shape,i.dtype,t),u=Ur(s,a);return n.makeTensorInfo(u.shape,u.dtype,u.values)}const u=new Ea(i.shape,a);return n.runWebGPUProgram(u,[i],i.dtype)}const Ba={kernelName:nt,backendName:"webgpu",kernelFunc:Na};const _a={kernelName:rt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:s,attrs:i}=e,{sparseIndices:a,sparseValues:o,defaultValue:u}=t,{outputShape:l}=i,{sliceRank:h,numUpdates:d,sliceSize:c,strides:p,outputSize:f}=n.calculateShapes(o,a,l),m=!1;if("string"===o.dtype){const e=s.bufferSync(a),t=s.bufferSync(o),n=r.decodeString(s.readSync(u.dataId)[0]),i=_r(e,t,l,f,c,d,h,p,n,m);return s.makeTensorInfo(l,i.dtype,i.values)}const g=[f/c,c],b=xn({inputs:{x:a},backend:s,attrs:{shape:[d,h]}}),x=o.shape.length?xn({inputs:{x:o},backend:s,attrs:{shape:[d,c]}}):vn({inputs:{x:o},backend:s}),w=x.dtype,I=s.makeTensorInfo([],w,r.makeZerosTypedArray(1,w)),y=xn({inputs:{x:u},backend:s,attrs:{shape:Array(g.length).fill(1)}}),k=Na({inputs:{x:y},backend:s,attrs:{reps:g}}),S=[{type:"int32",data:[h]},{type:"int32",data:p},{type:"int32",data:[r.sizeFromShape([d,c])]}];switch(d){case 0:break;case 1:{const e=new ya([d,c],h,b.shape.length,x.shape.length,p,g,w,m);s.runWebGPUProgram(e,[x,b],w,S,k)}break;default:{const e=new ya([d,c],h,b.shape.length,I.shape.length,p,g,w,m);s.runWebGPUProgram(e,[I,b],w,S,k)}{const e=new ya([d,c],h,b.shape.length,x.shape.length,p,g,w);s.runWebGPUProgram(e,[x,b],w,S,k)}}const v=xn({inputs:{x:k},backend:s,attrs:{shape:l}});return s.disposeData(b.dataId),s.disposeData(x.dataId),s.disposeData(y.dataId),s.disposeData(I.dataId),s.disposeData(k.dataId),v}};const Fa={kernelName:st,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:s,attrs:i}=e,{x:a}=t,{numOrSizeSplits:o,axis:u}=i,l=r.parseAxisParam(u,a.shape)[0],h=n.prepareSplitSize(a,o,l),d=a.shape.length,c=new Array(d).fill(0),p=a.shape.slice();return h.map((e=>{const t=[...p];t[l]=e;const n=gs({inputs:{x:a},backend:s,attrs:{begin:c,size:t}});return c[l]+=e,n}))}},Oa={kernelName:it,backendName:"webgpu",kernelFunc:Tn({opType:Jt.SQRT})},Ga={kernelName:at,backendName:"webgpu",kernelFunc:({inputs:e,backend:t})=>{const{x:n}=e,r=t,s=new An(n.shape,Jt.SQUARE);return r.runWebGPUProgram(s,[n],n.dtype)}},La={kernelName:ot,backendName:"webgpu",kernelFunc:zn({opType:Xt.SQUARED_DIFFERENCE})};class Da{constructor(e){this.variableNames=["x"],this.workPerThread=1,this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Bt(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]);const t=vt(this.outputShape.length);this.uniforms=`begin : ${t},  strides : ${t}, `,this.shaderKey="stridedSlice"}getUserCode(){let e="";if(1===this.outputShape.length)e="coords * uniforms.strides + uniforms.begin";else{let t=0;e=this.outputShape.map(((e,n)=>(t++,1===this.outputShape.length?`coords * uniforms.strides[${n}] + uniforms.begin[${n}]`:`coords[${t-1}] * uniforms.strides[${n}] + uniforms.begin[${n}]`))).join(",")}return`\n       ${$t("index")} {\n         if (index < uniforms.size) {\n           let coords = getCoordsFromIndex(index);\n           setOutputAtIndex(index, getX(${e}));\n         }\n       }\n     `}}const Ua={kernelName:ut,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:i}=t,{begin:a,end:u,strides:l,beginMask:h,endMask:d,ellipsisMask:c,newAxisMask:p,shrinkAxisMask:f}=s,{finalShapeSparse:m,finalShape:g,isIdentity:b,sliceDim0:x,isSimpleSlice:I,begin:y,end:k,strides:S}=w.sliceInfo(i.shape,a,u,l,h,d,c,p,f);let v;if(b)v=xn({inputs:{x:i},backend:n,attrs:{shape:g}});else if(x||I){r.assert(i.shape.length>=1,(()=>`Input must have rank at least 1, got: ${i.shape.length}`));const e=w.computeOutShape(y,k,S),t=gs({inputs:{x:i},backend:n,attrs:{begin:y,size:e}});v=xn({inputs:{x:t},backend:n,attrs:{shape:g}}),n.disposeData(t.dataId)}else{if(n.shouldExecuteOnCPU([i])){const e=n.readSync(i.dataId),t=o(i.shape,i.dtype,e),r=Gr(m,t,S,y);v=n.makeTensorInfo(g,i.dtype,r.values)}else{const e=new Da(m),t=[{type:"int32",data:y},{type:"int32",data:S}],r=n.runWebGPUProgram(e,[i],i.dtype,t);v=xn({inputs:{x:r},backend:n,attrs:{shape:g}}),n.disposeData(r.dataId)}}return v}};const Wa={kernelName:lt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{separator:s,nGramWidths:i,leftPad:a,rightPad:o,padWidth:u,preserveShortSequences:l}=r,{data:h,dataSplits:d}=t,c=n.readSync(h.dataId),p=n.readSync(d.dataId),[f,m]=Lr(c,p,s,i,a,o,u,l);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",m)]}},Ma={kernelName:ht,backendName:"webgpu",kernelFunc:Tn({opType:Jt.TANH})};class Va{constructor(e){this.variableNames=["x","indices"],this.workGroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Bt(this.dispatchLayout,this.outputShape,this.workGroupSize),this.uniforms="inputSize : i32, firstPass : i32, negativeInf : f32,\n        dir : i32, inc : i32,",this.shaderKey="swap"}getUserCode(){return`\n        ${$t("index")} {\n          if (index < uniforms.size) {\n            let outC = getCoordsFromIndex(index);\n            let batch = outC[0];\n            let elemIdx = outC[1];\n            // We compare elements pair-wise within a group of size 2 * inc.\n            // The comparing rule for each group alternates between ascending\n            // and descending. Within each group, we compare each pair at\n            // positions i and i+inc. To decide whether an element at position i\n            // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n            // inc, it is in the first half of the group, we denote it as x0,\n            // otherwise we denote it as x1.\n            // For example, as shown in the Bitonic top K paper referenced\n            // above, Figure5(a) shows that element[1] is in the second half of\n            // the group when group size is 2, but it is in the first half of\n            // the group when group size is 4.\n            let isFirstInPair = elemIdx % (2 * uniforms.inc) < uniforms.inc;\n            var i = 0;\n            if (isFirstInPair) {\n              i = elemIdx;\n            } else {\n              i = elemIdx - uniforms.inc;\n            }\n\n            var i0 = 0;\n            if (uniforms.firstPass == 1) {\n              i0 = i;\n            } else {\n              i0 = i32(getIndices(batch, i));\n            }\n\n            var i1 = 0;\n            if (uniforms.firstPass == 1) {\n              i1 = i + uniforms.inc;\n            } else {\n              i1 = i32(getIndices(batch, i + uniforms.inc));\n            }\n\n            var x0 = f32(0.0);\n            var x1 = f32(0.0);\n            if (i0 < uniforms.inputSize) {\n              x0 = getX(batch, i0);\n            } else {\n              x0 = uniforms.negativeInf;\n            }\n            if (i1 < uniforms.inputSize) {\n              x1 = getX(batch, i1);\n            } else {\n              x1 = uniforms.negativeInf;\n            }\n\n            let reverse = elemIdx % (2 * uniforms.dir) >= uniforms.dir;\n            let isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n            if (reverse == isGreater) {\n              // Elements in opposite order of direction\n              let iTemp = i0;\n              i0 = i1;\n              i1 = iTemp;\n            }\n            if (isFirstInPair) {\n              setOutputAtIndex(index, f32(i0));\n            } else {\n              setOutputAtIndex(index, f32(i1));\n            }\n          }\n        }\n      `}}class Ha{constructor(e){this.variableNames=["x","indices"],this.workGroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Bt(this.dispatchLayout,this.outputShape,this.workGroupSize),this.uniforms="inputSize : i32, firstPass : i32, k : i32,",this.shaderKey="merge"}getUserCode(){return`\n        ${$t("index")} {\n          if (index < uniforms.size) {\n            let outC = getCoordsFromIndex(index);\n            let batch = outC[0];\n            let elemIdx = outC[1];\n            // The output size is half of the previous size.\n            // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _\n            // (k=4), we only need to output the indices at positions |, the\n            // indices at positions _ can be thrown away, see Figure5(b) After\n            // Phase 2 (Merge phase) in the Bitonic Top K paper referenced\n            // above.\n            // For example, the paper shows we only need to output the orange\n            // bars. The output sequence should look like this | | | | | | | |.\n            // Because the sequence is halved, to map the output index back to\n            // the previous sequence to find the corresponding value, we need\n            // to double the index. When we double the index, we basically\n            // interpolate a position, so 2i looks like\n            // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k\n            // position of each 2k positions by - elemIdx % k. E.g. for output\n            // at index 4,5,6,7, we want to get the corresponding element at\n            // original index 8,9,10,11, for output at index 8,9,10,11,\n            // we want to get the corresponding element at original index\n            // 16,17,18,19, so on and so forth.\n\n            var i = 0;\n            if (elemIdx < uniforms.k) {\n              i = elemIdx;\n            } else {\n              i = elemIdx * 2 - elemIdx % uniforms.k;\n            }\n            var i0 = 0;\n            if (uniforms.firstPass == 1) {\n              i0 = i;\n            } else {\n              i0 = i32(getIndices(batch, i));\n            }\n            var i1 = 0;\n            if (uniforms.firstPass == 1) {\n              i1 = i + uniforms.k;\n            } else {\n              i1 = i32(getIndices(batch, i + uniforms.k));\n            }\n\n            let x0 = getX(batch, i0);\n            var x1 = f32(0.0);\n            if (i1 < uniforms.inputSize) {\n              x1 = getX(batch, i1);\n            } else {\n              x1 = x0;\n            }\n\n            if (x0 >= x1) {\n              setOutputAtIndex(index, f32(i0));\n            } else {\n              setOutputAtIndex(index, f32(i1));\n            }\n          }\n        }\n      `}}function Xa(e,t){null!==t&&e.disposeData(t.dataId)}function qa(e){let t=1;for(;t<e;)t*=2;return t}const Ka={kernelName:dt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:i}=t,{k:a,sorted:o}=s,u=i.shape,l=u[u.length-1];if(n.shouldExecuteOnCPU([i])){const e=n.readSync(i.dataId),[t,r]=Wr(e,u,i.dtype,a,o);return[n.makeTensorInfo(t.shape,t.dtype,t.values),n.makeTensorInfo(r.shape,r.dtype,r.values)]}if(0===a)return u[u.length-1]=0,[n.makeTensorInfo(u,i.dtype,[]),n.makeTensorInfo(u,"int32",[])];if(1===l)return[i,gn({attrs:{shape:u,dtype:"int32",value:0},backend:n})];const h=r.sizeFromShape(u)/l,d=xn({inputs:{x:i},attrs:{shape:[h,l]},backend:n}),c=qa(a),p=qa(l);let f=null;const m=()=>null===f?[d,d]:[d,f],g=(e,t,r)=>{const s=m(),i=new Va(r),a=[{type:"int32",data:[l]},{type:"int32",data:[null===f?1:0]},{type:"float32",data:[Number.NEGATIVE_INFINITY]},{type:"int32",data:[e]},{type:"int32",data:[t]}],o=f;f=n.runWebGPUProgram(i,s,"int32",a),Xa(n,o)};for(let e=1;e<c;e*=2){const t=2*e;for(let n=e;n>=1;n/=2)g(t,n,[h,p])}for(let e=p;e>c;e/=2){const t=m(),r=new Ha([h,e/2]),s=[{type:"int32",data:[l]},{type:"int32",data:[null===f?1:0]},{type:"int32",data:[c]}],i=f;f=n.runWebGPUProgram(r,t,"int32",s),Xa(n,i);const a=c/2,o=2*a;for(let e=a;e>=1;e/=2)g(o,e,f.shape)}let b=f;f=gs({inputs:{x:f},backend:n,attrs:{begin:0,size:[h,a]}}),Xa(n,b);let x=Ei({inputs:{x:d,indices:f},backend:n,attrs:{axis:1,batchDims:1}});Xa(n,d);const w=u.slice(0,-1);w.push(a),b=f,f=xn({inputs:{x:f},attrs:{shape:w},backend:n}),Xa(n,b);const I=x;return x=xn({inputs:{x:x},attrs:{shape:w},backend:n}),Xa(n,I),[x,f]}};class Ya{constructor(e){this.variableNames=["Image","Transforms"],this.uniforms="interpolationModeId : i32, fillModeId : i32, fillValue : f32,",this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Gt(this.outputShape),this.dispatch=Bt(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="transform"}getUserCode(){return`\n          fn mapCoord(outCoord : f32, len : f32) -> f32{\n            var inCoord = outCoord;\n            if(uniforms.fillModeId == 2) {\n              if (inCoord < 0.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz2 = 2.0 * len;\n                  if (inCoord < sz2) {\n                    inCoord = sz2 * f32(i32(f32(-inCoord / sz2))) +\n                    inCoord;\n                  }\n                  if (inCoord < -len) {\n                    inCoord = inCoord + sz2;\n                  } else {\n                    inCoord = -inCoord - 1.0;\n                  }\n                }\n              } else if (inCoord > len - 1.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz2 = 2.0 * len;\n                  inCoord = inCoord - sz2 * f32(i32(f32(inCoord / sz2)));\n                  if (inCoord >= len) {\n                    inCoord = sz2 - inCoord - 1.0;\n                  }\n                }\n              }\n              return clamp(inCoord, 0.0, len - 1.0);\n            } else if (uniforms.fillModeId == 3) {\n              if (inCoord < 0.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz = len - 1.0;\n                  inCoord = inCoord + len * (f32(i32(f32(-inCoord / sz))) + 1.0);\n                }\n              } else if (inCoord > len - 1.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz = len - 1.0;\n                  inCoord = inCoord - len * f32(i32(f32(inCoord / sz)));\n                }\n              }\n              return clamp(inCoord, 0.0, len - 1.0);\n            } else if (uniforms.fillModeId == 4) {\n              return clamp(outCoord, 0.0, len - 1.0);\n            }\n            return outCoord;\n          }\n          fn readWithFillValue(batch : i32, coordY : i32, coordX : i32,\n            channel : i32) -> f32 {\n            var outputValue : f32;\n            if (0 <= coordY && coordY < uniforms.imageShape[1] && 0 <= coordX && coordX < uniforms.imageShape[2]) {\n                outputValue = getImage(batch, coordY, coordX, channel);\n            } else {\n              outputValue = uniforms.fillValue;\n            }\n            return outputValue;\n          }\n\n          ${$t("index")} {\n            if (index < uniforms.size) {\n              let coords = getCoordsFromIndex(index);\n              var outputValue : f32;\n              let batch = coords[0];\n              let x = coords[2];\n              let y = coords[1];\n              let channel = coords[3];\n              let xf = f32(x);\n              let yf = f32(y);\n              let a1 = getTransforms(batch, 0);\n              let a2 = getTransforms(batch, 1);\n              let a3 = getTransforms(batch, 2);\n              let b1 = getTransforms(batch, 3);\n              let b2 = getTransforms(batch, 4);\n              let b3 = getTransforms(batch, 5);\n              let c1 = getTransforms(batch, 6);\n              let c2 = getTransforms(batch, 7);\n              let projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = uniforms.fillValue;\n              } else {\n                let inX = (a1 * xf + a2 * yf + a3) / projection;\n                let inY = (b1 * xf + b2 * yf + b3) / projection;\n                let mapX = mapCoord(inX, f32(uniforms.imageShape[2]));\n                let mapY = mapCoord(inY, f32(uniforms.imageShape[1]));\n\n                if (uniforms.interpolationModeId == 1) {\n                  let coordY = i32(round(mapY));\n                  let coordX = i32(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  let yFloor = floor(mapY);\n                  let xFloor = floor(mapX);\n                  let yCeil = yFloor + 1.0;\n                  let xCeil = xFloor + 1.0;\n                  let valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, i32(yFloor), i32(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, i32(yFloor), i32(xCeil), channel);\n                  let valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, i32(yCeil), i32(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, i32(yCeil), i32(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutputAtIndex(index, outputValue);\n            }\n          }\n        `}}const ja=[yn,Hr,Xr,Kr,es,ts,ns,cs,ps,xs,Ss,vs,Rs,Rn,Ns,Gs,Us,Ws,Ms,Hs,Qs,Zs,ei,si,li,hi,di,pi,mi,gi,bn,xi,ki,wi,Ii,$i,Ri,Ai,zi,Ni,Bi,_i,Cn,zs,Fi,Oi,Gi,Li,Di,Ui,Wi,us,Mi,Vi,hs,Hi,Xi,Ki,ai,Yi,ji,Qi,Is,ea,ta,sa,ia,aa,oa,ua,ks,ha,da,ca,pa,wn,ma,ba,wa,Ia,ka,va,Ca,$a,Ra,bs,Ua,Wa,za,Pa,_a,Fa,Oa,Ga,La,Ta,ui,Ma,Ba,Ka,{kernelName:ct,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:s,transforms:i}=t,{interpolation:a,fillMode:o,fillValue:u,outputShape:l}=r,[h,d,c,p]=s.shape,[f,m]=null!=l?l:[d,c],g=new Ya([h,f,m,p]),b="nearest"===a?1:2;let x;switch(o){case"constant":default:x=1;break;case"reflect":x=2;break;case"wrap":x=3;break;case"nearest":x=4}const w=[{type:"int32",data:[b]},{type:"int32",data:[x]},{type:"float32",data:[u]}];return n.runWebGPUProgram(g,[s,i],"float32",w)}},Jr,{kernelName:pt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{value:s}=t;let{axis:i}=r;i<0&&(i+=s.shape.length);const a=s,o=a.shape.length,u=s.shape[i],l=new Array(o-1);let h=0;for(let e=0;e<o;e++)e!==i&&(l[h++]=a.shape[e]);const d=[],c=new Array(o).fill(0),p=a.shape.slice();p[i]=1;const f=new Array(u);for(let e=0;e<f.length;e++){c[i]=e;const t=gs({inputs:{x:a},backend:n,attrs:{begin:c,size:p}}),r=xn({inputs:{x:t},backend:n,attrs:{shape:l}});f[e]=r,d.push(t)}return d.forEach((e=>n.disposeData(e.dataId))),f}},Ji];for(const e of ja)ft(e);export{Ht as WebGPUBackend,Mt as webgpu_util};
//# sourceMappingURL=tf-backend-webgpu.fesm.min.js.map
