/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("@tensorflow/tfjs-core")):"function"==typeof define&&define.amd?define(["exports","@tensorflow/tfjs-core"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).tf=e.tf||{},e.tf)}(this,(function(e,t){"use strict";function n(e){if(e&&e.__esModule)return e;var t=Object.create(null);return e&&Object.keys(e).forEach((function(n){if("default"!==n){var r=Object.getOwnPropertyDescriptor(e,n);Object.defineProperty(t,n,r.get?r:{enumerable:!0,get:function(){return e[n]}})}})),t.default=e,t}var r=n(t);const i=t.env();i.registerFlag("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE",(()=>15)),i.registerFlag("WEBGPU_CPU_FORWARD",(()=>!0)),i.registerFlag("WEBGPU_MATMUL_PROGRAM_TYPE",(()=>-1)),i.registerFlag("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE",(()=>!1)),i.registerFlag("WEBGPU_USE_LOW_POWER_GPU",(()=>!1)),i.registerFlag("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD",(()=>1e3)),i.registerFlag("WEBGPU_USE_PROFILE_TOOL",(()=>!1)),i.registerFlag("WEBGPU_IMPORT_EXTERNAL_TEXTURE",(()=>!0)),i.registerFlag("WEBGPU_USE_NAIVE_CONV2D_DEBUG",(()=>!1));class s{constructor(e){e&&(this.vendor=e.vendor)}isIntel(){return"intel"===this.vendor}}class a{constructor(e){this.device=e,this.numUsedBuffers=0,this.numFreeBuffers=0,this.freeBuffers=new Map,this.usedBuffers=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireUploadBuffer(e,t){return this.acquireBuffer(e,t,!0)}acquireBuffer(e,t,n=!1){const r=o(e,t);if(this.freeBuffers.has(r)||this.freeBuffers.set(r,[]),this.usedBuffers.has(r)||this.usedBuffers.set(r,[]),this.numBytesUsed+=e,this.numUsedBuffers++,this.freeBuffers.get(r).length>0){this.numFreeBuffers--;const e=this.freeBuffers.get(r).shift();return this.usedBuffers.get(r).push(e),e}this.numBytesAllocated+=e;const i=this.device.createBuffer({size:e,usage:t,mappedAtCreation:n});return this.usedBuffers.get(r).push(i),i}releaseBuffer(e,t,n){if(0===this.freeBuffers.size)return;const r=o(t,n);this.freeBuffers.has(r)||this.freeBuffers.set(r,[]),this.freeBuffers.get(r).push(e),this.numFreeBuffers++,this.numUsedBuffers--;const i=this.usedBuffers.get(r),s=i.indexOf(e);if(s<0)throw new Error("Cannot release a buffer that was never provided by this buffer manager");i.splice(s,1),this.numBytesUsed-=t}releaseUploadBuffer(e,t,n){e.mapAsync(GPUMapMode.WRITE).then((()=>{this.releaseBuffer(e,t,n)}),(e=>{}))}getNumUsedBuffers(){return this.numUsedBuffers}getNumFreeBuffers(){return this.numFreeBuffers}dispose(){this.freeBuffers.forEach(((e,t)=>{e.forEach((e=>{e.destroy()}))})),this.usedBuffers.forEach(((e,t)=>{e.forEach((e=>{e.destroy()}))})),this.freeBuffers=new Map,this.usedBuffers=new Map,this.numUsedBuffers=0,this.numFreeBuffers=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function o(e,t){return`${e}_${t}`}class u{constructor(e){this.device=e,this.numUsedTextures=0,this.numFreeTextures=0,this.freeTextures=new Map,this.usedTextures=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireTexture(e,t,n,r){const i=e*t*d(n),s=l(e,t,n,r);if(this.freeTextures.has(s)||this.freeTextures.set(s,[]),this.usedTextures.has(s)||this.usedTextures.set(s,[]),this.numBytesUsed+=i,this.numUsedTextures++,this.freeTextures.get(s).length>0){this.numFreeTextures--;const e=this.freeTextures.get(s).shift();return this.usedTextures.get(s).push(e),e}this.numBytesAllocated+=i;const a=this.device.createTexture({size:[e,t],format:n,usage:r});return this.usedTextures.get(s).push(a),a}releaseTexture(e,t,n,r,i){if(0===this.freeTextures.size)return;const s=l(t,n,r,i);this.freeTextures.has(s)||this.freeTextures.set(s,[]),this.freeTextures.get(s).push(e),this.numFreeTextures++,this.numUsedTextures--;const a=this.usedTextures.get(s),o=a.indexOf(e);if(o<0)throw new Error("Cannot release a texture that was never provided by this texture manager");a.splice(o,1);const u=t*n*d(r);this.numBytesUsed-=u}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){this.freeTextures.forEach(((e,t)=>{e.forEach((e=>{e.destroy()}))})),this.usedTextures.forEach(((e,t)=>{e.forEach((e=>{e.destroy()}))})),this.freeTextures=new Map,this.usedTextures=new Map,this.numUsedTextures=0,this.numFreeTextures=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function l(e,t,n,r){return`${e}_${t}_${n}_${r}`}function d(e){if("rgba8unorm"===e)return 16;throw new Error(`${e} is not supported!`)}function h(e,t){if(Math.max(...e)>3)throw new Error("Cannot symbolically compute strides for rank > 4 tensor.");const n=e.length,r=e.map((e=>`${t}[${e}]`)),i=new Array(n-1);i[n-2]=r[n-1];for(let e=n-3;e>=0;--e)i[e]=`(${i[e+1]} * ${r[e+1]})`;return i}const c=(e,n,r,i)=>{const s=function(e,n,r){const i=[];if(i.push(`\n      const workGroupSizeX = ${r.workGroupSize[0]}u;\n      const workGroupSizeY = ${r.workGroupSize[1]}u;\n      const workGroupSizeZ = ${r.workGroupSize[2]}u;\n\n      var<private> localId: vec3<u32>;\n      var<private> globalId: vec3<u32>;\n      var<private> numWorkgroups: vec3<u32>;\n\n      // Only used when the y/z dimension of workgroup size is 1.\n      fn getGlobalIndex() -> i32 {\n        ${I(r)?"  return i32(globalId.x);":"  let localInvocationIndex = localId.z * workGroupSizeX * workGroupSizeY +\n                   localId.y * workGroupSizeX + localId.x;\n               let workGroupID = (globalId - localId)/vec3<u32>(\n                   workGroupSizeX, workGroupSizeY, workGroupSizeZ);\n\n               return i32((workGroupID.z * numWorkgroups.x * numWorkgroups.y +\n                   workGroupID.y * numWorkgroups.x + workGroupID.x) *\n                   (workGroupSizeX * workGroupSizeY * workGroupSizeZ) +\n                   localInvocationIndex);\n        "}\n      }\n    `),r.isFromPixels)return i.push(`\n        struct Uniform {\n          size            : i32,\n          numChannels     : i32,\n          outShapeStrides : vec2<i32>,\n        };\n\n        @group(0) @binding(0) var<storage, read_write> result: array<${k(n.dtype,r.isVec4)}>;\n        @group(0) @binding(2) var<uniform> uniforms: Uniform;\n      `),[b,i.join("\n"),x(n.shape),r.getUserCode()].join("\n");let s="struct Uniforms { NAN : f32, ";r.variableNames.forEach(((t,n)=>{const r=p(e[n].shape.length);s+=`${t.charAt(0).toLowerCase()+t.slice(1)}Shape : ${r}, `}));const a=p(n.shape.length);s+=`outShape : ${a}, `;const o=p(n.shape.length-1);s+=`\n         outShapeStrides: ${o}, `,r.size&&(s+="size : i32, ");r.uniforms&&(s+=r.uniforms);s+="};",s=function(e){const t=/(\w+)\s*:\s*vec(5|6)/g;e=e.replace(t,(e=>"@align(16) "+e));const n=/vec(5|6)\s*,\s*(\w+)/g;return e=e.replace(n,((e,t,n)=>`vec${t}, @align(16) ${n}`))}(s),i.push(s),r.atomic?i.push("\n      @group(0) @binding(0) var<storage, read_write> result: array<atomic<i32>>;\n    "):i.push(`\n      @group(0) @binding(0) var<storage, read_write> result: array<${k(n.dtype,r.isVec4)}>;\n    `);r.variableNames.forEach(((t,n)=>{i.push(`\n      @group(0) @binding(${1+n}) var<storage, read> ${t}: array<${r.variableTypes?r.variableTypes[n]:k(e[n].dtype,r.isVec4)}>;\n        `)})),""!==s&&i.push(`\n      @group(0) @binding(${1+r.variableNames.length}) var<uniform> uniforms: Uniforms;\n      `);const u=function(e,t){const{x:n,y:r=[],z:i=[]}=t,s=e.length,a=n.length+r.length+i.length;if(a!==s)return"";if(n.length===s){return`fn getOutputCoords() -> ${p(s)}{\n    let globalIndex = getGlobalIndex();\n    return getCoordsFromIndex(globalIndex);\n  }\n  `}let o="";const u=[n,r,i];for(let e=0;e<u.length;e++){const t=u[e];if(0!==t.length)if(1===t.length)o+=`let d${t[0]} = i32(globalId[${e}]);`;else{const n=h(t,"uniforms.outShape");o+=`var index${e} = i32(globalId[${e}]);`;for(let r=0;r<n.length;r++)o+=`let d${t[r]} = index${e} / ${n[r]};`,r===n.length-1?o+=`let d${t[r+1]} = index${e} - d${t[r]} * ${n[r]};`:o+=`index${e} = index${e} - d${t[r]} * ${n[r]};`}}const l=[];for(let e=0;e<a;e++)l.push(`d${e}`);const d=p(a);let c=`fn getOutputCoords() -> ${d} {\n  ${o}\n`;0===l.length?c+=`return ${d}(0); }`:c+=`return ${d}(${l.join(",")}); }`;return c}(n.shape,r.dispatchLayout),l=[b,i.join("\n"),x(n.shape),u,w(n.shape.length)];r.atomic||l.push(function(e,t,n){const r=e.length,i=k(t,n);let s;s=n?`fn setOutputAtIndex(flatIndex : i32, value : vec4<f32>) {\n      result[flatIndex] = ${i}(value);\n    }\n    fn setOutputAtIndexI32(flatIndex : i32, value : vec4<i32>) {\n      result[flatIndex] = ${i}(value);\n    }`:`fn setOutputAtIndex(flatIndex : i32, value : f32) {\n      result[flatIndex] = ${i}(value);\n    }\n    fn setOutputAtIndexI32(flatIndex : i32, value : i32) {\n      result[flatIndex] = ${i}(value);\n    }`;if(r>=2){const e=["d0","d1","d2","d3","d4","d5"].slice(0,r),t=p(r);s+=n?`\n      fn setOutputAtCoords(${e.map((e=>`${e} : i32`)).join(", ")}, value : vec4<f32>) {\n        let flatIndex = getOutputIndexFromCoords(${t}(${e.join(", ")}));\n        setOutputAtIndex(flatIndex / 4, value);\n      }\n      fn setOutputAtCoordsI32(${e.map((e=>`${e} : i32`)).join(", ")}, value : vec4<i32>) {\n        let flatIndex = getOutputIndexFromCoords(${t}(${e.join(", ")}));\n        setOutputAtIndexI32(flatIndex / 4, value);\n      }\n    `:`\n      fn setOutputAtCoords(${e.map((e=>`${e} : i32`)).join(", ")}, value : f32) {\n        let flatIndex = getOutputIndexFromCoords(${t}(${e.join(", ")}));\n        setOutputAtIndex(flatIndex, value);\n      }\n      fn setOutputAtCoordsI32(${e.map((e=>`${e} : i32`)).join(", ")}, value : i32) {\n        let flatIndex = getOutputIndexFromCoords(${t}(${e.join(", ")}));\n        setOutputAtIndexI32(flatIndex, value);\n      }\n    `}return s}(n.shape,n.dtype,r.isVec4));const d=e.map(((e,i)=>function(e,n,r,i){let s=function(e,t){const n=e.name,r=e.shape.length,i=p(r),s="get"+n.charAt(0).toUpperCase()+n.slice(1),a=["d0","d1","d2","d3","d4","d5"].slice(0,r),o=a.map((e=>`${e} : i32`)).join(", ");if(r<1)return t?`\n        fn ${s}() -> vec4<f32> {\n          return vec4<f32>(${n}[0]);\n        }\n      `:`\n      fn ${s}() ->f32 {\n        return f32(${n}[0]);\n      }\n    `;const u=`uniforms.${n.charAt(0).toLowerCase()+n.slice(1)}Shape`;let l=`${r}D`;0===r&&(l="1D");if(t)return`\n      fn ${s}(${o}) -> vec4<f32> {\n        return vec4<f32>(${n}[getIndexFromCoords${l}(${i}(${a.join(",")}),\n          ${u}) / 4]);\n      }\n      `;return`\n    fn ${s}(${o}) -> f32 {\n      return f32(${n}[getIndexFromCoords${l}(${i}(${a.join(",")}),\n        ${u})]);\n    }\n   `}(e,r);e.shape.length<=n.length&&(s+=function(e,n,r,i){const s=e.name,a=s.charAt(0).toUpperCase()+s.slice(1),o="get"+a+"ByOutput",u=e.shape.length,l=n.length,d=p(l);if(t.util.arraysEqual(e.shape,n)&&i)return r?`\n      fn ${o}Index(globalIndex : i32) -> vec4<f32> {\n        return vec4<f32>(${s}[globalIndex]);\n      }\n\n      fn ${o}Coords(coords : ${d}) -> vec4<f32> {\n        return vec4<f32>(${s}[${l>1?"getOutputIndexFromCoords(coords)":"coords"} / 4]);\n      }\n      `:`\n    fn ${o}Index(globalIndex : i32) -> f32 {\n      return f32(${s}[globalIndex]);\n    }\n\n    fn ${o}Coords(coords : ${d}) -> f32 {\n      return f32(${s}[${l>1?"getOutputIndexFromCoords(coords)":"coords"}]);\n    }\n    `;const h=t.backend_util.getBroadcastDims(e.shape,n),c=l-u;let m="";if(0===u)return r?`\n    fn ${o}Index(globalIndex : i32) -> vec4<f32> {\n      return get${a}();\n    }\n\n    fn ${o}Coords(coords : ${d}) -> vec4<f32> {\n      return get${a}();\n    }\n  `:`\n    fn ${o}Index(globalIndex : i32) -> f32{\n      return get${a}();\n    }\n\n    fn ${o}Coords(coords : ${d}) -> f32{\n      return get${a}();\n    }\n  `;m=l<2&&h.length>=1?"coords = 0;":h.map((e=>`coords.${f(e+c)} = 0;`)).join("\n");let g="";if(l<2&&u>0)g="coords";else if(l>1){const t=p(u),n=e.shape.map(((e,t)=>`coords.${f(t+c)}`)).join(", ");g=`${t}(${n})`}else g="coords";const b=`uniforms.${s.charAt(0).toLowerCase()+s.slice(1)}Shape`,x=`${u}D`;if(r)return`\n    fn ${o}Index(globalIndex : i32) -> vec4<f32> {\n      var coords = getCoordsFromIndex(globalIndex);\n      ${m}\n      return ${s}[getIndexFromCoords${x}(${g}, ${b}) / 4];\n    }\n\n    fn ${o}Coords(coordsIn : ${d}) -> vec4<f32> {\n      var coords = coordsIn;\n      ${m}\n      return ${s}[getIndexFromCoords${x}(${g}, ${b}) / 4];\n    }\n  `;return`\n  fn ${o}Index(globalIndex : i32) -> f32 {\n    var coords = getCoordsFromIndex(globalIndex);\n    ${m}\n    return f32(${s}[getIndexFromCoords${x}(${g}, ${b})]);\n  }\n\n  fn ${o}Coords(coordsIn : ${d}) -> f32 {\n    var coords = coordsIn;\n    ${m}\n    return f32(${s}[getIndexFromCoords${x}(${g}, ${b})]);\n  }\n`}(e,n,r,i));return s}(e,n.shape,r.variableTypes?"vec4<f32>"===r.variableTypes[i]:r.isVec4,r.dispatchLayout.x.length===n.shape.length))).join("\n");l.push(d),l.push(r.getUserCode());return l.join("\n")}(r,{dtype:i.dtype,shape:i.shape},n),a=e.createShaderModule({code:s,label:n.constructor.name});return e.createComputePipeline({compute:{module:a,entryPoint:"_start"},label:n.constructor.name,layout:"auto"})};function p(e){if(e<=1)return"i32";if(2===e)return"vec2<i32>";if(3===e)return"vec3<i32>";if(4===e)return"vec4<i32>";if(5===e)return"vec5";if(6===e)return"vec6";throw Error(`GPU for rank ${e} is not yet supported`)}function f(e){if(0===e)return"x";if(1===e)return"y";if(2===e)return"z";if(3===e)return"w";if(4===e)return"u";if(5===e)return"v";throw Error(`Index ${e} is not yet supported`)}function m(...e){let t;switch(e.length){case 0:t=`\n        ${g()}\n        fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,\n                  @builtin(global_invocation_id) GlobalId : vec3<u32>,\n                  @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {\n          localId = LocalId;\n          globalId = GlobalId;\n          numWorkgroups = NumWorkgroups;\n          main();\n        }\n\n        fn main()\n      `;break;case 1:t=`\n        ${g()}\n        fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,\n                  @builtin(global_invocation_id) GlobalId : vec3<u32>,\n                  @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {\n          localId = LocalId;\n          globalId = GlobalId;\n          numWorkgroups = NumWorkgroups;\n          main(getGlobalIndex());\n        }\n\n        fn main(${e[0]} : i32)\n      `;break;default:throw Error("Unreachable")}return t}function g(){return"\n  @compute @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n"}const b="\n  struct vec5 {x: i32, y: i32, z: i32, w: i32, u: i32};\n  struct vec6 {x: i32, y: i32, z: i32, w: i32, u: i32, v: i32};\n\n  // Checks whether coordinates lie within the bounds of the shape.\n  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {\n    return all(coord >= vec2<i32>(0)) && all(coord < shape);\n  }\n  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {\n    return all(coord >= vec3<i32>(0)) && all(coord < shape);\n  }\n  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {\n    return all(coord >= vec4<i32>(0)) && all(coord < shape);\n  }\n\n  fn getIndexFromCoords1D(coord : i32, shape : i32) -> i32 {\n    return coord;\n  }\n  fn getIndexFromCoords2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {\n    return dot(coords, vec2<i32>(shape.y, 1));\n  }\n  fn getIndexFromCoords3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {\n    return dot(coords, vec3<i32>(shape.y * shape.z, shape.z, 1));\n  }\n  fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n    return dot(coords, vec4<i32>(\n        shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\n  }\n  fn getIndexFromCoords5D(coords : vec5, shape : vec5) -> i32 {\n    let shapeStrides: vec5 = vec5(shape.y * shape.z * shape.w * shape.u, shape.z * shape.w * shape.u, shape.w * shape.u, shape.u, 1);\n    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u;\n  }\n  fn getIndexFromCoords6D(coords : vec6, shape : vec6) -> i32 {\n    let shapeStrides: vec6 = vec6(shape.y * shape.z * shape.w * shape.u * shape.v, shape.z * shape.w * shape.u * shape.v, shape.w * shape.u * shape.v, shape.u * shape.v, shape.v, 1);\n    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u + coords.v*shapeStrides.v;\n  }\n\n  fn idiv(a: i32, b: i32, sign: f32) -> i32 {\n    var res: i32 = a / b;\n    let modulo: i32 = a % b;\n    if (sign < 0. && modulo != 0) {\n      res = res - 1;\n    }\n    return res;\n  }\n\n  // NaN defination in IEEE 754-1985 is :\n  //   - sign = either 0 or 1.\n  //   - biased exponent = all 1 bits.\n  //   - fraction = anything except all 0 bits (since all 0 bits represents infinity).\n  // https://en.wikipedia.org/wiki/IEEE_754-1985#Representation_of_non-numbers\n  fn isnan(val: f32) -> bool {\n    let floatToUint: u32 = bitcast<u32>(val);\n    return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n  }\n  fn isnanVec4(val : vec4<f32>) -> vec4<bool> {\n    return vec4<bool>(isnan(val[0]), isnan(val[1]), isnan(val[2]), isnan(val[3]));\n  }\n";function x(e){const n=e.length;if(n<=1)return"fn getCoordsFromIndex(index : i32) -> i32 { return index; }";const r=t.util.computeStrides(e),i=p(n),s=[];for(let e=0;e<n;e++)s.push(`d${e}`);if(1===r.length)return"    fn getCoordsFromIndex(index : i32) -> vec2<i32> {\n      let d0 = index / uniforms.outShapeStrides; let d1 = index - d0 * uniforms.outShapeStrides;\n      return vec2<i32>(d0, d1);\n    }";let a;return a="var index2 = index;"+r.map(((e,t)=>`${`let ${s[t]} = index2 / uniforms.outShapeStrides.${f(t)}`}; ${t===r.length-1?`let ${s[t+1]} = index2 - ${s[t]} * uniforms.outShapeStrides.${f(t)}`:`index2 = index2 - ${s[t]} * uniforms.outShapeStrides.${f(t)}`};`)).join(""),`\n    fn getCoordsFromIndex(index : i32) -> ${i} {\n      ${a}\n      return ${i}(${s.join(",")});\n    }\n  `}function w(e){let n="";switch(e){case 0:case 1:n+="\n        fn getOutputIndexFromCoords(coords : i32) -> i32 {\n          return coords;\n        }\n        ";break;case 2:n+="\n        fn getOutputIndexFromCoords(coords : vec2<i32>) -> i32 {\n          return dot(coords, vec2<i32>(uniforms.outShapeStrides, 1));\n        }\n        ";break;case 3:n+="\n        fn getOutputIndexFromCoords(coords : vec3<i32>) -> i32 {\n          return dot(coords, vec3<i32>(uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, 1));\n        }\n        ";break;case 4:n+="\n        fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\n          return dot(coords, vec4<i32>(\n            uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, uniforms.outShapeStrides.z, 1));\n        }\n        ";break;case 5:n+="\n        fn getOutputIndexFromCoords(coords : vec5) -> i32 {\n          return coords.x * uniforms.outShapeStrides.x +\n              coords.y * uniforms.outShapeStrides.y +\n              coords.z * uniforms.outShapeStrides.z +\n              coords.w * uniforms.outShapeStrides.w +\n              coords.u;\n        }\n        ";break;case 6:n+="\n        fn getOutputIndexFromCoords(coords : vec6) -> i32 {\n          return coords.x * uniforms.outShapeStrides.x +\n              coords.y * uniforms.outShapeStrides.y +\n              coords.z * uniforms.outShapeStrides.z +\n              coords.w * uniforms.outShapeStrides.w +\n              coords.u * uniforms.outShapeStrides.u +\n              coords.v;\n        }\n        ";break;default:t.util.assert(!1,(()=>`Unsupported ${e}D shape`))}return n}function I(e){return 1===e.dispatch[1]&&1===e.dispatch[2]}function k(e,t){return"float32"===e?t?"vec4<f32>":"f32":"int32"===e||"bool"===e?t?"vec4<i32>":"i32":e}const y=e=>{let t=1;for(let n=0;n<e.length;n++)t*=e[n];return t};function S(e,t,n=[1,1,1],r=[1,1,1]){const[i,s,a]=[Math.ceil(y(e.x.map((e=>t[e])))/(n[0]*r[0])),e.y?Math.ceil(y(e.y.map((e=>t[e])))/(n[1]*r[1])):1,e.z?Math.ceil(y(e.z.map((e=>t[e])))/(n[2]*r[2])):1];return[i,s,a]}function v(e,t,n,r=!1){const i=[8,8,1],s=[4,4,1];return r||(e<=8&&(s[1]=1),t<=16&&n<=16&&(i[0]=4)),{workGroupSize:i,elementsPerThread:s}}function C(e,t,n=!1){if(n)return[8,8,1];const r=y(e.x.map((e=>t[e]))),i=y(e.y.map((e=>t[e])));return r<=4?[4,16,1]:i<=4?[16,4,1]:[16,16,1]}function $(e,t,n=!1){if(n)return[4,4,1];const r=y(e.x.map((e=>t[e]))),i=y(e.y.map((e=>t[e])));return r<=4?[1,2,1]:i<=4?[2,1,1]:[2,2,1]}function R(e){return{x:e.map(((e,t)=>t))}}function T(e){if("float32"===e||"int32"===e||"bool"===e||"string"===e)return 4;if("complex64"===e)return 8;throw new Error(`Unknown dtype ${e}`)}function A(e,t){if("float32"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t||"string"===t)return Uint8Array.from(new Int32Array(e));throw new Error(`Unknown dtype ${t}`)}function P(){return("undefined"!=typeof window||"undefined"!=typeof WorkerGlobalScope)&&!!navigator.gpu}var z;!function(e){e[e.MatMulReduceProgram=0]="MatMulReduceProgram",e[e.MatMulSplitKProgram=1]="MatMulSplitKProgram",e[e.MatMulSmallOutputSizeProgram=2]="MatMulSmallOutputSizeProgram",e[e.MatMulPackedProgram=3]="MatMulPackedProgram",e[e.MatMulMax=4]="MatMulMax"}(z||(z={}));var _={__proto__:null,tilesFitEvenlyIntoShape:function(e,t){if(e.length!==t.length)throw new Error(`Cannot compute whether rank ${e.length} tiles fit evenly into rank ${t.length} shape - ranks must match.`);return t.every(((t,n)=>t%e[n]==0))},computeDispatch:S,computeWorkGroupInfoForMatMul:v,computeWorkGroupSizeForConv2d:C,computeWorkPerThreadForConv2d:$,flatDispatchLayout:R,GPUBytesPerElement:T,ArrayBufferToTypedArray:A,isWebGPUSupported:P,get MatMulProgramType(){return z}};const E=t.env().getNumber("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD");class N extends t.KernelBackend{constructor(e,n){if(super(),this.commandQueueOwnedIds=new WeakSet,this.dispatchNumberInEncoder=0,this.disposed=!1,this.downloadWaitMs=0,this.tensorDataPendingDisposal=[],this.stagingPendingDisposal=[],this.uniformPendingDisposal=[],this.uploadWaitMs=0,!P())throw new Error("WebGPU is not supported on this device");this.pipelineCache={},this.device=e,this.queue=e.queue,this.currentCommandEncoder=null,this.currentComputePass=null,this.supportTimeQuery=e.features.has("timestamp-query"),this.adapterInfo=new s(n),this.bufferManager=new a(this.device),this.textureManager=new u(this.device),this.tensorMap=new t.DataStorage(this,t.engine()),this.supportTimeQuery&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:2})),t.env().getBool("WEBGPU_USE_PROFILE_TOOL")&&(this.dummyCanvas=document.createElement("canvas"),this.dummyCanvas.width=1,this.dummyCanvas.height=1,this.dummyContext=this.dummyCanvas.getContext("webgpu"),this.dummyContext.configure({device:e,format:"bgra8unorm"}),document.body.appendChild(this.dummyCanvas))}nextDataId(){return N.nextDataId++}floatPrecision(){return 32}defaultGpuBufferUsage(){return GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST}disposeData(e,t=!1){if(this.tensorDataPendingDisposal.indexOf(e)>=0)return!1;if(!this.tensorMap.has(e))return!0;const n=this.tensorMap.get(e);if(this.decRef(e),!t&&n.refCount>0)return!1;if(this.commandQueueOwnedIds.has(e))return this.tensorDataPendingDisposal.push(e),!1;const{complexTensorInfos:r}=this.tensorMap.get(e);return null!=r&&(this.disposeData(r.real.dataId,t),this.disposeData(r.imag.dataId,t)),this.releaseResource(e),this.tensorMap.delete(e),!0}memory(){return{numBytesInGPU:this.bufferManager.numBytesUsed,numBytesAllocatedInGPU:this.bufferManager.numBytesAllocated,unreliable:!1}}releaseResource(e){const t=this.tensorMap.get(e);if(t&&t.resourceInfo){if("texture"in t.resourceInfo){const e=t.resourceInfo;e.texture instanceof GPUTexture&&this.textureManager.releaseTexture(e.texture,e.width,e.height,e.format,e.usage),e.texture=null}else{const e=t.resourceInfo;this.bufferManager.releaseBuffer(e.buffer,e.size,e.usage),e.buffer=null}t.resourceInfo=null}}refCount(e){if(this.tensorMap.has(e)){return this.tensorMap.get(e).refCount}return 0}incRef(e){this.tensorMap.get(e).refCount++}decRef(e){if(this.tensorMap.has(e)){this.tensorMap.get(e).refCount--}}write(e,t,n){if("complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.tensorMap.set(r,{dtype:n,shape:t,values:e,refCount:1}),r}move(e,t,n,r,i){if("complex64"===r)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.tensorMap.set(e,{dtype:r,shape:n,values:t,refCount:i})}submitQueue(){this.ensureComputePassEnded(),this.queue.submit([this.currentCommandEncoder.finish()]),this.currentCommandEncoder=null,this.dispatchNumberInEncoder=0,this.commandQueueOwnedIds=new WeakSet,this.tensorDataPendingDisposal.forEach((e=>{this.releaseResource(e),this.tensorMap.delete(e)})),this.uniformPendingDisposal.forEach((e=>this.bufferManager.releaseBuffer(e.buffer,e.size,e.usage))),this.stagingPendingDisposal.forEach((e=>this.bufferManager.releaseUploadBuffer(e.buffer,e.size,e.usage))),this.tensorDataPendingDisposal=[],this.uniformPendingDisposal=[],this.stagingPendingDisposal=[]}ensureCommandEncoderReady(){this.currentCommandEncoder||(this.currentCommandEncoder=this.device.createCommandEncoder())}ensureComputePassEnded(){this.currentComputePass&&(this.currentComputePass.end(),this.currentComputePass=null)}getComputePass(){return this.currentComputePass||(this.currentComputePass=this.currentCommandEncoder.beginComputePass()),this.currentComputePass}async getBufferData(e,n){const r=this.bufferManager.acquireBuffer(n,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ);this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.copyBufferToBuffer(e,0,r,0,n),this.submitQueue(),await r.mapAsync(GPUMapMode.READ);const i=r.getMappedRange().slice(0);return r.unmap(),null!=r&&this.bufferManager.releaseBuffer(r,n,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ),t.env().getBool("WEBGPU_USE_PROFILE_TOOL")&&(t.util.assert(void 0!==this.dummyContext,(()=>"Fail to get context for profiling tool")),this.dummyContext.getCurrentTexture()),i}convertAndCacheOnCPU(e,t){const n=this.tensorMap.get(e);return this.releaseResource(e),n.values=t,n.values}readSync(e){const t=this.tensorMap.get(e),{values:n}=t;if(null==n)throw new Error("WebGPU readSync is only available for CPU-resident tensors.");return n}async read(e){if(!this.tensorMap.has(e))throw new Error(`Tensor ${e} was not registered!`);const n=this.tensorMap.get(e),{values:r}=n;if(null!=r)return this.convertAndCacheOnCPU(e,r);let i;if("complex64"===n.dtype){const e=await Promise.all([this.read(n.complexTensorInfos.real.dataId),this.read(n.complexTensorInfos.imag.dataId)]),r=e[0],s=e[1];i=t.backend_util.mergeRealAndImagArrays(r,s)}else{const e=n.resourceInfo;i=A(await this.getBufferData(e.buffer,e.size),n.dtype)}return this.convertAndCacheOnCPU(e,i),i}readToGPU(e){const n=this.tensorMap.get(e),{values:r,dtype:i,shape:s,resourceInfo:a}=n;if("complex64"===i)throw new Error("Does not support reading buffer for complex64 dtype.");if(null==a)throw null!=r?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const o=a.size,u=this.bufferManager.acquireBuffer(o,a.usage);this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.copyBufferToBuffer(a.buffer,0,u,0,o),this.submitQueue();const l=this.makeTensorInfo(s,i),d=t.engine().makeTensorFromTensorInfo(l);return this.tensorMap.get(l.dataId).resourceInfo={size:o,usage:this.defaultGpuBufferUsage(),buffer:u},{tensorRef:d,buffer:u,bufSize:o}}bufferSync(e){const n=this.readSync(e.dataId);if("string"===e.dtype)try{const r=n.map((e=>t.util.decodeString(e)));return t.buffer(e.shape,e.dtype,r)}catch(e){throw new Error("Failed to decode encoded string bytes into utf-8")}return t.buffer(e.shape,e.dtype,n)}async time(e){this.supportTimeQuery||console.warn("This device doesn't support timestamp-query extension. Start Chrome browser with flag --disable-dawn-features=disallow_unsafe_apis then try again. Otherwise, zero will be shown for the kernel time when profiling mode is enabled. Using performance.now is not workable for webgpu since it doesn't support synchronous data read from GPU.");const n=this.activeTimers,r=[];let i=!1;null==this.programTimersStack?(this.programTimersStack=r,i=!0):this.activeTimers.push(r),this.activeTimers=r,e();const s=t.util.flatten(this.activeTimers.map((e=>e.query))).filter((e=>null!=e)),a=t.util.flatten(this.activeTimers.map((e=>e.name))).filter((e=>null!=e));this.activeTimers=n,i&&(this.programTimersStack=null);const o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null},u=await Promise.all(s);return o.kernelMs=t.util.sum(u),o.getExtraProfileInfo=()=>u.map(((e,t)=>({name:a[t],ms:e}))).map((e=>`${e.name}: ${e.ms}`)).join(", "),this.uploadWaitMs=0,this.downloadWaitMs=0,o}makeTensorInfo(e,n,r){"string"===n&&null!=r&&r.length>0&&t.util.isString(r[0])&&(r=r.map((e=>t.util.encodeString(e))));return{dataId:this.write(r,e,n),shape:e,dtype:n}}tensorToBinding(e){if(!e)return null;const t=this.tensorMap.get(e.dataId);if("texture"in t.resourceInfo){const e=t.resourceInfo;return e.texture instanceof GPUExternalTexture?e.texture:e.texture.createView()}const n=t.resourceInfo;return{offset:0,size:n.size,buffer:n.buffer}}async getQueryTime(e){return this.supportTimeQuery?this.getTimeFromQuerySet(e):0}uploadToGPU(e){const n=this.tensorMap.get(e);if(n.resourceInfo)return;const r=T(n.dtype)*t.util.sizeFromShape(n.shape),i=this.bufferManager.acquireBuffer(r,this.defaultGpuBufferUsage());if(n.resourceInfo={size:r,usage:this.defaultGpuBufferUsage(),buffer:i},n.values){const e=this.bufferManager.acquireUploadBuffer(r,GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC),t=e.getMappedRange();"int32"===n.dtype||"bool"===n.dtype?new Int32Array(t).set(n.values):new Float32Array(t).set(n.values),e.unmap(),this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.copyBufferToBuffer(e,0,i,0,r);const s={size:r,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC,buffer:e};this.stagingPendingDisposal.push(s)}}makeUniforms(e){let n=0,r=0;const i=[];e.forEach((e=>{let s;switch(0===e.data.length&&(e.data=[1]),e.data.length){case 1:s=4;break;case 2:s=8;break;case 3:case 4:case 5:case 6:s=16;break;default:t.util.assert(!1,(()=>`Unsupported ${e.data.length}D shape`))}5!==r&&6!==r||(s=16),n=Math.ceil(n/s)*s,r=e.data.length,i.push(n),n+=4*e.data.length}));const s=new ArrayBuffer(n);e.forEach(((e,t)=>{const n=i[t];"int32"===e.type?new Int32Array(s,n,e.data.length).set(e.data):"uint32"===e.type?new Uint32Array(s,n,e.data.length).set(e.data):new Float32Array(s,n,e.data.length).set(e.data)}));const a=this.bufferManager.acquireBuffer(n,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.queue.writeBuffer(a,0,s,0,n);const o={size:n,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM,buffer:a};return this.uniformPendingDisposal.push(o),{offset:0,size:n,buffer:a}}runWebGPUProgram(e,n,r,i,s){if(s||(s=this.makeTensorInfo(e.outputShape,r)),0===t.util.sizeFromShape(s.shape))return this.tensorMap.get(s.dataId).values=t.util.getTypedArrayFromDType(s.dtype,0),s;this.uploadToGPU(s.dataId),e.dispatch=((e,n)=>{const r=e.limits.maxComputeWorkgroupsPerDimension,i=n.dispatchLayout,s=n.dispatch;if(s.every((e=>e<=r)))return s;t.util.assert(s[0]>r&&void 0===i.y&&void 0===i.z,(()=>"Dispatch size exceeds WebGPU limits in Y or Z dimension."));let a=Math.ceil(Math.sqrt(s[0]));return a>r?(a=Math.ceil(Math.cbrt(s[0])),t.util.assert(a<=r,(()=>"Total dispatch size exceeds WebGPU maximum.")),[a,a,a]):[a,a,1]})(this.device,e);let a=[],o=[];if(!e.isFromPixels){a.push({type:"float32",data:[NaN]}),o=n.concat(s).map((e=>e.shape));const r="int32";o.map((e=>{a.push({type:r,data:e})}));const i=t.util.computeStrides(s.shape);if(a.push({type:r,data:i}),e.size){const n=t.util.sizeFromShape(e.outputShape);a.push({type:r,data:[e.isVec4?n/4:n]})}}const u=n.map(((t,n)=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");return this.uploadToGPU(t.dataId),{dtype:this.tensorMap.get(t.dataId).dtype,shape:t.shape,name:e.variableNames[n]}})),l=function(e,n,r,i){let s=e.shaderKey;if(e.isFromPixels)return s;const a=r.map((e=>e.dtype)).concat(i.dtype),o=r.map((e=>t.backend_util.getBroadcastDims(e.shape,i.shape))),u=r.map((e=>t.util.arraysEqual(e.shape,i.shape))).join("_"),l=o.map((e=>e.join("_"))).join(";"),d=I(e)?"flatDispatch":"";return s+="_"+(e.workGroupSize?e.workGroupSize.join(","):"")+n.map((e=>e.length)).join(",")+a.join(",")+e.variableNames.join(",")+l+u+d,s}(e,o,u,s);let d;l in this.pipelineCache?d=this.pipelineCache[l]:(d=c(this.device,e,u,s),this.pipelineCache[l]=d),i&&(a=[...a,...i]);const h=[this.tensorToBinding(s),...n.map((e=>this.tensorToBinding(e))),this.makeUniforms(a)],p=this.device.createBindGroup({layout:d.getBindGroupLayout(0),entries:h.map(((e,t)=>({binding:t,resource:e})))});this.ensureCommandEncoderReady();const f=this.getComputePass(),m=null!=this.activeTimers;return m&&this.supportTimeQuery&&f.writeTimestamp(this.querySet,0),f.setPipeline(d),f.setBindGroup(0,p),f.dispatchWorkgroups(e.dispatch[0],e.dispatch[1],e.dispatch[2]),m&&this.supportTimeQuery&&f.writeTimestamp(this.querySet,1),this.dispatchNumberInEncoder++,n.forEach((e=>{this.commandQueueOwnedIds.add(e.dataId)})),this.commandQueueOwnedIds.add(s.dataId),t.env().get("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE")<=this.dispatchNumberInEncoder&&this.submitQueue(),m&&this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(this.querySet)}),s}async getTimeFromQuerySet(e){const t=this.bufferManager.acquireBuffer(16,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE),n=this.bufferManager.acquireBuffer(16,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.resolveQuerySet(e,0,2,t,0),this.currentCommandEncoder.copyBufferToBuffer(t,0,n,0,16),this.submitQueue(),await n.mapAsync(GPUMapMode.READ);const r=new BigUint64Array(n.getMappedRange()),i=Number(r[1]-r[0]);return n.unmap(),this.bufferManager.releaseBuffer(n,16,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST),this.bufferManager.releaseBuffer(t,16,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE),i/1e6}shouldExecuteOnCPU(e,n=E){return t.env().getBool("WEBGPU_CPU_FORWARD")&&e.every((e=>null==this.tensorMap.get(e.dataId).resourceInfo&&t.util.sizeFromShape(e.shape)<n))}numDataIds(){return this.tensorMap.numDataIds()-this.tensorDataPendingDisposal.length}dispose(){this.disposed||(this.bufferManager.dispose(),this.textureManager.dispose(),this.disposed=!0)}}var B;N.nextDataId=0,P()&&t.registerBackend("webgpu",(async()=>{t.env().set("CHECK_COMPUTATION_FOR_ERRORS",!1);const e={powerPreference:t.env().get("WEBGPU_USE_LOW_POWER_GPU")?"low-power":"high-performance"},n=await navigator.gpu.requestAdapter(e),r=n.limits,i={},s=n.features.has("timestamp-query");i.requiredLimits={maxComputeWorkgroupStorageSize:r.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:r.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:r.maxStorageBufferBindingSize},s&&(i.requiredFeatures=["timestamp-query"]);const a=await n.requestDevice(i),o=await n.requestAdapterInfo();return new N(a,o)}),3),function(e){e[e.MUL=0]="MUL",e[e.ADD=1]="ADD",e[e.ATAN2=2]="ATAN2",e[e.SUB=3]="SUB",e[e.DIV=4]="DIV",e[e.EQUAL=5]="EQUAL",e[e.GREATER=6]="GREATER",e[e.GREATER_EQUAL=7]="GREATER_EQUAL",e[e.LESS=8]="LESS",e[e.LESS_EQUAL=9]="LESS_EQUAL",e[e.LOGICAL_AND=10]="LOGICAL_AND",e[e.NOT_EQUAL=11]="NOT_EQUAL",e[e.SQUARED_DIFFERENCE=12]="SQUARED_DIFFERENCE",e[e.INT_DIV=13]="INT_DIV",e[e.POW=14]="POW",e[e.PRELU=15]="PRELU",e[e.MAX=16]="MAX",e[e.MIN=17]="MIN",e[e.COMPLEX_MULTIPLY_REAL=18]="COMPLEX_MULTIPLY_REAL",e[e.COMPLEX_MULTIPLY_IMAG=19]="COMPLEX_MULTIPLY_IMAG"}(B||(B={}));const F="\n  if (isNaN.r) {\n    resultTemp.r = valueForNaN;\n  }\n  if (isNaN.g) {\n    resultTemp.g = valueForNaN;\n  }\n  if (isNaN.b) {\n    resultTemp.b = valueForNaN;\n  }\n  if (isNaN.a) {\n    resultTemp.a = valueForNaN;\n  }\n  ",O=`\n  let isNaN = isnanVec4(a) | isnanVec4(b);\n  ${F}\n  `,D=`\n  var resultTemp = vec4<f32>(a != b);\n  let valueForNaN = 1.0;\n  ${O}\n\n  return resultTemp;\n`,G=`\n  let isModRound1Bool = vec4<i32>(round(abs(b) % vec4<f32>(2.0))) == vec4<i32>(1);\n  let isModRound1 = vec4<f32>(isModRound1Bool);\n  let multiplier = sign(a) * isModRound1 + (vec4<f32>(1.0) - isModRound1);\n  var resultTemp = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  let isExpZero = b == vec4<f32>(0.0);\n  if (isExpZero.r) {\n    resultTemp.r = 1.0;\n  }\n  if (isExpZero.g) {\n    resultTemp.g = 1.0;\n  }\n  if (isExpZero.b) {\n    resultTemp.b = 1.0;\n  }\n  if (isExpZero.a) {\n    resultTemp.a = 1.0;\n  }\n  let isNaN = (a < vec4<f32>(0.0)) & (floor(b) < b);\n  let valueForNaN = uniforms.NAN;\n  ${F}\n  return resultTemp;\n  `;function L(e,t,n="uniforms.NAN"){const r=t?O:"\n  if (isnan(a)) { return a; }\n  if (isnan(b)) { return b; }\n  ";return t?`\n    let valueForNaN = ${n};\n    var resultTemp = vec4<f32>(${e}(a, b));\n    `+r+"\n    return resultTemp;\n  ":r+`\n    return ${e}(a, b);\n  `}function U(e,t){switch(e){case B.MUL:return"return a * b;";case B.ADD:return"return a + b;";case B.ATAN2:return L("atan2",t);case B.SUB:return"return a - b;";case B.DIV:return"return a / b;";case B.EQUAL:return t?"return vec4<f32>(a == b);":"return f32(a == b);";case B.GREATER:return t?"return vec4<f32>(a > b);":"return f32(a > b);";case B.GREATER_EQUAL:return t?"return vec4<f32>(a >= b);":"return f32(a >= b);";case B.LESS:return t?"return vec4<f32>(a < b);":"return f32(a < b);";case B.LESS_EQUAL:return t?"return vec4<f32>(a <= b);":"return f32(a <= b);";case B.LOGICAL_AND:return t?"return (vec4<f32>(a >= vec4<f32>(1.0)) *\n  vec4<f32>(b >= vec4<f32>(1.0)));":"return f32(f32(a) >= 1.0 && f32(b) >= 1.0);";case B.NOT_EQUAL:return t?D:"\n  if (isnan(a) || isnan(b)) {\n    return 1.0;\n  }\n  return f32(a != b);\n";case B.SQUARED_DIFFERENCE:return"return (a - b) * (a - b);";case B.INT_DIV:return t?"\n  let ia = vec4<i32>(round(a));\n  let ib = vec4<i32>(round(b));\n  let cond = ib != vec4<i32>(0);\n  var resultTemp = vec4<i32>(0);\n  let s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    resultTemp[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    resultTemp[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    resultTemp[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    resultTemp[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4<f32>(resultTemp);\n  ":"\n  let s = sign(a) * sign(b);\n  let ia = i32(round(a));\n  let ib = i32(round(b));\n  return f32(idiv(ia, ib, s));\n  ";case B.PRELU:return t?"\n  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));\n  return (aLessThanZero * (b * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);\n  ":"if (a < 0.0) { return b * a; }  return a;";case B.MAX:return L("max",t);case B.MIN:return L("min",t);case B.POW:return t?G:"\n  if(a < 0.0 && floor(b) < b) {\n    return uniforms.NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  if (round(abs(b) % 2.0) != 1.0) {\n    return pow(abs(a), b);\n  }\n  return sign(a) * pow(abs(a), b);\n  ";case B.COMPLEX_MULTIPLY_REAL:return"return areal * breal - aimag * bimag;";case B.COMPLEX_MULTIPLY_IMAG:return"return areal * bimag + aimag * breal;";default:throw new Error(`BinaryType ${e} is not implemented!`)}}var M;!function(e){e[e.ABS=0]="ABS",e[e.CEIL=1]="CEIL",e[e.COS=2]="COS",e[e.COSH=3]="COSH",e[e.ELU=4]="ELU",e[e.EXP=5]="EXP",e[e.EXPM1=6]="EXPM1",e[e.FLOOR=7]="FLOOR",e[e.IS_NAN=8]="IS_NAN",e[e.LINEAR=9]="LINEAR",e[e.LOG=10]="LOG",e[e.LOGICAL_NOT=11]="LOGICAL_NOT",e[e.NEG=12]="NEG",e[e.RELU=13]="RELU",e[e.RELU6=14]="RELU6",e[e.LEAKYRELU=15]="LEAKYRELU",e[e.RECIPROCAL=16]="RECIPROCAL",e[e.RSQRT=17]="RSQRT",e[e.SIN=18]="SIN",e[e.SINH=19]="SINH",e[e.SIGMOID=20]="SIGMOID",e[e.SQRT=21]="SQRT",e[e.SQUARE=22]="SQUARE",e[e.TANH=23]="TANH",e[e.TO_INT=24]="TO_INT"}(M||(M={}));function W(e,t){switch(e){case M.ABS:return"return abs(a);";case M.COS:return"return cos(a);";case M.COSH:return"\n  let e2x = exp(-a);\n  return (e2x + 1.0 / e2x) / 2.0;\n";case M.CEIL:return"return ceil(a);";case M.ELU:return t?"\n  var resFloat = exp(a) - vec4<f32>(1.0);\n  if (a.r >= 0.0) {\n    resFloat.r = a.r;\n  }\n  if (a.g >= 0.0) {\n    resFloat.g = a.g;\n  }\n  if (a.b >= 0.0) {\n    resFloat.b = a.b;\n  }\n  if (a.a >= 0.0) {\n    resFloat.a = a.a;\n  }\n  return resFloat;\n":"if (a >= 0.0) { return a; }  return (exp(a) - 1.0);";case M.EXP:return"return exp(a);";case M.EXPM1:return"return exp(a) - 1.0;";case M.FLOOR:return"return floor(a);";case M.IS_NAN:return"return f32(isnan(a));";case M.LINEAR:return"return a;";case M.LOG:return"if (a < 0.0) { return uniforms.NAN; }\n  return log(a);";case M.LOGICAL_NOT:return"return f32(!(a >= 1.0));";case M.NEG:return"return -a;";case M.LEAKYRELU:return t?"\n  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));\n  return (aLessThanZero * (uniforms.alpha * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);\n":"if (a < 0.0) { return uniforms.alpha * a; } return a;";case M.RECIPROCAL:return"return 1.0 / a;";case M.RELU:return t?"\n  return select(a, vec4<f32>(0.0), a < vec4<f32>(0.0));\n":"return select(a, 0.0, a < 0.0);";case M.RELU6:return t?"return clamp(a, vec4<f32>(0.0, 0.0, 0.0, 0.0), vec4<f32>(6.0, 6.0, 6.0, 6.0));":"return clamp(a, 0.0, 6.0);";case M.RSQRT:return"return 1.0/sqrt(a);";case M.SIGMOID:return"return 1.0 / (1.0 + exp(-1.0 * a));";case M.SIN:return"return sin(a);";case M.SINH:return"\n  let e2x = exp(a);\n  return (e2x - 1.0 / e2x) / 2.0;\n";case M.SQRT:return"return sqrt(a);";case M.SQUARE:return"return a * a;";case M.TANH:return"\n  let e2x = exp(-2.0 * abs(a));\n  return sign(a) * (1.0 - e2x) / (1.0 + e2x);\n";case M.TO_INT:return"return f32(i32((a)));";default:throw new Error(`BinaryType ${e} is not implemented!`)}}const V=e=>{switch(e){case 1:return"f32";case 2:return"vec2<f32>";case 3:return"vec3<f32>";case 4:return"vec4<f32>";default:throw new Error(`${e}-component is not supported.`)}};function H(e,t=!1,n=!1,r=3){if(null===e)return"";let i="";if("linear"===e)i=W(M.LINEAR);else if("relu"===e)i=W(M.RELU,n);else if("elu"===e)i=W(M.ELU,n);else if("relu6"===e)i=W(M.RELU6,n);else if("prelu"===e)i=U(B.PRELU,n);else if("sigmoid"===e)i=W(M.SIGMOID,n);else{if("leakyrelu"!==e)throw new Error(`Activation ${e} has not been implemented for the WebGPU backend.`);i=W(M.LEAKYRELU,n)}const s=V(n?4:1);let a="";return a=t?`\n      fn activation(a : ${s}, coords : vec${r}<i32>) -> ${s} {\n        let b = getPreluActivationWeightsByOutputCoords(coords);\n        ${i}\n      }`:`\n      fn activation(a : ${s}, coords : vec${r}<i32>) -> ${s} {\n        ${i}\n      }`,a}function q(e,t){return`\n      ${e?"value = value + getBiasByOutputCoords(coords);":""}\n      ${t?"value = activation(value, coords);":""}\n      `}function X(e,n,r,i,s=!1,a=!1,o=!1,u=1){t.util.assert(r&&1===u||!r,(()=>`transposeA ${r} is not compatible with component size ${u}`));const l=`\n      let batch = ${e?"0":"batchIn"};\n      ${r?"value = getA(batch, col, row);":"value = getA(batch, row, col);"}\n\n    `,d=i?"value = getB(batch, col, row);":"value = getB(batch, row, col);";return`\n  fn mm_readA(batchIn: i32, row: i32, colIn: i32) -> ${V(u)} {\n    var value = ${V(u)}(0.0);\n    let col = colIn * ${u};\n    ${s&&o?l:`\n    ${r?"if(row < uniforms.dimAOuter && col < uniforms.dimInner)":"if(row < uniforms.aShape[1] && col < uniforms.aShape[2])"}\n    {\n      ${l}\n    }\n    `}\n    return value;\n  }\n\n  fn mm_readB(batchIn: i32, row: i32, colIn: i32) -> ${V(u)} {\n    let col = colIn * ${u};\n    let batch = ${n?"0":"batchIn"};\n    var value = ${V(u)}(0.0);\n    ${d}\n    return value;\n  }\n  `}function K(e,t,n,r,i,s,a=!1,o=!1,u=!1,l=1){return`\n  ${X(n,r,i,s,a,o,u,l)}\n  fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${V(l)}) {\n    let col = colIn * ${l};\n    ${a&&o?"":"if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)"}\n    {\n      var value = valueIn;\n      let coords = vec3<i32>(batch, row, col);\n      ${q(e,t)}\n      setOutputAtCoords(coords[0], coords[1], coords[2], value);\n    }\n  }\n  `}function j(e,n,r=!1,i=32,s=!1,a=32,o=!1){const u=n[1]*e[1],l=n[0]*e[0],d=r?u:i,h=r?i:u,c=d/n[0],p=i/n[1];return t.util.assert((r&&4===c&&4===e[1]||!r&&(3===c||4===c))&&d%n[0]==0&&i%n[1]==0&&4===e[0],(()=>`If transposeA ${r} is true, innerElementSize ${c} and workPerThread[1] ${e[1]} must be 4.\n          Otherwise, innerElementSize ${c} must be 3 or 4.\n      tileAWidth ${d} must be divisible by workGroupSize[0]${n[0]}. tileInner ${i} must be divisible by workGroupSize[1] ${n[1]}. ColPerThread ${e[0]} must be 4.`)),`\n  var<workgroup> mm_Asub : array<array<vec${c}<f32>, ${d/c}>, ${h}>;\n  var<workgroup> mm_Bsub : array<array<vec4<f32>, ${l/e[0]}>, ${i}>;\n\n  const RowPerThread = ${e[1]};\n  const ColPerThread = ${e[0]};\n  const InnerElementSize = ${c};\n  const TileInner = ${i};\n\n  @compute @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n  fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,\n            @builtin(global_invocation_id) GlobalId : vec3<u32>,\n            @builtin(num_workgroups) NumWorkgroups: vec3<u32>,\n            @builtin(workgroup_id) workgroupId: vec3<u32>) {\n    localId = LocalId;\n    globalId = GlobalId;\n    numWorkgroups = NumWorkgroups;\n\n    let localRow = i32(localId.y);\n    let tileRow = ${o?"0":"localRow * RowPerThread"};\n    let tileCol = i32(localId.x);\n\n    let globalRow = ${o?"0":"i32(globalId.y) * RowPerThread"};\n    let globalCol = i32(globalId.x);\n    let batch = ${s?"0":"i32(globalId.z)"};\n    let globalRowStart = i32(workgroupId.y) * ${u};\n\n    let numTiles = ${s?`${Math.ceil(a/i)}`:"(uniforms.dimInner - 1) / TileInner + 1"};\n    var kStart = ${s?`i32(globalId.z) * ${a}`:"0"};\n\n    var acc: array<vec4<f32>, RowPerThread>;\n\n    // Loop over shared dimension.\n    let tileRowB = localRow * ${p};\n    for (var t = 0; t < numTiles; t = t + 1) {\n        // Load one tile of A into local memory.\n        for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {\n            let inputRow = tileRow + innerRow;\n            let inputCol = tileCol;\n            ${(e=>e?"\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          kStart + inputRow,\n          globalRowStart / InnerElementSize + inputCol);\n        ":"\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          globalRow + innerRow,\n          kStart / InnerElementSize + inputCol);\n        ")(r)}\n        }\n\n        // Load one tile of B into local memory.\n        for (var innerRow = 0; innerRow < ${p}; innerRow = innerRow + 1) {\n            let inputRow = tileRowB + innerRow;\n            let inputCol = tileCol;\n            mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol);\n        }\n        kStart = kStart + TileInner;\n        workgroupBarrier();\n\n        // Compute acc values for a single thread.\n        for (var k = 0; k < TileInner / InnerElementSize; k = k + 1) {\n            let BCached0 = mm_Bsub[k * InnerElementSize][tileCol];\n            let BCached1 = mm_Bsub[k * InnerElementSize + 1][tileCol];\n            let BCached2 = mm_Bsub[k * InnerElementSize + 2][tileCol];\n            ${3===c?"":"let BCached3 = mm_Bsub[k * InnerElementSize + 3][tileCol];"}\n\n            ${((e,t)=>e?`\n        let ACached0 = mm_Asub[k * InnerElementSize][localRow];\n        let ACached1 = mm_Asub[k * InnerElementSize + 1][localRow];\n        let ACached2 = mm_Asub[k * InnerElementSize + 2][localRow];\n        ${3===t?"":"let ACached3 = mm_Asub[k * InnerElementSize + 3][localRow];"}\n        for (var i = 0; i < RowPerThread; i = i + 1) {\n          acc[i] = BCached0 * ACached0[i] + acc[i];\n          acc[i] = BCached1 * ACached1[i] + acc[i];\n          acc[i] = BCached2 * ACached2[i] + acc[i];\n          ${3===t?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}\n        }`:`\n        for (var i = 0; i < RowPerThread; i = i + 1) {\n          let ACached = mm_Asub[tileRow + i][k];\n          acc[i] = BCached0 * ACached.x + acc[i];\n          acc[i] = BCached1 * ACached.y + acc[i];\n          acc[i] = BCached2 * ACached.z + acc[i];\n          ${3===t?"":"acc[i] = BCached3 * ACached.w + acc[i];"}\n        }`)(r,c)}\n        }\n\n        workgroupBarrier();\n    }\n\n    for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {\n        mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);\n    }\n  }`}const Y=e=>e?"\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          kStart + inputRow,\n          globalRowStart + inputCol);\n        ":"\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          globalRowStart + inputRow,\n          kStart + inputCol);\n        ";function Q(e,n,r=!1,i=32,s=!1,a=32,o=!1){const u=e[1]*n[1],l=e[0]*n[0],d=r?u:i,h=r?i:u;t.util.assert(h%n[1]==0&&d%n[0]==0&&i%n[1]==0,(()=>`tileAHight ${h} must be divisible by workGroupSize[1]${n[1]}, tileAWidth ${d} must be divisible by workGroupSize[0]${n[0]}, tileInner ${i} must be divisible by workGroupSize[1]${n[1]}`));const c=h/n[1],p=d/n[0],f=i/n[1],m=o?`\n      let localRow = i32(localId.y);\n      let localCol = i32(localId.x);\n      let globalRowStart = i32(workgroupId.y) * ${u};\n      let globalColStart = i32(workgroupId.x) * ${l};\n\n      // Loop over shared dimension.\n      for (var t = 0; t < numTiles; t = t + 1) {\n        // Load one tile of A into local memory.\n        for (var inputRow = localRow; inputRow < ${h}; inputRow = inputRow + ${n[1]}) {\n          for (var inputCol = localCol; inputCol < ${d}; inputCol = inputCol + ${n[0]}) {\n            ${Y(r)}\n          }\n        }\n        // Load one tile of B into local memory.\n        for (var inputRow = localRow; inputRow < ${i}; inputRow = inputRow + ${n[1]}) {\n              for (var inputCol = localCol; inputCol < ${l}; inputCol = inputCol + ${n[0]}) {\n            mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n              kStart + inputRow,\n              globalColStart + inputCol);\n          }\n        }\n        kStart = kStart + TileInner;\n        workgroupBarrier();\n\n        // Compute acc values for a single thread.\n        var BCached : array<f32, ColPerThread>;\n        for (var k = 0; k < TileInner; k = k + 1) {\n          for (var inner = 0; inner < ColPerThread; inner = inner + 1) {\n            BCached[inner] = mm_Bsub[k][localCol + inner * ${n[0]}];\n          }\n          for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {\n            let ACached = ${r?`mm_Asub[k][localRow + innerRow * ${n[1]}];`:`mm_Asub[localRow + innerRow * ${n[1]}][k];`}\n            for (var innerCol = 0; innerCol < ColPerThread; innerCol = innerCol + 1) {\n              acc[innerRow][innerCol] = acc[innerRow][innerCol] +\n                  ACached * BCached[innerCol];\n            }\n          }\n        }\n        workgroupBarrier();\n      }\n      for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {\n        let gRow = globalRowStart + localRow + innerRow * ${n[1]};\n        for (var innerCol = 0; innerCol < ColPerThread; innerCol = innerCol + 1) {\n          let gCol = globalColStart + localCol + innerCol * ${n[0]};\n          mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);\n        }\n      }\n      `:`\n  let tileRow = i32(localId.y) * RowPerThread;\n  let tileCol = i32(localId.x) * ColPerThread;\n\n  let globalRow = i32(globalId.y) * RowPerThread;\n  let globalCol = i32(globalId.x) * ColPerThread;\n  let globalRowStart = i32(workgroupId.y) * ${u};\n\n  let tileRowA = i32(localId.y) * ${c};\n  let tileColA = i32(localId.x) * ${p};\n  let tileRowB = i32(localId.y) * ${f};\n  // Loop over shared dimension.\n  for (var t = 0; t < numTiles; t = t + 1) {\n    // Load one tile of A into local memory.\n    for (var innerRow = 0; innerRow < ${c}; innerRow = innerRow + 1) {\n      for (var innerCol = 0; innerCol < ${p}; innerCol = innerCol + 1) {\n        let inputRow = tileRowA + innerRow;\n        let inputCol = tileColA + innerCol;\n        ${Y(r)}\n      }\n    }\n\n    // Load one tile of B into local memory.\n    for (var innerRow = 0; innerRow < ${f}; innerRow = innerRow + 1) {\n      for (var innerCol = 0; innerCol < ColPerThread; innerCol = innerCol + 1) {\n        let inputRow = tileRowB + innerRow;\n        let inputCol = tileCol + innerCol;\n        mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n          kStart + inputRow,\n          globalCol + innerCol);\n      }\n    }\n    kStart = kStart + TileInner;\n    workgroupBarrier();\n\n    // Compute acc values for a single thread.\n    var BCached : array<f32, ColPerThread>;\n    for (var k = 0; k < TileInner; k = k + 1) {\n      for (var inner = 0; inner < ColPerThread; inner = inner + 1) {\n        BCached[inner] = mm_Bsub[k][tileCol + inner];\n      }\n\n      for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {\n        ${(e=>e?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];")(r)}\n        for (var innerCol = 0; innerCol < ColPerThread; innerCol = innerCol + 1) {\n          acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];\n        }\n      }\n    }\n\n    workgroupBarrier();\n  }\n\n  for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < ColPerThread; innerCol = innerCol + 1) {\n      mm_write(batch, globalRow + innerRow, globalCol + innerCol,\n          acc[innerRow][innerCol]);\n    }\n  }\n  `;return`\n    var<workgroup> mm_Asub : array<array<f32, ${d}>, ${h}>;\n    var<workgroup> mm_Bsub : array<array<f32, ${l}>, ${i}>;\n    const RowPerThread = ${e[1]};\n    const ColPerThread = ${e[0]};\n    const TileInner = ${i};\n\n    @compute @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n    fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,\n              @builtin(global_invocation_id) GlobalId : vec3<u32>,\n              @builtin(num_workgroups) NumWorkgroups: vec3<u32>,\n              @builtin(workgroup_id) workgroupId: vec3<u32>) {\n      localId = LocalId;\n      globalId = GlobalId;\n      numWorkgroups = NumWorkgroups;\n\n      let batch = ${s?"0":"i32(globalId.z)"};\n      let numTiles = ${s?`${Math.ceil(a/i)}`:"(uniforms.dimInner - 1) / TileInner + 1"};\n      var kStart = ${s?`i32(globalId.z) * ${a}`:"0"};\n\n      var acc : array<array<f32, ColPerThread>, RowPerThread>;\n\n      // Without this initialization strange values show up in acc.\n      for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {\n        for (var innerCol = 0; innerCol < ColPerThread; innerCol = innerCol + 1) {\n          acc[innerRow][innerCol] = 0.0;\n        }\n      }\n      ${m}\n    }\n  `}class Z{constructor(e,t,n,r,i=!1,s=!1,a=null,o=null,u=null,l=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=t,this.dispatchLayout={x:[2],y:[1],z:[0]};const d=i?e[1]:e[2];if(this.isVec4=(d%4==0&&!i||t[1]%4==0&&i)&&t[2]%4==0&&!s,this.isVectorA=1===t[1]&&!i,!this.isVec4&&this.isVectorA)this.elementsPerThread=[1,1,1],this.workGroupSize=[32,1,1];else{const e=v(t[1],d,t[2],i);this.workGroupSize=e.workGroupSize,this.elementsPerThread=e.elementsPerThread}this.dispatch=S(this.dispatchLayout,this.outputShape,this.workGroupSize,this.elementsPerThread);const h=null!=a,c=null!=u;h&&this.variableNames.push("bias"),c&&this.variableNames.push("preluActivationWeights"),this.sequentialAccessByThreads=l,this.transposeA=i,this.transposeB=s,this.addBias=h,this.activation=o,this.hasPreluActivationWeights=c,this.batchAEqualOne=n,this.batchBEqualOne=r,[this.fitAOuter,this.fitBOuter,this.fitInner]=this.getShapeFit(t[1],t[2],d),this.shaderKey=`matMulPacked_${this.elementsPerThread}_${i}_${s}_${this.activation}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.isVectorA}_${this.batchAEqualOne}_${this.batchBEqualOne}_${this.sequentialAccessByThreads}`}getShapeFit(e,t,n){const r=this.workGroupSize[1]*this.elementsPerThread[1],i=this.workGroupSize[0]*this.elementsPerThread[0];!this.isVec4&&this.isVectorA?this.tileInner=4*this.workGroupSize[0]:this.tileInner=i;return[e%r==0,t%i==0,n%this.tileInner==0]}getUserCode(){const e=`\n      ${H(this.activation,this.hasPreluActivationWeights,this.isVec4)}\n      ${K(this.addBias,this.activation,this.batchAEqualOne,this.batchBEqualOne,!1,this.transposeB,this.fitAOuter,this.fitBOuter,this.fitInner,this.isVec4?4:1)}\n      ${this.isVec4?j(this.elementsPerThread,this.workGroupSize,this.transposeA,this.tileInner,!1,null,this.isVectorA):this.isVectorA?function(e,n=!1){return t.util.assert(1===e[1]&&1===e[2],(()=>`A linear work group size is required. But got ${e}.`)),`\n    const TileSize = ${4*e[0]};\n    var<workgroup> mm_Asub : array<vec4<f32>, ${e[0]}>;\n\n    ${m()} {\n      let tileCol = i32(localId.x);\n      let globalCol = i32(globalId.x);\n      let globalRow = i32(globalId.y);\n\n      let numTiles = (uniforms.dimInner - 1) / TileSize + 1;\n      let batch = i32(globalId.z);\n      // Without this initialization strange values show up in acc.\n      var acc = 0.0;\n\n      // Loop over shared dimension.\n      for (var t = 0; t < numTiles; t = t + 1) {\n        // Load one tile of A into local memory.\n        let colA = t * TileSize + tileCol * 4;\n        mm_Asub[tileCol] = vec4<f32>(${(e=>e?"\n      mm_readA(batch, colA, globalRow),\n      mm_readA(batch, colA + 1, globalRow),\n      mm_readA(batch, colA + 2, globalRow),\n      mm_readA(batch, colA + 3, globalRow)\n  ":"\n      mm_readA(batch, globalRow, colA),\n      mm_readA(batch, globalRow, colA + 1),\n      mm_readA(batch, globalRow, colA + 2),\n      mm_readA(batch, globalRow, colA + 3)\n  ")(n)});\n        workgroupBarrier();\n\n        // Compute acc values for a single thread.\n        for (var k = 0; k < TileSize / 4; k = k + 1) {\n          let rowB = t * TileSize + k * 4;\n          let BCached = vec4<f32>(mm_readB(batch, rowB, globalCol),\n                              mm_readB(batch, rowB + 1, globalCol),\n                              mm_readB(batch, rowB + 2, globalCol),\n                              mm_readB(batch, rowB + 3, globalCol));\n\n          let ACached = mm_Asub[k];\n          acc = acc + dot(ACached, BCached);\n        }\n\n        workgroupBarrier();\n      }\n\n      mm_write(batch, globalRow, globalCol, acc);\n    }\n  `}(this.workGroupSize,this.transposeA):Q(this.elementsPerThread,this.workGroupSize,this.transposeA,this.tileInner,!1,null,this.sequentialAccessByThreads)}\n    `;return e}}class J{constructor(e,t,n,r=!1,i=!1,s=null,a=null,o=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workGroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout={x:[],y:[1,2],z:[0]},this.dispatch=S(this.dispatchLayout,this.outputShape,this.workGroupSize);const u=null!=s,l=null!=o;u&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),this.transposeA=r,this.transposeB=i,this.addBias=u,this.activation=a,this.hasPreluActivationWeights=l,this.batchAEqualOne=t,this.batchBEqualOne=n,this.shaderKey=`matMulReduce_${this.activation}_${r}_${i}_${this.batchAEqualOne}_${this.batchBEqualOne}`}getUserCode(){return`\n      ${H(this.activation,this.hasPreluActivationWeights)}\n      ${K(this.addBias,this.activation,this.batchAEqualOne,this.batchBEqualOne,this.transposeA,this.transposeB)}\n      \n    var<workgroup> sumValues : array<f32, workGroupSizeX>;\n    ${m()} {\n      let coords = getOutputCoords();\n      let batch = coords[0];\n      let row = coords[1];\n      let col = coords[2];\n      var sum = 0.0;\n      let Length = uniforms.dimInner;\n      for (var k = i32(localId.x); k < Length; k = k + i32(workGroupSizeX)) {\n        let dataA = mm_readA(batch, row, k);\n        let dataB = mm_readB(batch, k, col);\n        sum = sum + dataA * dataB;\n      }\n      sumValues[localId.x] = sum;\n      workgroupBarrier();\n\n      for(var currentSize = workGroupSizeX / 2u; currentSize > 1u;\n          currentSize = currentSize / 2u) {\n        if (localId.x < currentSize)\n        {\n          sumValues[localId.x] = sumValues[localId.x] + sumValues[localId.x + currentSize];\n        }\n        workgroupBarrier();\n      }\n\n      if (localId.x == 0u) {\n        sum = sumValues[0] + sumValues[1];\n        mm_write(batch, row, col, sum);\n      }\n    }\n  \n    `}}class ee{constructor(e,t,n,r=!1,i=!1,s=null,a=null,o=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workGroupSize=[16,8,1],this.outputShape=n,this.dispatchLayout={x:[2],y:[1],z:[0]},this.dispatch=[Math.ceil(n[2]/this.workGroupSize[0]),Math.ceil(n[1]/this.workGroupSize[1]),n[0]];const u=null!=s;u&&this.variableNames.push("bias");const l=null!=o;l&&this.variableNames.push("preluActivationWeights"),this.transposeA=r,this.transposeB=i,this.addBias=u,this.activation=a,this.hasPreluActivationWeights=l,this.batchAEqualOne=1===e[0],this.batchBEqualOne=1===t[0],this.shaderKey=`matMulSmallOutputSize_${this.activation}_${r}_${i}_${this.batchAEqualOne}_${this.batchBEqualOne}`}getUserCode(){return`\n      ${H(this.activation,this.hasPreluActivationWeights)}\n      ${K(this.addBias,this.activation,this.batchAEqualOne,this.batchBEqualOne,this.transposeA,this.transposeB)}\n      ${function(e){const t=e[1],n=e[0],r=t>n?t:n;return`\n  var<workgroup> mm_Asub : array<array<f32, ${r}>, ${t}>;\n  var<workgroup> mm_Bsub : array<array<f32, ${n}>, ${r}>;\n\n  // If the output size is small for matrix multiplication, avoid to use vec4\n  // and handle some elements per thread to optimally utilize the ALU.\n  // Read data from global memory to registers firstly, then store them into\n  // shared memory, so it is instruction-Level parallelism for arithmetic\n  // operations and others handle IO operations between barrier api, makes ALU\n  // and load/store units work simultaneously, could improves the performance.\n  ${m()} {\n    let tileRow = i32(localId.y);\n    let tileCol = i32(localId.x);\n    let globalRow = i32(globalId.y);\n    let globalCol = i32(globalId.x);\n    let batch = i32(globalId.z);\n\n    // uniforms.dimInner should be greater than 0.\n    let numTiles = (uniforms.dimInner - 1) / ${r} + 1;\n    var acc = 0.0;\n\n    var globalColA = tileCol;\n    var globalRowB = 0;\n    var regA = mm_readA(batch, globalRow, globalColA);\n    var regB0 = mm_readB(batch, globalRowB + 2 * tileRow, globalCol);\n    var regB1 = mm_readB(batch, globalRowB + 2 * tileRow + 1, globalCol);\n    globalColA = globalColA + ${r};\n    globalRowB = globalRowB + ${r};\n\n    for (var t = 0; t < numTiles; t = t + 1) {\n      mm_Asub[tileRow][tileCol] = regA;\n      mm_Bsub[2 * tileRow][tileCol] = regB0;\n      mm_Bsub[2 * tileRow + 1][tileCol] = regB1;\n\n      workgroupBarrier();\n\n      regA = mm_readA(batch, globalRow, globalColA);\n      regB0 = mm_readB(batch, globalRowB + 2 * tileRow, globalCol);\n      regB1 = mm_readB(batch, globalRowB + 2 * tileRow + 1, globalCol);\n      globalColA = globalColA + ${r};\n      globalRowB = globalRowB + ${r};\n\n      for (var k = 0; k < ${r}; k = k + 1) {\n        acc = acc + mm_Asub[tileRow][k] * mm_Bsub[k][tileCol];\n      }\n      workgroupBarrier();\n    }\n\n    mm_write(batch, globalRow, globalCol, acc);\n  }\n  `}(this.workGroupSize)}\n    `}}class te{constructor(e,n,r,i,s=!1,a=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workGroupSize=[8,8,1],this.atomic=!0,this.isVec4=!1,this.splitedDimInner=128,t.util.assert(1===e[0],(()=>"MatMulSplitKProgram only supports batch = 1.")),this.outputShape=e,this.dispatchLayout={x:[2],y:[1],z:[0,3]},this.isVec4=(s&&this.outputShape[1]%4==0||!s&&n%4==0)&&this.outputShape[2]%4==0,this.elementsPerThread=[4,4,this.splitedDimInner],this.isVec4||(this.outputShape[1]<16&&(this.elementsPerThread[1]=1),this.outputShape[2]<16&&(this.elementsPerThread[0]=1)),this.dispatch=S(this.dispatchLayout,[this.outputShape[0],this.outputShape[1],this.outputShape[2],n],this.workGroupSize,this.elementsPerThread),this.transposeA=s,this.transposeB=a,this.batchAEqualOne=r,this.batchBEqualOne=i,this.shaderKey=`matMulSplitK_${s}_${a}_${r}_${i}_${this.elementsPerThread}_${this.isVec4}`}getUserCode(){const e=this.isVec4?4:1,t=`\n      ${X(this.batchAEqualOne,this.batchBEqualOne,!1,this.transposeB,!1,!1,!1,e)}\n      fn mm_write(batch: i32, row : i32, colIn : i32, value : ${V(e)}) {\n        let col = colIn * ${e};\n        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {\n          let coords = vec3<i32>(batch, row, col);\n          let flatIndex = getOutputIndexFromCoords(coords);\n          // The problem is that we should initialize output to zero before using.\n          // Otherwise, the original value will be added to the result.\n          ${(e=>`\n      for (var i = 0; i < ${e}; i = i + 1)\n      {\n        var oldValue = atomicLoad(&(result[flatIndex + i]));\n        var exchanged = false;\n        for (; !exchanged;) {\n          let newValueF32 = bitcast<f32>(oldValue) + ${e>1?"value[i]":"value"};\n          let newValue = bitcast<i32>(newValueF32);\n          let res = atomicCompareExchangeWeak(&(result[flatIndex + i]), oldValue, newValue);\n          oldValue = res.old_value;\n          exchanged = res.exchanged;\n        }\n      }\n      `)(e)}\n        }\n      }\n      ${this.isVec4?j(this.elementsPerThread,this.workGroupSize,this.transposeA,32,!0,this.splitedDimInner):Q(this.elementsPerThread,this.workGroupSize,this.transposeA,32,!0,this.splitedDimInner)}\n    `;return t}}class ne{constructor(e,t=null,n=null,r=null){this.uniforms="",this.variableNames=["x"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=R(this.outputShape),this.dispatch=S(this.dispatchLayout,this.outputShape,this.workGroupSize),this.addBias=null!=t,this.hasPreluActivationWeights=null!=r,this.activation=n,this.addBias&&this.variableNames.push("bias"),this.hasPreluActivationWeights&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`biasActivation_${n}`}getUserCode(){return`\n    ${H(this.activation,this.hasPreluActivationWeights)}\n    ${m("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        var value = getXByOutputIndex(index);\n        ${q(this.addBias,this.activation)}\n        setOutputAtIndex(index, value);\n      }\n    }\n    `}}class re{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="value : f32,",this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=R(this.outputShape),this.dispatch=S(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="fill"}getUserCode(){return`\n    ${m("index")} {\n      if (index < uniforms.size) {\n        setOutputAtIndex(index, uniforms.value);\n      }\n    }\n  `}}function ie(e){const{backend:n,attrs:r}=e,{shape:i,value:s}=r;let{dtype:a}=r;if(a=a||t.util.inferDtype(s),"string"===a){const e=t.util.getArrayFromDType(a,t.util.sizeFromShape(i));return e.fill(s),n.makeTensorInfo(i,a,e)}{const e=new re(i),t=[{type:"float32",data:[s]}];return n.runWebGPUProgram(e,[],a,t)}}const se={kernelName:t.Fill,backendName:"webgpu",kernelFunc:ie};function ae(e){const{inputs:n,attrs:r}=e,{x:i}=n,{shape:s}=r,a=t.util.sizeFromShape(i.shape),o=t.util.inferFromImplicitShape(s,a),u=t.util.sizeFromShape(o);return t.util.assert(a===u,(()=>`The new shape (${o}) has ${u} elements and the old shape (${i.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`)),e.backend.incRef(i.dataId),{dataId:i.dataId,shape:o,dtype:i.dtype}}const oe={kernelName:t.Reshape,backendName:"webgpu",kernelFunc:ae};function ue({a:e,b:n,transposeA:r,transposeB:i,backend:s,bias:a=null,preluActivationWeights:o=null,leakyreluAlpha:u=0,activation:l=null}){const d=e.shape.length,h=n.shape.length,c=r?e.shape[d-2]:e.shape[d-1],p=i?n.shape[h-1]:n.shape[h-2],f=r?e.shape[d-1]:e.shape[d-2],m=i?n.shape[h-2]:n.shape[h-1],g=e.shape.slice(0,-2),b=n.shape.slice(0,-2),x=t.util.sizeFromShape(g),w=t.util.sizeFromShape(b),I=t.broadcast_util.assertAndGetBroadcastShape(e.shape.slice(0,-2),n.shape.slice(0,-2)).concat([f,m]);t.util.assert(c===p,(()=>`Error in matMul: inner shapes (${c}) and (${p}) of Tensors with shapes ${e.shape} and ${n.shape} and transposeA=${r} and transposeB=${i} must match.`));const k=r?[x,c,f]:[x,f,c],y=i?[w,m,p]:[w,p,m],S=ae({inputs:{x:e},backend:s,attrs:{shape:k}}),v=ae({inputs:{x:n},backend:s,attrs:{shape:y}}),C=[S,v],$=Math.max(x,w),R=1===x,T=1===w,A=[S,v],P=[{type:"int32",data:[f]},{type:"int32",data:[m]},{type:"int32",data:[c]}];let _,E;const N=[$,f,m];let B=t.env().get("WEBGPU_MATMUL_PROGRAM_TYPE");switch(B<0&&(B=f*m<=128?z.MatMulReduceProgram:1===$&&f<=128&&m<=48&&p>=2e3?z.MatMulSplitKProgram:f<=16&&(m<=512||p>=2*m)||m<=16&&(f<=512||c>=2*f)?z.MatMulSmallOutputSizeProgram:z.MatMulPackedProgram),B){case z.MatMulReduceProgram:_=new J(N,R,T,r,i,a,l,o);break;case z.MatMulSplitKProgram:if(E=ie({backend:s,attrs:{shape:N,value:0,dtype:e.dtype}}),_=new te(N,p,R,T,r,i),a||l){E=s.runWebGPUProgram(_,A,e.dtype,P,E);const t=new ne(E.shape,a,l,o);let n=null;const r=[E];a&&r.push(a),o&&r.push(o),"leakyrelu"===l&&(n=[{type:"float32",data:[u]}],t.uniforms+=" alpha : f32,");const i=s.runWebGPUProgram(t,r,E.dtype,n);C.push(E);const d=ae({inputs:{x:i},backend:s,attrs:{shape:I}});C.push(i);for(const e of C)s.disposeData(e.dataId);return d}break;case z.MatMulSmallOutputSizeProgram:_=new ee(k,y,N,r,i,a,l,o);break;case z.MatMulPackedProgram:const t=s.adapterInfo.isIntel();_=new Z(k,N,R,T,r,i,a,l,o,t);break;default:throw new Error(`Unsupported MatMulProgramType ${B}.`)}a&&A.push(a),o&&A.push(o),"leakyrelu"===l&&(P.push({type:"float32",data:[u]}),_.uniforms+=" alpha : f32,"),E=s.runWebGPUProgram(_,A,e.dtype,P,E);const F=ae({inputs:{x:E},backend:s,attrs:{shape:I}});C.push(E);for(const e of C)s.disposeData(e.dataId);return F}const le={kernelName:t._FusedMatMul,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:i,b:s,bias:a,preluActivationWeights:o}=t,{transposeA:u,transposeB:l,activation:d,leakyreluAlpha:h}=r;return ue({a:i,b:s,transposeA:u,transposeB:l,backend:n,bias:a,preluActivationWeights:o,leakyreluAlpha:h,activation:d})}};class de{constructor(e,n,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.workGroupSize=[128,1,1],this.size=!0,this.outputShape=t.backend_util.assertAndGetBroadcastShape(n,r),this.dispatchLayout=R(this.outputShape),this.dispatch=S(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey=`binaryOpComplex_${e}`,this.op=e}getUserCode(){return`\n      fn binaryOpComplex(\n          areal : f32, aimag : f32, breal : f32, bimag : f32) -> f32 {\n        ${U(this.op,!1)}\n      }\n\n      ${m("index")} {\n        if(index < uniforms.size) {\n          let areal = getARealByOutputIndex(index);\n          let aimag = getAImagByOutputIndex(index);\n          let breal = getBRealByOutputIndex(index);\n          let bimag = getBImagByOutputIndex(index);\n          setOutputAtIndex(index, binaryOpComplex(areal, aimag, breal, bimag));\n        }\n      }\n    `}}class he{constructor(e,n,r){this.size=!0,this.variableNames=["A","B"],this.outputShape=t.backend_util.assertAndGetBroadcastShape(n,r),this.dispatchLayout=R(this.outputShape),this.op=e,this.useSharedMemoryWithA=n.length<=1&&r.length>1&&n[0]<128,this.useSharedMemoryWithB=r.length<=1&&n.length>1&&r[0]<128,this.useSharedMemoryWithA||this.useSharedMemoryWithB?(this.isVec4=!1,this.lastDimensionSize=this.useSharedMemoryWithB?r[0]:n[0],this.shaderKey=`binary_${this.type}_${e}_${this.lastDimensionSize}_${this.useSharedMemoryWithB}`,this.type="shared",this.workGroupSize=[256,1,1],this.workPerThread=1):(t.util.arraysEqual(n,r)&&t.util.sizeFromShape(n)%4==0?(this.isVec4=!0,this.type="vec4",this.workPerThread=4):(this.isVec4=!1,this.type="plain",this.workPerThread=1),this.shaderKey=`binary_${this.type}_${e}`,this.workGroupSize=[128,1,1]),this.dispatch=S(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1])}getUserCode(){let e;const t=this.isVec4?"vec4<f32>":"f32",n=`\n    fn binaryOperation(a : ${t}, b : ${t}) -> ${t} {\n      ${U(this.op,this.isVec4)}\n    };\n    `;if("shared"===this.type){const t=this.lastDimensionSize>1?`coords[${this.outputShape.length-1}]`:"0",r=this.useSharedMemoryWithB?`let a = getAByOutputIndex(index);\n          let b = sharedBuf[${t}];`:`let a = sharedBuf[${t}];\n          let b = getBByOutputIndex(index);`;e=`\n        ${n}\n        var<workgroup> sharedBuf : array<f32, ${this.lastDimensionSize}>;\n        ${m("index")} {\n          // Fill in the shared memory buffer.\n          let localIndex = i32(localId.x);\n          if(localIndex < ${this.lastDimensionSize}) {\n            sharedBuf[localIndex] = f32(${this.useSharedMemoryWithB?"B":"A"}[localIndex]);\n          }\n          workgroupBarrier();\n\n          if(index < uniforms.size) {\n            let coords = getCoordsFromIndex(index);\n            ${r}\n            setOutputAtIndex(index, binaryOperation(a, b));\n          }\n        }\n        `}else e=`\n       ${n}\n       ${m("index")} {\n         if (index < uniforms.size) {\n           let a = getAByOutputIndex(index);\n           let b = getBByOutputIndex(index);\n           setOutputAtIndex(index, binaryOperation(a, b));\n         }\n       }\n       `;return e}}function ce(e){const{inputs:t}=e,{x:n}=t;return e.backend.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}const pe={kernelName:t.Identity,backendName:"webgpu",kernelFunc:ce};function fe(e){const{inputs:t,backend:n}=e,{real:r,imag:i}=t,s=n.makeTensorInfo(r.shape,"complex64"),a=n.tensorMap.get(s.dataId),o=ce({inputs:{x:r},backend:n}),u=ce({inputs:{x:i},backend:n});return a.complexTensorInfos={real:o,imag:u},s}const me={kernelName:t.Complex,backendName:"webgpu",kernelFunc:fe};class ge{constructor(e,t){this.variableNames=["A"],this.size=!0;this.workGroupSize=[128,1,1],this.outputShape=e,this.dispatchLayout=R(this.outputShape),this.dispatch=S(this.dispatchLayout,this.outputShape,this.workGroupSize),this.op=t,this.shaderKey=`unary_${t}`}getUserCode(){return`\n      fn unaryOperation(a : f32) -> f32 {\n        ${W(this.op,!1)}\n      }\n      ${m("index")} {\n        if (index < uniforms.size) {\n          let a = getAByOutputIndex(index);\n          setOutputAtIndex(index, unaryOperation(a));\n        }\n      }\n      `}}function be({opType:e,cpuKernelImpl:t,dtype:n}){return({inputs:r,backend:i})=>{const{x:s}=r,a=i,o=n||s.dtype;if(a.shouldExecuteOnCPU([s])&&null!=t){const e=a.tensorMap.get(s.dataId),n=t(e.values,o);return a.makeTensorInfo(s.shape,o,n)}const u=new ge(s.shape,e);return a.runWebGPUProgram(u,[s],o)}}function xe({opType:e,cpuKernelImpl:n,supportsComplex:r=!1,dtype:i}){return({inputs:s,backend:a})=>{const{a:o,b:u}=s,l=a;if(r&&"complex64"===o.dtype){const n=l.tensorMap.get(o.dataId),r=l.tensorMap.get(u.dataId);let i,s;if(e!==B.MUL)[i,s]=[[n.complexTensorInfos.real,r.complexTensorInfos.real],[n.complexTensorInfos.imag,r.complexTensorInfos.imag]].map((n=>{const[r,i]=n,s={dataId:r.dataId,dtype:r.dtype,shape:o.shape},a={dataId:i.dataId,dtype:i.dtype,shape:u.shape},d=new he(e,o.shape,u.shape);return l.runWebGPUProgram(d,[s,a],t.upcastType(r.dtype,i.dtype))}));else{const e=new de(B.COMPLEX_MULTIPLY_REAL,o.shape,u.shape),t=new de(B.COMPLEX_MULTIPLY_IMAG,o.shape,u.shape),a=[{dataId:n.complexTensorInfos.real.dataId,dtype:n.complexTensorInfos.real.dtype,shape:o.shape},{dataId:n.complexTensorInfos.imag.dataId,dtype:n.complexTensorInfos.imag.dtype,shape:o.shape},{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:u.shape},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:u.shape}];i=l.runWebGPUProgram(e,a,"float32"),s=l.runWebGPUProgram(t,a,"float32")}const a=fe({inputs:{real:i,imag:s},backend:l});return l.disposeData(i.dataId),l.disposeData(s.dataId),a}const d=i||t.upcastType(o.dtype,u.dtype);if(("string"===o.dtype||"string"===u.dtype||l.shouldExecuteOnCPU([o,u]))&&null!=n){const e=l.tensorMap.get(o.dataId).values,r=l.tensorMap.get(u.dataId).values,i="string"===o.dtype?t.backend_util.fromUint8ToStringArray(e):e,s="string"===o.dtype?t.backend_util.fromUint8ToStringArray(r):r,[a,h]=n(o.shape,u.shape,i,s,d);return l.makeTensorInfo(h,d,a)}const h=new he(e,o.shape,u.shape);return l.runWebGPUProgram(h,[o,u],d)}}function we(e){return(n,r,i,s,a)=>{const o=t.backend_util.assertAndGetBroadcastShape(n,r),u=o.length,l=t.util.computeStrides(o),d=t.util.sizeFromShape(o),h=t.util.getTypedArrayFromDType(a,d),c=n.length,p=r.length,f=t.util.computeStrides(n),m=t.util.computeStrides(r),g=t.backend_util.getBroadcastDims(n,o),b=t.backend_util.getBroadcastDims(r,o);if(g.length+b.length===0)for(let t=0;t<h.length;++t)h[t]=e(i[t%i.length],s[t%s.length]);else for(let n=0;n<h.length;++n){const r=t.util.indexToLoc(n,u,l),a=r.slice(-c);g.forEach((e=>a[e]=0));const o=t.util.locToIndex(a,c,f),d=r.slice(-p);b.forEach((e=>d[e]=0));const x=t.util.locToIndex(d,p,m);h[n]=e(i[o],s[x])}return[h,o]}}const Ie=we(((e,t)=>e+t));function ke(e){return(n,r,i)=>{const s=t.util.getTypedArrayFromDType(r,n.length);for(let t=0;t<n.length;++t)s[t]=e(n[t],i);return s}}const ye=ke((e=>Math.ceil(e)));const Se=we(((e,t)=>e===t?1:0)),ve=ke((e=>Math.exp(e))),Ce=ke((e=>Math.expm1(e))),$e=ke((e=>Math.floor(e)));const Re=we(((e,t)=>e>t?1:0)),Te=we(((e,t)=>e>=t?1:0)),Ae=we(((e,t)=>e<t?1:0)),Pe=we(((e,t)=>e<=t?1:0));const ze=ke((e=>Math.log(e)));const _e=we(((e,t)=>Math.max(e,t))),Ee=we(((e,t)=>Math.min(e,t))),Ne=we(((e,t)=>e*t));const Be=we(((e,t)=>e!==t?1:0));function Fe(e,t,n,r){const i=[];let s=0;const a=t.length-1+n.length,o=new Array(a).fill(null).map((()=>[0]));!function(e,t){for(let n=0;n<e.length;++n){const r=e[n],i=n===e.length-1?t:e[n+1].length;if(0===r.length)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>i)throw new Error("Ragged splits must not point past values");for(let e=1;e<r.length;++e)if(r[e-1]>r[e])throw new Error("Ragged splits must be sorted in ascending order")}}(n,r);let u=1;for(let e=0;e<t.length-1;++e){u*=t[e];const n=t[e+1];for(let t=1;t<u+1;++t)o[e].push(t*n)}for(let r=0;r<e.length;++r){let a=e[r],u=e[r]+1;for(let e=0;e<n.length;++e){const r=n[e],i=e+t.length-1;if(i>=0){const e=o[i],t=e[e.length-1]-r[a];for(let e=a;e<u;++e)o[i].push(r[e+1]+t)}a=r[a],u=r[u]}u!==a&&(i.push([a,u]),s+=u-a)}return{outSplits:o,valueSlices:i,numValues:s}}function Oe(e,t){const n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let r=t;r<e.length;r++)n[t-1]*=e[r];return n}function De(e,n,r,i,s){const a=n.slice();a[0]=s;const o=t.util.getArrayFromDType(r,t.util.sizeFromShape(a)),u=e.length;return function(e,t,n,r,i,s){const a=Oe(t,2)[1],o=Oe(s,2)[1];let u=0;for(const t of n)for(let n=t[0];n<t[1];++n){for(let t=0;t<r;++t)i[u*o+t]=e[n*a+t];++u}}(e,n,i,0===u?0:u/n[0],o,a),[o,a]}var Ge=t.backend_util.RowPartitionType;class Le{constructor(e,n,r,i,s,a,o,u,l,d){this.shape=e,this.shapeShape=n,this.values=r,this.valuesShape=i,this.valuesDType=s,this.defaultValue=a,this.defaultValueShape=o,this.rowPartitionValues=u,this.rowPartitionValuesShapes=l,this.rowPartitionTypes=t.backend_util.getRowPartitionTypesHelper(d),this.raggedRank=t.backend_util.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===Ge.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===Ge.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case Ge.VALUE_ROWIDS:return Le.getMaxWidthValueRowID(t);case Ge.ROW_SPLITS:return Le.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${Ge[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const t=e.length;if(0===t||1===t)return 0;let n=0;for(let r=0;r<t-1;++r){const t=e[r+1]-e[r];t>n&&(n=t)}return n}static getMaxWidthValueRowID(e){const t=e.length;if(0===t)return 0;let n=0,r=e[0],i=0;for(let s=1;s<t;++s){const t=e[s];t!==r&&(r=t,i=Math.max(s-n,i),n=s)}return Math.max(t-n,i)}tensorShapeFromTensor(e,t,n=!0){if(0===t.length){if(-1===e[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return Me(e,n)}calculateOutputSize(e){const n=this.valuesShape,r=this.defaultValueShape;t.backend_util.validateDefaultValueShape(r,n);const i=this.tensorShapeFromTensor(this.shape,this.shapeShape),s=t.backend_util.combineRaggedTensorToTensorShapes(this.raggedRank,i,n);s[0]<0&&(s[0]=e);for(let e=1;e<=this.raggedRank;++e)s[e]<0&&(s[e]=this.getMaxWidth(e));return s}calculateFirstParentOutputIndex(e,n,r){const i=Math.min(e,r),s=[];let a=0;for(let e=0;e<i;++e,a+=n)s.push(a);for(let t=i;t<e;++t)s.push(-1);return t.util.assert(s.length===e,(()=>"Final length of result must be equal to firstDimension.")),s}calculateOutputIndexRowSplit(e,t,n,r){const i=e.length,s=[];for(let a=0;a<i-1;++a){const i=e[a+1]-e[a];let o=Math.min(r,i),u=t[a];-1===u&&(o=0);for(let e=0;e<o;++e)s.push(u),u+=n;for(let e=0;e<i-o;++e)s.push(-1)}if(i>0&&s.length!==e[i-1])throw new Error("Invalid row split size.");return s}calculateOutputIndexValueRowID(e,t,n,r){const i=e.length,s=[];if(0===i)return[];let a=0,o=e[0];if(o>=t.length)throw new Error(`Got currentValueRowId=${o}, which is not less than ${t.length}`);let u=t[o];s.push(u);for(let l=1;l<i;++l){const i=e[l];if(i===o)u>=0&&(++a,a<r?u+=n:u=-1);else{if(a=0,o=i,i>=t.length)throw new Error(`Got nextValueRowId=${i} which is not less than ${t.length}`);u=t[i]}s.push(u)}if(s.length!==e.length)throw new Error("Invalid row ids.");return s}calculateOutputIndex(e,t,n,r){const i=this.getRowPartitionTensor(e),s=this.getRowPartitionTypeByDimension(e);switch(s){case Ge.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(i,t,n,r);case Ge.ROW_SPLITS:if(i.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${i.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(i,t,n,r);default:throw new Error(`Unsupported partition type: ${Ge[s]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case Ge.FIRST_DIM_SIZE:return e[0];case Ge.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Ge.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Ge[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),n=this.calculateOutputSize(e),r=new Array(this.raggedRank+1);r[r.length-1]=1;for(let e=r.length-2;e>=0;--e)r[e]=r[e+1]*n[e+1];const i=Me(n,!1),s=t.util.getArrayFromDType(this.valuesDType,t.util.sizeFromShape(i));if(r[0]*n[0]>0){let t=this.calculateFirstParentOutputIndex(e,r[0],n[0]);for(let e=1;e<=this.raggedRank;++e){t=this.calculateOutputIndex(e-1,t,r[e],n[e])}this.setOutput(this.raggedRank,t,s,i)}return[i,s]}setOutput(e,n,r,i){if(0===r.length)return;const s=this.values,a=r;let o=i.slice();o=o.slice(e+1);const u=t.util.sizeFromShape(o),l=n.length;let d=this.defaultValue;if(d.length!==u&&1!==d.length){const e=this.defaultValueShape;t.tidy((()=>{const n=t.reshape(d,e),r=t.broadcastTo(n,o);d=r.dataSync()}))}let h=0,c=0,p=0;for(let e=0;e<=l;++e){let t=e<l?n[e]:-1;if(t!==p){if(c<p){const e=s.subarray(h*u);Ue(a.subarray(c*u),e,(p-c)*u)}if(e>=l){const e=r.length;t=Math.floor(e/u)}if(t>p)if(1===this.defaultValue.length)a.subarray(p*u,t*u).fill(this.defaultValue[0]),p=t;else for(;t>p;){Ue(a.slice(p*u),d,u),++p}t<0?(h=e+1,c=p):(h=e,c=p,p=c+1)}else++p}}}function Ue(e,t,n){for(let r=0;r<n;r++)e[r]=t[r]}function Me(e,t){const n=[];for(let r of e){if(r<0){if(!t)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}n.push(r)}return n}const We=ke((e=>1/Math.sqrt(e)));const Ve=ke((e=>1/(1+Math.exp(-e))));const He=ke((e=>Math.sqrt(e))),qe=we(((e,t)=>{const n=e-t;return n*n}));class Xe{constructor(e,n,r,i,s,a){this.separator=t.util.encodeString(e),this.nGramWidths=n,this.leftPad=t.util.encodeString(r),this.rightPad=t.util.encodeString(i),this.padWidth=s,this.preserveShort=a}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,r,i,s){for(let a=0;a<i;++a){const o=this.getPadWidth(s),u=Math.max(0,o-a),l=Math.max(0,o-(i-(a+1))),d=s-(u+l),h=t+(u>0?0:a-o);let c=0;c+=u*this.leftPad.length;for(let t=0;t<d;++t)c+=e[h+t].length;c+=l*this.rightPad.length;c+=(u+l+d-1)*this.separator.length,n[r+a]=new Uint8Array(c);const p=n[r+a];let f=0;const m=e=>e.forEach((e=>p[f++]=e));for(let e=0;e<u;++e)m(this.leftPad),m(this.separator);for(let t=0;t<d-1;++t)m(e[h+t]),m(this.separator);if(d>0){m(e[h+d-1]);for(let e=0;e<l;++e)m(this.separator),m(this.rightPad)}else{for(let e=0;e<l-1;++e)m(this.rightPad),m(this.separator);m(this.rightPad)}}}compute(e,n){const r=e.length,i=n.length;if(i>0){let e=n[0];if(0!==e)throw new Error(`First split value must be 0, got ${e}`);for(let t=1;t<i;++t){let i=n[t]>=e;if(i=i&&n[t]<=r,!i)throw new Error(`Invalid split value ${n[t]}, must be in [${e}, ${r}]`);e=n[t]}if(e!==r)throw new Error(`Last split value must be data size. Expected ${r}, got ${e}`)}const s=i-1,a=t.util.getArrayFromDType("int32",i);if(0===r||0===i){const e=new Array(r);for(let e=0;e<=s;++e)a[e]=0;return[e,a]}a[0]=0;for(let e=1;e<=s;++e){const t=n[e]-n[e-1];let r=0;this.nGramWidths.forEach((e=>{r+=this.getNumNGrams(t,e)})),this.preserveShort&&t>0&&0===r&&(r=1),a[e]=a[e-1]+r}const o=new Array(a[s]);for(let t=0;t<s;++t){const r=n[t];let i=a[t];if(this.nGramWidths.forEach((s=>{const a=n[t+1]-n[t],u=this.getNumNGrams(a,s);this.createNGrams(e,r,o,i,u,s),i+=u})),this.preserveShort&&i===a[t]){const s=n[t+1]-n[t];if(0===s)continue;const a=s+2*this.padWidth,u=1;this.createNGrams(e,r,o,i,u,a)}}return[o,a]}}function Ke(e,t,n,r){if(!e.length)return;if(0===t.length){for(let t=0;t<e.length;++t)r.push(e.subarray(t,t+1));return}if(1===t.length){const i=t[0];let s=e.indexOf(i);for(;-1!==s;){const t=e.subarray(0,s);n&&0===t.length||r.push(t),s=(e=e.subarray(s+1)).indexOf(i)}return void(n&&0===e.length||r.push(e))}let i=0;for(let s=0;s<e.length+1;s++)if(s===e.length||-1!==t.indexOf(e[s])){const t=e.subarray(i,s);n&&0===t.length||r.push(t),i=s+1}}const je=we(((e,t)=>e-t));const Ye=(e,t)=>{const n=t.value-e.value;return 0===n?e.index-t.index:n};function Qe(e,n,r=0,i=e.length-1){for(;i>r;){if(i-r>600){const t=i-r+1,s=n-r+1,a=Math.log(t),o=.5*Math.exp(2*a/3),u=.5*Math.sqrt(a*o*(t-o)/t)*Math.sign(s-t/2);Qe(e,n,Math.max(r,Math.floor(n-s*o/t+u)),Math.min(i,Math.floor(n+(t-s)*o/t+u)))}const s=e[n];let a=r,o=i;for(t.util.swap(e,r,n),Ye(e[i],s)>0&&t.util.swap(e,r,i);a<o;){for(t.util.swap(e,a,o),a++,o--;Ye(e[a],s)<0;)a+=1;for(;Ye(e[o],s)>0;)o-=1}0===Ye(e[r],s)?t.util.swap(e,r,o):(o+=1,t.util.swap(e,o,i)),o<=n&&(r=o+1),n<=o&&(i=o-1)}}var Ze={__proto__:null,simpleAbsImpl:function(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t},addImpl:Ie,bincountImpl:function(e,n,r,i,s){const a=t.util.sizeFromShape(i),o=t.util.makeZerosTypedArray(s,r);for(let t=0;t<e.length;t++){const r=e[t];if(r<0)throw new Error("Input x must be non-negative!");r>=s||(o[r]+=a>0?n[t]:1)}return o},bincountReduceImpl:function(e,n,r,i=!1){const s=e.shape[0],a=e.shape[1],o=t.buffer([s,r],n.dtype);for(let t=0;t<s;t++)for(let s=0;s<a;s++){const a=e.get(t,s);if(a<0)throw new Error("Input x must be non-negative!");a>=r||(i?o.set(1,t,a):n.size>0?o.set(o.get(t,a)+n.get(t,s),t,a):o.set(o.get(t,a)+1,t,a))}return o},castImpl:function(e,n,r,i){if("int32"===i){return[n,"int32",Int32Array.from(e)]}if("bool"===i){const i=t.util.toTypedArray([0],r),[s,a]=we(((e,t)=>e!==t?1:0))(n,[],e,i,"bool");return[a,"bool",s]}throw new Error(`Error in Cast: failed to cast ${r} to ${i}`)},ceilImpl:ye,concatImpl:function(e,n,r,i){const s=t.util.getArrayFromDType(r,t.util.sizeFromShape(n));if(i&&"string"!==r){let n=0;e.forEach((e=>{const r=t.util.sizeFromShape(e.shape);s.set(e.vals,n),n+=r}))}else{let i=0;e.forEach((e=>{const a="string"===r?t.backend_util.fromUint8ToStringArray(e.vals):e.vals;let o=0;for(let t=0;t<e.shape[0];++t){const r=t*n[1]+i;for(let t=0;t<e.shape[1];++t)s[r+t]=a[o++]}i+=e.shape[1]}))}return s},equalImpl:Se,expImpl:ve,expm1Impl:Ce,floorImpl:$e,gatherNdImpl:function(e,n,r,i,s,a,o,u,l){const d=t.buffer([i,a],r);for(let t=0;t<i;t++){const r=[];let i=0;for(let n=0;n<s;n++){const a=e[t*s+n];i+=a*o[n],r.push(a)}if(i<0||i>=l/a)throw new Error(`Invalid indices: ${r} does not index into ${u}`);for(let e=0;e<a;e++)d.values[t*a+e]=n.get(...n.indexToLoc(i*a+e))}return d},gatherV2Impl:function(e,n,r){const i=t.buffer(r,e.dtype);for(let t=0;t<i.size;++t){const r=i.indexToLoc(t).slice(),s=r[0],a=r[2],o=n.locToIndex([s,a]);r[2]=n.values[o];const u=e.locToIndex(r);0<=u&&u<e.values.length&&(i.values[t]=e.values[u])}return i},greaterImpl:Re,greaterEqualImpl:Te,lessImpl:Ae,lessEqualImpl:Pe,linSpaceImpl:function(e,n,r){const i=(n-e)/(r-1),s=t.util.makeZerosTypedArray(r,"float32");s[0]=e;for(let e=1;e<s.length;e++)s[e]=s[e-1]+i;return s},logImpl:ze,maxImpl:function(e,n,r,i){const s=t.util.getTypedArrayFromDType(i,t.util.sizeFromShape(r));for(let t=0;t<s.length;++t){const r=t*n;let i=e[r];for(let t=0;t<n;++t){const n=e[r+t];(Number.isNaN(n)||n>i)&&(i=n)}s[t]=i}return s},maximumImpl:_e,minimumImpl:Ee,multiplyImpl:Ne,negImpl:function(e,n,r){const i=t.util.createScalarValue(-1,r);return Ne([],n,i,e,r)},notEqualImpl:Be,prodImpl:function(e,n,r,i){const[s,a]=t.backend_util.computeOutAndReduceShapes(e,i),o=t.upcastType(n,"int32"),u=t.util.makeZerosTypedArray(t.util.sizeFromShape(s),o),l=t.util.sizeFromShape(a);for(let e=0;e<u.length;++e){const t=e*l;let n=1;for(let e=0;e<l;++e)n*=r[t+e];u[e]=n}return{outVals:u,outShape:s,outDtype:o}},raggedGatherImpl:function(e,n,r,i,s,a,o,u){if(0===e.length)throw new Error("paramsNestedSplits must be non empty");if(0===n[0].length)throw new Error("Split tensors must not be scalars");if(function(e,n,r){e.forEach(((e,i)=>{if(e<0||e>=r){const s=t.util.indexToLoc(i,n.length,t.util.computeStrides(n)).join(",");throw new Error(`indices[${s}] = ${e} is not in [0, ${r})`)}}))}(a,o,n[0][0]-1),0===i.length)throw new Error("params.rank must be nonzero");const l=i[0],{outSplits:d,valueSlices:h,numValues:c}=Fe(a,o,e,l),p=function(e){const n=[];for(let r=0;r<e.length;++r){const i=e[r].length,s=t.util.getArrayFromDType("int32",i);n.push(s),e[r].forEach(((e,t)=>s[t]=e))}return n}(d),f=De(r,i,s,h,c);return[p,f[0],f[1]]},raggedTensorToTensorImpl:function(e,t,n,r,i,s,a,o,u,l){return new Le(e,t,n,r,i,s,a,o,u,l).compute()},rangeImpl:function(e,n,r,i){if(e===n||e<n&&r<0||n<e&&r>1)return t.util.makeZerosTypedArray(0,i);const s=Math.abs(Math.ceil((n-e)/r)),a=t.util.makeZerosTypedArray(s,i);n<e&&1===r&&(r=-1),a[0]=e;for(let e=1;e<a.length;e++)a[e]=a[e-1]+r;return a},rsqrtImpl:We,scatterImpl:function(e,n,r,i,s,a,o,u,l,d){const h=[i/s,s],c=e.values,p=n.values;if(0===i)return t.buffer(r,n.dtype);const f=t.buffer(h,n.dtype);"string"==typeof l||"number"==typeof l?f.values.fill(l):"boolean"==typeof l&&f.values.fill(+l);for(let e=0;e<a;e++){const t=[];let a=0;for(let n=0;n<o;n++){const r=c[e*o+n];t.push(r),a+=r*u[n]}if(a<0||a>=i/s)throw new Error(`Invalid indices: ${t} does not index into ${r}`);for(let t=0;t<s;t++)d?f.values[a*s+t]+=p[e*s+t]:f.values[a*s+t]=0===n.rank?p[0]:p[e*s+t]}return f},sigmoidImpl:Ve,sliceImpl:function(e,n,r,i,s){const a=t.slice_util.isSliceContinous(i,n,r),o=t.util.sizeFromShape(r),u=t.util.computeStrides(i);if(a){const r=t.slice_util.computeFlatOffset(n,u);return"string"===s?e.slice(r,r+o):e.subarray(r,r+o)}const l="string"===s?t.backend_util.fromUint8ToStringArray(e):e,d=t.buffer(i,s,l),h=t.buffer(r,s);for(let e=0;e<h.size;++e){const t=h.indexToLoc(e),r=t.map(((e,t)=>e+n[t]));h.set(d.get(...r),...t)}return"string"===s?t.backend_util.fromStringArrayToUint8(h.values):h.values},sparseFillEmptyRowsImpl:function(e,n,r,i,s,a,o){const u=n[0],l=a[0],d=new Array(l),h=new Array(u),c=n[1];if(0===l){if(0!==u)throw new Error(t.backend_util.getSparseFillEmptyRowsIndicesDenseShapeMismatch(u));return[t.util.getArrayFromDType(r,0),[0,c],t.util.getArrayFromDType(s,0),d,h]}let p=!0,f=0;const m=new Array(l).fill(0);for(let n=0;n<u;++n){const r=e[n*c];if(r<0)throw new Error(t.backend_util.getSparseFillEmptyRowsNegativeIndexErrorMessage(n,r));if(r>=l)throw new Error(t.backend_util.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(n,r,l));++m[r],p=p&&r>=f,f=r}let g=!0;for(let e=0;e<l;++e){const t=0===m[e];d[e]=t,g=g&&!t,m[e]=Math.max(m[e],1),e>0&&(m[e]+=m[e-1])}if(g&&p){const t=e,n=i;for(let e=0;e<u;++e)h[e]=e;return[t,[u,c],n,d,h]}{const n=m[l-1],a=t.util.getArrayFromDType(r,n*c),p=t.util.getArrayFromDType(s,n),f=new Array(l).fill(0);for(let t=0;t<u;++t){const n=e[t*c],r=f[n],s=(0===n?0:m[n-1])+r;f[n]++;for(let n=0;n<c;++n)a[s*c+n]=e[t*c+n];p[s]=i[t],h[t]=s}for(let e=0;e<l;++e){if(0===f[e]){const t=0===e?0:m[e-1];a[t*c+0]=e;for(let e=1;e<c;++e)a[t*c+e]=0;p[t]=o}}return[a,[n,c],p,d,h]}},sparseReshapeImpl:function(e,n,r,i,s){const a=t.util.sizeFromShape(i),o=n[0],u=s.length,l=[];let d=1,h=-1;for(let e=0;e<u;++e){const n=s[e];if(-1===n){if(-1!==h)throw new Error(t.backend_util.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(h,e));h=e,l.push(1)}else{if(n<0)throw new Error(t.backend_util.getSparseReshapeNegativeOutputDimErrorMessage(e,n));d*=n,l.push(n)}}if(-1!==h){if(d<=0)throw new Error(t.backend_util.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());const e=Math.trunc(a/d);if(d*e!==a)throw new Error(t.backend_util.getSparseReshapeInputOutputMultipleErrorMessage(i,l));l[h]=e}if(t.util.sizeFromShape(l)!==a)throw new Error(t.backend_util.getSparseReshapeInputOutputMismatchErrorMessage(i,l));const c=i.length,p=[];if(c>0){p[c-1]=1;for(let e=c-2;e>=0;--e)p[e]=p[e+1]*i[e+1]}const f=[];if(u>0){f[u-1]=1;for(let e=u-2;e>=0;--e)f[e]=f[e+1]*l[e+1]}const m=t.util.getArrayFromDType(r,o*u);for(let t=0;t<o;++t){let n=0;for(let r=0;r<c;++r)n+=e[t*c+r]*p[r];for(let e=0;e<u;++e)m[t*u+e]=Math.trunc(n/f[e]),n%=f[e]}return[m,[o,u],l]},sparseSegmentReductionImpl:function(e,n,r,i,s,a=!1,o=0){const u=i.length,l=[n[0],e.length/n[0]],d=l[1],h=u>0?s[u-1]+1:0;if(h<0)throw new Error(t.backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());const c=n.slice();c[0]=h;const p=c.reduce(((e,t)=>e*t),1),f=t.util.getArrayFromDType(r,p);if(0===u)return h>0&&f.fill(o),[f,c];if(h<=0)throw new Error(t.backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let m=0,g=1,b=0,x=s[m];for(;;){let n=0;if(g<u){if(n=s[g],x===n){++g;continue}if(x>=n)throw new Error(t.backend_util.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(x<0||x>=h)throw new Error(t.backend_util.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(x,h));x>b&&f.fill(o,b*d,x*d);for(let n=m;n<g;++n){const r=i[n];if(r<0||r>=l[0])throw new Error(t.backend_util.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(n,i[n],l[0]));for(let t=0;t<d;t++)f[x*d+t]+=e[r*d+t]}if(a)for(let e=0;e<d;e++)f[x*d+e]/=g-m;if(m=g,++g,b=x+1,x=n,g>u)break}return b<h&&f.fill(o,b*d,h*d),[f,c]},sqrtImpl:He,squaredDifferenceImpl:qe,stridedSliceImpl:function(e,n,r,i){const s=t.buffer(e,n.dtype);for(let e=0;e<s.size;e++){const t=s.indexToLoc(e),a=new Array(t.length);for(let e=0;e<a.length;e++)a[e]=t[e]*r[e]+i[e];s.set(n.get(...a),...t)}return s},stringNGramsImpl:function(e,t,n,r,i,s,a,o){return new Xe(n,r,i,s,a,o).compute(e,t)},stringSplitImpl:function(e,n,r){const i=e.length,s=[];let a=0,o=0;const u=new Array(i);for(let t=0;t<i;++t){const i=s.length;Ke(e[t],n,r,s);const l=s.length-i;u[t]=l,a+=l,o=Math.max(o,l)}const l=t.util.getArrayFromDType("int32",2*a),d=new Array(a),h=[i,o];let c=0;for(let e=0;e<i;++e)for(let t=0;t<u[e];++t)l[2*c]=e,l[2*c+1]=t,d[c]=s[c],++c;return[l,d,h]},stringToHashBucketFastImpl:function(e,n){const r=t.util.getArrayFromDType("int32",e.length);for(let i=0;i<e.length;++i)r[i]=t.util.fingerPrint64(e[i]).modulo(n).getLowBitsUnsigned();return r},subImpl:je,tileImpl:function(e,n){const r=new Array(e.rank);for(let t=0;t<r.length;t++)r[t]=e.shape[t]*n[t];const i=t.buffer(r,e.dtype);for(let t=0;t<i.values.length;++t){const n=i.indexToLoc(t),r=new Array(e.rank);for(let t=0;t<r.length;t++)r[t]=n[t]%e.shape[t];const s=e.locToIndex(r);i.values[t]=e.values[s]}return i},topKImpl:function(e,n,r,i,s){const a=n[n.length-1],[o,u]=[e.length/a,a],l=t.util.getTypedArrayFromDType(r,o*i),d=t.util.getTypedArrayFromDType("int32",o*i);for(let t=0;t<o;t++){const n=t*u,r=e.subarray(n,n+u);let a=new Array(r.length);r.forEach(((e,t)=>a[t]={value:e,index:t})),i<a.length&&(Qe(a,i),a=a.slice(0,i)),s&&a.sort(Ye);const o=t*i,h=l.subarray(o,o+i),c=d.subarray(o,o+i);for(let e=0;e<i;e++)h[e]=a[e].value,c[e]=a[e].index}const h=n.slice();return h[h.length-1]=i,[t.buffer(h,r,l),t.buffer(h,"int32",d)]},transposeImpl:function(e,n,r,i,s){const a=n.length,o=t.util.sizeFromShape(n),u=t.util.computeStrides(n),l=t.util.computeStrides(s),d=t.util.getTypedArrayFromDType(r,t.util.sizeFromShape(s));for(let n=0;n<o;++n){const r=t.util.indexToLoc(n,a,u),s=new Array(r.length);for(let e=0;e<s.length;e++)s[e]=r[i[e]];d[t.util.locToIndex(s,a,l)]=e[n]}return d},uniqueImpl:function(e,n,r,i){const s=t.util.parseAxisParam(n,r)[0],a=[1,r[0],1];for(let e=0;e<s;e++)a[0]*=r[e];a[1]=r[s];for(let e=s+1;e<r.length;e++)a[2]*=r[e];const o={},u=new Int32Array(r[s]),l=new t.TensorBuffer(a,i,e),d=[],h=1===a[0]&&1===a[2];for(let t=0;t<r[s];t++){let n;if(h)n=e[t].toString();else{const e=[];for(let n=0;n<a[0];n++)for(let r=0;r<a[2];r++)e.push(l.get(n,t,r));n=e.join(",")}if(void 0!==o[n])u[t]=o[n];else{const e=Object.keys(o).length;o[n]=e,u[t]=e,d.push(t)}}const c=a.slice();c[1]=Object.keys(o).length;const p=new t.TensorBuffer(c,i);d.forEach(((e,t)=>{for(let n=0;n<a[0];n++)for(let r=0;r<a[2];r++)p.set(l.get(n,e,r),n,t,r)}));const f=r.slice();return f[s]=c[1],{outputValues:p.values,outputShape:f,indices:u}}};const{addImpl:Je,castImpl:et,ceilImpl:tt,concatImpl:nt,equalImpl:rt,expImpl:it,expm1Impl:st,floorImpl:at,gatherNdImpl:ot,gatherV2Impl:ut,greaterEqualImpl:lt,greaterImpl:dt,lessEqualImpl:ht,lessImpl:ct,logImpl:pt,maxImpl:ft,maximumImpl:mt,minimumImpl:gt,multiplyImpl:bt,negImpl:xt,notEqualImpl:wt,prodImpl:It,rangeImpl:kt,rsqrtImpl:yt,scatterImpl:St,simpleAbsImpl:vt,sliceImpl:Ct,stridedSliceImpl:$t,stringNGramsImpl:Rt,subImpl:Tt,tileImpl:At,topKImpl:Pt,transposeImpl:zt,uniqueImpl:_t}=Ze,Et=be({opType:M.ABS,cpuKernelImpl:vt}),Nt={kernelName:t.Abs,backendName:"webgpu",kernelFunc:Et},Bt=xe({opType:B.ADD,cpuKernelImpl:Je,supportsComplex:!0}),Ft={kernelName:t.Add,backendName:"webgpu",kernelFunc:Bt};class Ot{constructor(e){this.workPerThread=1,this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e[0],this.variableNames=e.map(((e,t)=>`T${t}`)),this.dispatchLayout=R(this.outputShape),this.dispatch=S(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.shaderKey="addN"}getUserCode(){const e=[];this.variableNames.forEach((t=>{e.push(`let v${t} = get${t}ByOutputCoords(coords);`)}));const t=this.variableNames.map((e=>`v${e}`)).join(" + ");return`\n      ${m("index")} {\n        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {\n          let flatIndex = index * ${this.workPerThread} + i;\n          if (flatIndex < uniforms.size) {\n            let coords = getCoordsFromIndex(flatIndex);\n            ${e.join("\n        ")}\n            setOutputAtIndex(flatIndex, ${t});\n          }\n        }\n      }\n    `}}const Dt={kernelName:t.AddN,backendName:"webgpu",kernelFunc:function(e){const{inputs:n,backend:r}=e,i=n;if(1===i.length)return ce({inputs:{x:i[0]},backend:r});const s=i.map((e=>e.dtype)).reduce(((e,n)=>t.upcastType(e,n))),a=i.map((e=>e.shape)),o=new Ot(a);return r.runWebGPUProgram(o,i,s)}};class Gt{constructor(e,n,r){this.workGroupSize=[64,1,1],this.variableNames=["x"],this.uniforms="infinityValue : f32,",this.size=!0;const i=[n];this.op="min"===r?"<":">";const[s,a]=t.backend_util.computeOutAndReduceShapes(e,i);this.outputShape=0===s.length?[1]:s,this.dispatchLayout=R(this.outputShape),t.util.sizeFromShape(a)<32||t.util.sizeFromShape(s)>1e3?(this.type="plain",this.dispatch=S(this.dispatchLayout,this.outputShape,this.workGroupSize)):(this.type="shared",this.dispatch=S(this.dispatchLayout,this.outputShape,[1,1,1])),this.inputShape=e,this.shaderKey=`argMinMax_${this.op}_${this.type}`}getUserCode(){const e=()=>1===this.inputShape.length?"uniforms.xShape":`uniforms.xShape.${f(this.inputShape.length-1)}`,t=()=>{let e="";if(1===this.outputShape.length)1!==this.inputShape.length&&(e+="outputCoords,");else for(let t=0;t<this.outputShape.length;t++)e+=`outputCoords.${f(t)},`;return e};if("shared"===this.type){return`\n      fn DIV_CEIL(a : u32, b : u32) -> u32 {\n        return ((a - 1u) / b + 1u);\n      }\n\n      ${`\n      var<workgroup> xBestIndices : array<i32, ${this.workGroupSize[0]}>;\n      var<workgroup> xBestValues : array<f32, ${this.workGroupSize[0]}>;\n    `}\n\n      ${m("index")} {\n        let outputIndex = index / i32(workGroupSizeX);\n        let reduceLength = ${e()};\n\n        var bestIndex = i32(localId.x);\n        var bestValue = uniforms.infinityValue;\n        let outputCoords = getCoordsFromIndex(outputIndex);\n        for (var k = i32(localId.x); k < reduceLength && outputIndex < uniforms.size;\n            k = k + i32(workGroupSizeX)) {\n          let candidate = getX(${t()} k);\n          if (!isnan(candidate) && candidate ${this.op} bestValue) {\n            bestValue = candidate;\n            bestIndex = k;\n          }\n        }\n        xBestValues[localId.x] = bestValue;\n        xBestIndices[localId.x] = bestIndex;\n        workgroupBarrier();\n\n        var reduceSize = min(u32(reduceLength), workGroupSizeX);\n        for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n            currentSize = reduceSize / 2u) {\n          let interval = DIV_CEIL(reduceSize, 2u);\n          if (localId.x < currentSize) {\n            let candidate = xBestValues[localId.x + interval];\n            if (candidate ${this.op} bestValue) {\n              bestValue = candidate;\n              xBestValues[localId.x] = bestValue;\n              xBestIndices[localId.x] = xBestIndices[localId.x + interval];\n            }\n          }\n          reduceSize = interval;\n          workgroupBarrier();\n        }\n\n        if (localId.x == 0u && outputIndex < uniforms.size) {\n          setOutputAtIndexI32(outputIndex, xBestIndices[localId.x]);\n        }\n      }\n    `}return`\n      ${m("index")} {\n        if (index < uniforms.size) {\n          let outputCoords = getCoordsFromIndex(index);\n          var bestIndex = 0;\n          var bestValue = getX(${t()} 0);\n          let reduceLength = ${e()};\n          for (var i = 1; i < reduceLength; i++) {\n            let candidate = getX(${t()} i);\n            if (candidate ${this.op} bestValue) {\n              bestValue = candidate;\n              bestIndex = i;\n            }\n          }\n          setOutputAtIndexI32(index, bestIndex);\n        }\n      }\n      `}}class Lt{constructor(e,t){this.variableNames=["A"],this.workGroupSize=[16,16,1];const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];this.outputShape=n,this.dispatchLayout={x:[0],y:[1]},this.dispatch=S(this.dispatchLayout,this.outputShape,this.workGroupSize,[1,1,1]),this.shaderKey="transposeShared"}getUserCode(){return`\n      const TILE_DIM = ${this.workGroupSize[0]};\n      var<workgroup> tile : array<array<f32, ${this.workGroupSize[0]+1}>, ${this.workGroupSize[0]}>;\n      \n  @compute @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n\n      fn _start(@builtin(local_invocation_id) localId : vec3<u32>,\n                @builtin(workgroup_id) workgroupId : vec3<u32>) {\n        var x = i32(workgroupId.x) * TILE_DIM + i32(localId.x);\n        var y = i32(workgroupId.y) * TILE_DIM + i32(localId.y);\n        let width = uniforms.outShape[0];\n        let height = uniforms.outShape[1];\n        if (x < width && y < height) {\n          tile[localId.y][localId.x] = A[y * width + x];\n        }\n        workgroupBarrier();\n\n        x = i32(workgroupId.y) * TILE_DIM + i32(localId.x);\n        y = i32(workgroupId.x) * TILE_DIM + i32(localId.y);\n        if (x < height && y < width) {\n          setOutputAtIndex((y * height + x), tile[localId.x]\n            [localId.y]);\n        }\n      }\n    `}}class Ut{constructor(e,t){this.variableNames=["A"],this.workPerThread=1,this.workGroupSize=[64,1,1],this.size=!0;const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];this.outputShape=n,this.dispatchLayout=R(this.outputShape),this.dispatch=S(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.newDim=t,this.shaderKey=`transpose_${t}`}getUserCode(){const e=p(this.outputShape.length),t=function(e){const t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const n=new Array(t);for(let t=0;t<e.length;t++)n[e[t]]=`resRC.${f(t)}`;return n.join()}(this.newDim);return`\n      ${m("index")} {\n        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {\n          let flatIndex = index * ${this.workPerThread} + i;\n          if(flatIndex < uniforms.size) {\n            let resRC = getCoordsFromIndex(flatIndex);\n            setOutputAtIndex(flatIndex, A[getIndexFromCoords${this.outputShape.length}D(\n              ${e}(${t}), uniforms.aShape)]);\n          }\n        }\n      }\n    `}}function Mt(e){const{inputs:n,backend:r,attrs:i}=e,{x:s}=n,{perm:a}=i,o=r,u=s.shape.length,l=new Array(u);for(let e=0;e<l.length;e++)l[e]=s.shape[a[e]];if(r.shouldExecuteOnCPU([s])){const e=o.tensorMap.get(s.dataId).values,t=zt(e,s.shape,s.dtype,a,l);return r.makeTensorInfo(l,s.dtype,t)}if(2===s.shape.length&&t.util.arraysEqual(a,[1,0])){const e=new Lt(s.shape,a);return o.runWebGPUProgram(e,[s],s.dtype)}const d=new Ut(s.shape,a);return o.runWebGPUProgram(d,[s],s.dtype)}const Wt={kernelName:t.Transpose,backendName:"webgpu",kernelFunc:Mt};const Vt={kernelName:t.ArgMax,backendName:"webgpu",kernelFunc:function(e){const{inputs:n,backend:r,attrs:i}=e,{x:s}=n,{axis:a}=i;let o=t.util.parseAxisParam(a,s.shape);const u=t.backend_util.getAxesPermutation(o,s.shape.length);let l=s;const d=[];null!=u&&(l=Mt({inputs:{x:s},backend:r,attrs:{perm:u}}),d.push(l),o=t.backend_util.getInnerMostAxes(o.length,l.shape.length)),t.backend_util.assertAxesAreInnerMostDims("argMax",[o[0]],l.shape.length);const h=new Gt(l.shape,o[0],"max"),c=[{type:"float32",data:[Number.NEGATIVE_INFINITY]}],p=r.runWebGPUProgram(h,[l],"int32",c);return d.forEach((e=>r.disposeData(e.dataId))),p}};const Ht={kernelName:t.ArgMin,backendName:"webgpu",kernelFunc:function(e){const{inputs:n,backend:r,attrs:i}=e,{x:s}=n,{axis:a}=i;let o=t.util.parseAxisParam(a,s.shape);const u=t.backend_util.getAxesPermutation(o,s.shape.length);let l=s;const d=[];null!=u&&(l=Mt({inputs:{x:s},backend:r,attrs:{perm:u}}),d.push(l),o=t.backend_util.getInnerMostAxes(o.length,l.shape.length)),t.backend_util.assertAxesAreInnerMostDims("argMin",[o[0]],l.shape.length);const h=new Gt(l.shape,o[0],"min"),c=[{type:"float32",data:[Number.POSITIVE_INFINITY]}],p=r.runWebGPUProgram(h,[l],"int32",c);return d.forEach((e=>r.disposeData(e.dataId))),p}},qt=xe({opType:B.ATAN2}),Xt={kernelName:t.Atan2,backendName:"webgpu",kernelFunc:qt};class Kt{constructor(e,t){this.variableNames=["x"],this.uniforms="stride : vec2<i32>, pad : vec2<i32>, dilation : vec2<i32>, convDims : vec2<i32>, filterDims : vec2<i32>,",this.workGroupSize=[128,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=R(this.outputShape),this.dispatch=S(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey=`pool2D_${t}`,this.poolType=t}getUserCode(){let e="resultValue = max(value, resultValue);";"avg"===this.poolType&&(e="resultValue = resultValue + value; count = count + 1.0;");let t="resultValue";"avg"===this.poolType&&(t="resultValue / count");return`\n      ${m("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n          let batch = coords[0];\n          let xRCCorner = vec2<i32>(coords.yz) * uniforms.stride - uniforms.pad;\n          let xRCorner = xRCCorner.x;\n          let xCCorner = xRCCorner.y;\n\n          var resultValue = ${"avg"===this.poolType?"0.0":"-1.0 / pow(10.0, -20.0)"};\n          var count = 0.0;\n\n          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilation.x) {\n            let xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= uniforms.convDims.x) {\n              continue;\n            }\n\n            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilation.y) {\n              let xC = xCCorner + wC;\n              if (xC < 0 || xC >= uniforms.convDims.y) {\n                continue;\n              }\n\n              let value = getX(batch, xR, xC, coords[3]);\n              ${e}\n            }\n          }\n\n          setOutputAtIndex(index, ${t});\n        }\n      }\n    `}}class jt{constructor(e){this.variableNames=["x"],this.uniforms="stride : vec2<i32>,",this.workGroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=R(this.outputShape),this.dispatch=S(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="poolWithFilterSizeEqualsOne"}getUserCode(){return`\n      ${m("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let batch = coords[0];\n          let d = coords[3];\n\n          let xRCCorner = coords.yz * uniforms.stride;\n          let xRCorner = xRCCorner.x;\n          let xCCorner = xRCCorner.y;\n\n          let value = getX(batch, xRCorner, xCCorner, d);\n          setOutputAtIndex(index, value);\n        }\n      }\n    `}}class Yt{constructor(e,n){this.workGroupSize=[64,1,1],this.variableNames=["x"],this.uniforms="reduceSize : i32,",this.size=!0,this.inputShape=[e.batchSize,e.inSize];const[r]=t.backend_util.computeOutAndReduceShapes(this.inputShape,[1]);this.outputShape=0===r.length?[1]:r,this.dispatchLayout=R(this.outputShape),this.dispatch=S(this.dispatchLayout,this.outputShape,[1,1,1]),this.reduceType=n,this.shaderKey=`reduce_${n}`}getUserCode(){let e="",t="0.0";"min"===this.reduceType||"max"===this.reduceType?(e=`\n         if (isnan(candidate)) {\n          bestValue = uniforms.NAN;\n         } else if (!isnan(bestValue) && candidate ${"min"===this.reduceType?"<":">"} bestValue)\n           {  bestValue = candidate; }`,t="f32(x[offset])"):"sum"===this.reduceType||"mean"===this.reduceType?e=" bestValue = bestValue + candidate; ":"prod"===this.reduceType&&(e=" bestValue = bestValue * candidate; ",t="1.0");const n="mean"===this.reduceType?"setOutputAtIndex(outputIndex, bestValue / f32(uniforms.reduceSize));":"setOutputAtIndex(outputIndex, bestValue);";return`\n       fn DIV_CEIL(a : u32, b : u32) -> u32 {\n        return ((a - 1u) / b + 1u);\n       }\n\n       ${`\n         var<workgroup> xBestValues : array<f32, ${this.workGroupSize[0]}>;\n       `}\n       fn getOffset(outputIndex : i32) -> i32 {\n         let outputCoords = getCoordsFromIndex(outputIndex);\n         let offset = ${1===this.outputShape.length?"outputCoords":"outputCoords[0]"} * uniforms.reduceSize;\n          return offset;\n       }\n       ${m("index")} {\n         let outputIndex = index / i32(workGroupSizeX);\n         let offset = getOffset(outputIndex);\n         var bestValue = ${t};\n         let Length = uniforms.reduceSize;\n         let WorkPerThread = DIV_CEIL(u32(Length), workGroupSizeX);\n         for (var k = i32(localId.x); k < Length && outputIndex < uniforms.size;\n             k = k + i32(workGroupSizeX)) {\n           let candidate = f32(x[offset + k]);\n           ${e}\n         }\n         xBestValues[localId.x] = bestValue;\n         workgroupBarrier();\n\n         var reduceSize = min(u32(Length), workGroupSizeX);\n         for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n             currentSize = reduceSize / 2u) {\n           let interval = DIV_CEIL(reduceSize, 2u);\n           if (localId.x < currentSize) {\n            let candidate = xBestValues[localId.x + interval];\n            ${e}\n            xBestValues[localId.x] = bestValue;\n           }\n           reduceSize = interval;\n           workgroupBarrier();\n         }\n\n         if (localId.x == 0u && outputIndex < uniforms.size) {\n          ${n}\n        }\n       }\n     `}}function Qt(e,n,r,i,s){const a=e.shape.length,o=[],u=t.util.parseAxisParam(n,e.shape);let l=u;const d=t.backend_util.getAxesPermutation(l,a);let h=e;null!=d&&(h=Mt({inputs:{x:e},attrs:{perm:d},backend:s}),l=t.backend_util.getInnerMostAxes(l.length,a),o.push(h)),t.backend_util.assertAxesAreInnerMostDims(i,l,a);const[c,p]=t.backend_util.computeOutAndReduceShapes(h.shape,l);let f,m=c;if(r&&(m=t.backend_util.expandShapeToKeepDim(c,u)),"max"!==i&&"prod"!==i||!s.shouldExecuteOnCPU([h])){const n=t.util.sizeFromShape(p),r={windowSize:n,inSize:n,batchSize:t.util.sizeFromShape(h.shape)/n,outSize:1},a="mean"===i?"float32":t.sumOutType(e.dtype),u=[{type:"int32",data:[n]}],l=new Yt(r,i),d=s.runWebGPUProgram(l,[h],a,u);o.push(d),f=ae({inputs:{x:d},attrs:{shape:m},backend:s})}else{const n=s.tensorMap.get(h.dataId).values;switch(i){case"max":const r=ft(n,t.util.sizeFromShape(p),m,e.dtype);f=s.makeTensorInfo(m,e.dtype,r);break;case"prod":const{outVals:a,outShape:o,outDtype:u}=It(h.shape,h.dtype,n,l);f=s.makeTensorInfo(o,u,a);break;default:throw new Error(`${i} CPU implementation is not yet supported.`)}}return o.forEach((e=>s.disposeData(e.dataId))),f}function Zt(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{reductionIndices:s,keepDims:a}=r;return Qt(i,s,a,"max",n)}const Jt={kernelName:t.Max,backendName:"webgpu",kernelFunc:Zt};function en(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{keepDims:s,axis:a}=r;return Qt(i,a,s,"mean",n)}const tn={kernelName:t.Mean,backendName:"webgpu",kernelFunc:en};function nn(e,n,r,i){if(1===n.filterWidth&&1===n.filterHeight&&t.util.arraysEqual(n.inShape,n.outShape))return ce({inputs:{x:e},backend:i});if(n.filterWidth===n.inWidth&&n.filterHeight===n.inHeight&&1===n.batchSize&&"VALID"===n.padInfo.type){const s=e.shape.length,a=ae({inputs:{x:e},backend:i,attrs:{shape:[e.shape[s-3]*e.shape[s-2],e.shape[s-1]]}});let o;"avg"===r?o=en({inputs:{x:a},backend:i,attrs:{axis:0,keepDims:!1}}):(t.util.assert("max"===r,(()=>`Invalid pool type ${r}`)),o=Zt({inputs:{x:a},backend:i,attrs:{reductionIndices:0,keepDims:!1}}));const u=ae({inputs:{x:o},backend:i,attrs:{shape:n.outShape}});return i.disposeData(a.dataId),i.disposeData(o.dataId),u}let s;const a=[{type:"int32",data:[n.strideHeight,n.strideWidth]}];return 1===n.filterHeight&&1===n.filterWidth?s=new jt(n):("avg"===r?s=new Kt(n,"avg"):(t.util.assert("max"===r,(()=>`Invalid pool type ${r}`)),s=new Kt(n,"max")),a.push({type:"int32",data:[n.padInfo.top,n.padInfo.left]},{type:"int32",data:[n.dilationHeight,n.dilationWidth]},{type:"int32",data:[n.inHeight,n.inWidth]},{type:"int32",data:[n.effectiveFilterHeight,n.effectiveFilterWidth]})),i.runWebGPUProgram(s,[e],e.dtype,a)}const rn={kernelName:t.AvgPool,backendName:"webgpu",kernelFunc:function(e){const{inputs:n,backend:r,attrs:i}=e,{x:s}=n,{filterSize:a,strides:o,pad:u,dimRoundingMode:l}=i;return nn(s,t.backend_util.computePool2DInfo(s.shape,a,o,1,u,l),"avg",r)}};const sn={kernelName:t.BatchMatMul,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:i,b:s}=t,{transposeA:a,transposeB:o}=r;return ue({a:i,b:s,transposeA:a,transposeB:o,backend:n})}};class an{constructor(e,t){this.variableNames=["source"],this.workPerThread=1,this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.rank=t.length,this.dispatchLayout=R(this.outputShape),this.dispatch=S(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.start=e,this.uniforms=`start : ${p(e.length)}, `,this.shaderKey="slice"}getUserCode(){const e=p(this.rank),t=function(e){if(1===e)return"sourceLoc";if(e<=6)return on.slice(0,e).map((e=>`sourceLoc.${e}`)).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}(this.rank);let n;n=1===this.start.length?this.outputShape.map(((e,t)=>"sourceLoc = uniforms.start + coords;")):this.outputShape.map(((e,t)=>`sourceLoc.${on[t]} = uniforms.start.${f(t)} + coords.${on[t]};`));return`\n      ${m("index")} {\n        if (index < uniforms.size) {\n          var sourceLoc : ${e};\n          let coords = getCoordsFromIndex(index);\n          ${n.join("\n")}\n          setOutputAtIndex(index, getSource(${t}));\n        }\n      }\n    `}}const on=["x","y","z","w","u","v"];function un(e){const{inputs:n,backend:r,attrs:i}=e,{x:s}=n,{begin:a,size:o}=i,[u,l]=t.slice_util.parseSliceParams(s,a,o);if(t.slice_util.assertParamsValid(s,u,l),r.shouldExecuteOnCPU([s])||"string"===s.dtype){const e=r.tensorMap.get(s.dataId),t=Ct(e.values,u,l,s.shape,s.dtype);return r.makeTensorInfo(l,s.dtype,t)}if(0===t.util.sizeFromShape(l))return r.makeTensorInfo(l,s.dtype,[]);const d=new an(u,l),h=[{type:"int32",data:u}];return r.runWebGPUProgram(d,[s],s.dtype,h)}const ln={kernelName:t.Slice,backendName:"webgpu",kernelFunc:un},dn={kernelName:t.BatchToSpaceND,backendName:"webgpu",kernelFunc:e=>{const{inputs:n,backend:r,attrs:i}=e,{x:s}=n,{blockShape:a,crops:o}=i;t.util.assert(s.shape.length<=4,(()=>"batchToSpaceND for rank > 4 with a WebGPU backend not implemented yet"));const u=a.reduce(((e,t)=>e*t)),l=t.backend_util.getReshaped(s.shape,a,u),d=t.backend_util.getPermuted(l.length,a.length),h=t.backend_util.getReshapedPermuted(s.shape,a,u),c=t.backend_util.getSliceBeginCoords(o,a.length),p=t.backend_util.getSliceSize(h,o,a.length),f=[],m=ae({inputs:{x:s},backend:r,attrs:{shape:l}}),g=Mt({inputs:{x:m},backend:r,attrs:{perm:d}}),b=ae({inputs:{x:g},backend:r,attrs:{shape:h}}),x=un({inputs:{x:b},backend:r,attrs:{begin:c,size:p}});return f.push(m),f.push(g),f.push(b),f.forEach((e=>r.disposeData(e.dataId))),x}},hn=xe({opType:B.NOT_EQUAL,dtype:"bool",cpuKernelImpl:wt}),cn={kernelName:t.NotEqual,backendName:"webgpu",kernelFunc:hn};function pn(e){const{inputs:t,backend:n}=e,{input:r}=t;return ce({inputs:{x:n.tensorMap.get(r.dataId).complexTensorInfos.real},backend:n})}const fn={kernelName:t.Real,backendName:"webgpu",kernelFunc:pn};const mn={kernelName:t.Cast,backendName:"webgpu",kernelFunc:function e(n){const{inputs:i,backend:s,attrs:a}=n,{x:o}=i,{dtype:u}=a;if("complex64"===u){if("complex64"===o.dtype)return ce({inputs:{x:o},backend:s});const t=r.zeros(o.shape),n=e({inputs:{x:o},backend:s,attrs:{dtype:"float32"}}),i=fe({inputs:{real:n,imag:t},backend:s});return t.dispose(),s.disposeData(n.dataId),i}if("complex64"===o.dtype){const t=pn({inputs:{input:o},backend:s}),n=e({inputs:{x:t},backend:s,attrs:{dtype:u}});return s.disposeData(t.dataId),n}if(!t.util.hasEncodingLoss(o.dtype,u)){const e=ce({inputs:{x:o},backend:s});return{dataId:e.dataId,shape:e.shape,dtype:u}}if(s.shouldExecuteOnCPU([o])){const e=s.tensorMap.get(o.dataId).values,[t,n,r]=et(e,o.shape,o.dtype,u);return s.makeTensorInfo(t,n,r)}if("int32"===u)return function(e,t){const n=new ge(e.shape,M.TO_INT),r=t.runWebGPUProgram(n,[e],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}(o,s);if("bool"===u){const e=s.makeTensorInfo([],"bool",t.util.getTypedArrayFromDType("bool",1)),n=hn({inputs:{a:o,b:e},backend:s});return s.disposeData(e.dataId),n}throw new Error(`Error in Cast: failed to cast ${o.dtype} to ${u}`)}},gn=be({opType:M.CEIL,cpuKernelImpl:tt}),bn={kernelName:t.Ceil,backendName:"webgpu",kernelFunc:gn};class xn{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workPerThread=4,this.workGroupSize=[64,1,1],this.isVec4=!0,this.size=!0,this.outputShape=e,this.dispatchLayout=R(this.outputShape),this.dispatch=S(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.shaderKey="clipVec4"}getUserCode(){return`\n      ${m("index")} {\n        if(index < uniforms.size) {\n          let value = getAByOutputIndex(index);\n          var clampedValue : vec4<f32>;\n          for (var i = 0; i < 4; i = i + 1) {\n            if (isnan(value[i])) {\n              clampedValue[i] = value[i];\n            } else {\n              clampedValue[i] = clamp(value[i], uniforms.minVal, uniforms.maxVal);\n            }\n          }\n\n          setOutputAtIndex(index, clampedValue);\n        }\n      }\n    `}}class wn{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=R(this.outputShape),this.dispatch=S(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="clip"}getUserCode(){return`\n      ${m("index")} {\n        if(index < uniforms.size) {\n          let value = getAByOutputIndex(index);\n          if (isnan(value)) {\n            setOutputAtIndex(index, value);\n            return;\n          }\n          setOutputAtIndex(index, clamp(value, uniforms.minVal, uniforms.maxVal));\n        }\n      }\n    `}}const In={kernelName:t.ClipByValue,backendName:"webgpu",kernelFunc:function(e){const{inputs:n,backend:r,attrs:i}=e,{x:s}=n,{clipValueMin:a,clipValueMax:o}=i;let u;const l=[{type:"float32",data:[a]},{type:"float32",data:[o]}];return u=t.util.sizeFromShape(s.shape)%4==0?new xn(s.shape):new wn(s.shape),r.runWebGPUProgram(u,[s],s.dtype,l)}};class kn{constructor(e){this.uniforms="",this.workPerThread=1,this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=t.backend_util.computeOutShape(e,1),this.variableNames=e.map(((e,t)=>`T${t}`)),this.dispatchLayout=R(this.outputShape),this.dispatch=S(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.offsetLength=e.length-1;for(let e=0;e<this.offsetLength;e++)this.uniforms+=`offset${e} : i32,`;this.shaderKey="concat"}getUserCode(){const e=[];if(this.offsetLength>0){e.push("if (yC < uniforms.offset0){ setOutputAtCoords(coords.x, coords.y, getT0(yR, yC)); }");for(let t=1;t<this.offsetLength;t++)e.push(`else if (yC < uniforms.offset${[t]}){ setOutputAtCoords(coords.x, coords.y, getT${t}(yR, yC - uniforms.offset${t-1})); }`);const t=this.offsetLength,n=this.offsetLength-1;e.push(`else { setOutputAtCoords(coords.x, coords.y, getT${t}(yR, yC - uniforms.offset${n})); }`)}else e.push("setOutputAtCoords(coords.x, coords.y, getT0(yR, yC));");return`\n      ${m("index")} {\n        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {\n          let flatIndex = index * ${this.workPerThread} + i;\n          if(flatIndex < uniforms.size) {\n            let coords = getCoordsFromIndex(flatIndex);\n            let yR = coords.x;\n            let yC = coords.y;\n\n            ${e.join("\n        ")}\n          }\n        }\n      }\n    `}}function yn(e){const{inputs:t,backend:n}=e,{input:r}=t;return ce({inputs:{x:n.tensorMap.get(r.dataId).complexTensorInfos.imag},backend:n})}const Sn={kernelName:t.Imag,backendName:"webgpu",kernelFunc:yn};function vn(e,n,r){const i=e[0].dtype;if("complex64"===i){const t=e.map((e=>pn({inputs:{input:e},backend:r}))),i=e.map((e=>yn({inputs:{input:e},backend:r}))),s=vn(t,n,r),a=vn(i,n,r),o=fe({inputs:{real:s,imag:a},backend:r});return t.forEach((e=>r.disposeData(e.dataId))),i.forEach((e=>r.disposeData(e.dataId))),r.disposeData(s.dataId),r.disposeData(a.dataId),o}let s=r.shouldExecuteOnCPU(e);if("string"===i&&(s=!0),s){const s=e.map((e=>{const i=t.util.sizeFromShape(e.shape.slice(n));return ae({inputs:{x:e},backend:r,attrs:{shape:[-1,i]}})})),a=s.map((e=>({vals:r.readSync(e.dataId),shape:e.shape}))),o=t.backend_util.computeOutShape(s.map((e=>e.shape)),1),u=1===s[0].shape[0],l=nt(a,o,i,u),d=t.backend_util.computeOutShape(e.map((e=>e.shape)),n),h=r.makeTensorInfo(d,i,l);return s.forEach((e=>r.disposeData(e.dataId))),h}const a=r.device.limits.maxStorageBuffersPerShaderStage-1;if(e.length>a){const t=[];for(let i=0;i<e.length;i+=a){const s=e.slice(i,i+a);t.push(vn(s,n,r))}const i=vn(t,n,r);for(const e of t)r.disposeData(e.dataId);return i}const{tensors2D:o,outShape:u}=function(e,n,r){const i=t.backend_util.computeOutShape(e.map((e=>e.shape)),n);return{tensors2D:e.map((e=>ae({inputs:{x:e},backend:r,attrs:{shape:[t.util.sizeFromShape(e.shape.slice(0,n)),t.util.sizeFromShape(e.shape.slice(n))]}}))),outShape:i}}(e,n,r),l=o.map((e=>e.shape)),d=new kn(l),h=[],c=new Array(l.length-1);if(c.length>0){c[0]=l[0][1],h.push({type:"int32",data:[c[0]]});for(let e=1;e<c.length;e++)c[e]=c[e-1]+l[e][1],h.push({type:"int32",data:[c[e]]})}const p=r.runWebGPUProgram(d,o,o[0].dtype,h);o.forEach((e=>r.disposeData(e.dataId)));const f=ae({inputs:{x:p},backend:r,attrs:{shape:u}});return r.disposeData(p.dataId),f}function Cn(e){const{inputs:n,backend:r,attrs:i}=e,{axis:s}=i,a=t.util.parseAxisParam(s,n[0].shape)[0],o=n.map((e=>e.shape));t.backend_util.assertParamsConsistent(o,a);const u=t.backend_util.computeOutShape(n.map((e=>e.shape)),a);if(0===t.util.sizeFromShape(u))return r.makeTensorInfo(u,n[0].dtype,[]);const l=n.filter((e=>t.util.sizeFromShape(e.shape)>0));return 1===l.length?ce({inputs:{x:l[0]},backend:r}):vn(l,a,r)}const $n={kernelName:t.Concat,backendName:"webgpu",kernelFunc:Cn};class Rn{constructor(e,t,n,r,i=!1,s=null,a=!1,o=!1){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>, dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.outShape,this.isChannelsLast="channelsLast"===e.dataFormat,this.isVec4=((e.inChannels%4==0||e.inChannels%3==0)&&this.isChannelsLast||e.outWidth%4==0&&!this.isChannelsLast)&&e.outChannels%4==0,this.dispatchLayout=this.isChannelsLast?{x:[3],y:[1,2],z:[0]}:{x:[2,3],y:[1],z:[0]},this.workGroupSize=C(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=$(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=S(this.dispatchLayout,this.outputShape,this.workGroupSize,this.elementsPerThread),this.isVec4?(this.isChannelsLast&&e.inChannels%4!=0?(this.innerElementSize=3,this.variableTypes=["f32","vec4<f32>"]):(this.innerElementSize=4,this.variableTypes=["vec4<f32>","vec4<f32>"]),i&&(this.variableNames.push("bias"),this.variableTypes.push("vec4<f32>")),a&&(this.variableNames.push("preluActivationWeights"),this.variableTypes.push("vec4<f32>"))):(this.innerElementSize=this.elementsPerThread[0],i&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights")),this.sequentialAccessByThreads=o,this.addBias=i,this.activation=s,this.hasPreluActivationWeights=a,this.tileAOuter=this.workGroupSize[1]*this.elementsPerThread[1],this.tileBOuter=this.workGroupSize[0]*this.elementsPerThread[0],this.tileInner=Math.max(this.workGroupSize[0]*this.innerElementSize,this.workGroupSize[1]),this.fitAOuter=t%this.tileAOuter==0,this.fitBOuter=n%this.tileBOuter==0,this.fitInner=r%this.tileInner==0,this.shaderKey=`conv2DMM_${this.elementsPerThread}_${this.activation}}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.innerElementSize}_${this.isChannelsLast}_${this.sequentialAccessByThreads}`}getUserCode(){const e=this.isVec4?j(this.elementsPerThread,this.workGroupSize,!this.isChannelsLast,this.tileInner):Q(this.elementsPerThread,this.workGroupSize,!this.isChannelsLast,this.tileInner,!1,null,this.sequentialAccessByThreads),t=this.isVec4?[this.innerElementSize,4,4]:[1,1,1];return`\n    ${function(e,t,n,r,i=!1,s=null,a=!1,o=4,u=4,l=4){const d=e?"\n      let coord = vec4<i32>(batch, xRow, xCol, xCh);\n      ":"\n      let coord = vec4<i32>(batch, xCh, xRow, xCol);\n      ",h=e?"\n      let coords = vec4<i32>(\n        batch,\n        row / outWidth,\n        row % outWidth,\n        col);\n      ":"\n      let coords = vec4<i32>(\n        batch,\n        row,\n        col / outWidth,\n        col % outWidth);\n      ",c=e?"uniforms.xShape[1]":"uniforms.xShape[2]",p=e?"uniforms.xShape[2]":"uniforms.xShape[3]",f=e?"row":"col",m=e?"col":"row",g=`\n      let inChannels = uniforms.wShape[2];\n      let outWidth = ${e?"uniforms.outShape[2]":"uniforms.outShape[3]"};\n      let outRow = ${f} / outWidth;\n      let outCol = ${f} % outWidth;\n\n      let WRow = ${m} / (uniforms.filterDims[1] * inChannels);\n      let WCol = ${m} / inChannels % uniforms.filterDims[1];\n      let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];\n      let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];\n      let xCh = ${m} % inChannels;\n      var resData = ${V(o)}(0.0);\n      // The bounds checking is always needed since we use it to pad zero for\n      // the 'same' padding type.\n      if (xRow >= 0 && xRow < ${c} && xCol >= 0 && xCol < ${p}) {\n        ${d}\n        let xIndex = getIndexFromCoords4D(coord, uniforms.xShape);\n        ${(e=>{switch(e){case 1:return"resData = x[xIndex];";case 3:return"resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${e} is not supported.`)}})(o)}\n      }\n      return resData;`,b=e?t&&r?`\n      let col = colIn * ${o};\n      ${g}`:`\n      let col = colIn * ${o};\n      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {\n        ${g}\n      }\n      return ${V(o)}(0.0);`:r&&n?`\n      let col = colIn * ${o};\n      ${g}`:`\n      let col = colIn * ${o};\n      if (row < uniforms.dimInner && col < uniforms.dimBOuter) {\n        ${g}\n      }\n      return ${V(o)}(0.0);`,x=`${(e=>{switch(e){case 1:return"return W[row * uniforms.wShape[3] + colIn];";case 4:return"return W[row * uniforms.wShape[3] / 4 + colIn];";default:throw new Error(`innerElementSize ${e} is not supported.`)}})(u)}`,w=V(l),I=V(e?o:u),k=V(e?u:o);return`\n      ${H(s,a,4===l,4)}\n      fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${I} {\n        ${e?b:x}\n      }\n\n      fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${k} {\n        ${e?x:b}\n      }\n\n      fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${w}) {\n        let col = colIn * ${l};\n        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)\n        {\n        var value = valueIn;\n        let outWidth = ${e?"uniforms.outShape[2]":"uniforms.outShape[3]"};\n        ${h}\n        ${q(i,s)}\n        setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n        }\n      }`}(this.isChannelsLast,this.fitAOuter,this.fitBOuter,this.fitInner,this.addBias,this.activation,this.hasPreluActivationWeights,t[0],t[1],t[2])}\n    ${e}\n  `}}class Tn{constructor(e,t=!1,n=null,r=!1){this.variableNames=["x","W"],this.uniforms="filterDims: vec2<i32>, pad: vec2<i32>, stride: vec2<i32>, dilation: vec2<i32>,",this.workGroupSize=[4,4,8],this.outputShape=e.outShape,this.isChannelsLast="channelsLast"===e.dataFormat,this.dispatchLayout=this.isChannelsLast?{x:[2],y:[1],z:[0,3]}:{x:[3],y:[2],z:[0,1]},this.dispatch=S(this.dispatchLayout,this.outputShape,this.workGroupSize),this.addBias=t,this.activation=n,this.hasPreluActivationWeights=r,t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`conv2dnaive_${this.activation}_${this.isChannelsLast}`}getUserCode(){return`\n       ${H(this.activation,this.hasPreluActivationWeights,!1,4)}\n       fn readInp(batch : i32, row : i32, col : i32, chan : i32) -> f32{\n         let coords = vec4<i32>(batch, row, col, chan);\n         if (coordsInBounds4D(coords, uniforms.xShape)) {\n           return  getX(batch, row, col, chan);\n         } else {\n          return 0.0;\n         }\n       }\n       fn readFilt(row : i32, col : i32, xChannel : i32, outChannel : i32) -> f32{\n         let coords = vec4<i32>(row, col, xChannel, outChannel);\n         if(coordsInBounds4D(coords, uniforms.wShape)) {\n           return getW(row, col, xChannel, outChannel);\n          } else {\n            return 0.0;\n          }\n       }\n       fn writeResult(batch : i32, row : i32, col : i32, chan : i32, valueIn : f32) {\n         let coords = ${this.isChannelsLast?"vec4<i32>(batch, row, col, chan);":"vec4<i32>(batch, chan, row, col);"}\n         if (coordsInBounds4D(coords, uniforms.outShape)) {\n           var value = valueIn;\n           ${q(this.addBias,this.activation)}\n           setOutputAtCoords(coords.x, coords.y, coords.z, coords.w, value);\n         }\n       }\n       ${m("index")} {\n         let coords = getOutputCoords();\n         let batch = coords[0];\n         let outChannel = ${this.isChannelsLast?"coords[3];":"coords[1];"}\n         let outRow = ${this.isChannelsLast?"coords[1];":"coords[2];"}\n         let outCol = ${this.isChannelsLast?"coords[2];":"coords[3];"}\n         var acc : f32 = 0.0;\n         for (var row = 0; row < uniforms.filterDims[0]; row = row + 1) {\n           for (var col = 0; col < uniforms.filterDims[1]; col = col + 1) {\n             let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * row - uniforms.pad[0];\n             let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * col - uniforms.pad[1];\n             for (var xChannel = 0; xChannel < ${this.isChannelsLast?"uniforms.xShape[3];":"uniforms.xShape[1];"} xChannel = xChannel + 1) {\n               ${this.isChannelsLast?"let v = readInp(batch, xRow, xCol, xChannel);":"let v = readInp(batch, xChannel, xRow, xCol);"}\n               let f = readFilt(row, col, xChannel, outChannel);\n               acc = acc + v * f;\n             }\n           }\n         }\n         writeResult(batch, outRow, outCol, outChannel, acc);\n       }\n     `}}function An(e,t){const n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&1===n&&e[0]>1?[e[0],1]:null}function Pn({x:e,filter:n,convInfo:r,backend:i,bias:s=null,preluActivationWeights:a=null,leakyreluAlpha:o=0,activation:u=null}){const l=null!=s,d=null!=a,h="channelsLast"===r.dataFormat,c=h&&r.filterHeight===r.inHeight&&r.filterWidth===r.inWidth&&"VALID"===r.padInfo.type,p=t.env().getBool("WEBGPU_USE_NAIVE_CONV2D_DEBUG");if(!p&&(c||1===r.filterHeight&&1===r.filterWidth&&1===r.dilationHeight&&1===r.dilationWidth&&1===r.strideHeight&&1===r.strideWidth&&("SAME"===r.padInfo.type||"VALID"===r.padInfo.type)))return function({x:e,filter:t,convInfo:n,backend:r,bias:i=null,preluActivationWeights:s=null,leakyreluAlpha:a=0,activation:o=null}){const u="channelsLast"===n.dataFormat,l=!u,d=[];let h,c;if(u&&n.filterHeight===n.inHeight&&n.filterWidth===n.inWidth&&"VALID"===n.padInfo.type){const i=n.inHeight*n.inWidth*n.inChannels;h=ae({inputs:{x:e},backend:r,attrs:{shape:[1,n.batchSize,i]}}),c=ae({inputs:{x:t},backend:r,attrs:{shape:[1,i,n.outChannels]}})}else h=ae({inputs:{x:e},backend:r,attrs:{shape:u?[n.batchSize,n.inHeight*n.inWidth,n.inChannels]:[n.batchSize,n.inChannels,n.inHeight*n.inWidth]}}),c=ae({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});if(d.push(h),d.push(c),null!=s){const e=An(s.shape,u);null!=e&&(s=ae({inputs:{x:s},backend:r,attrs:{shape:e}}),d.push(s))}if(null!=i){const e=An(i.shape,u);null!=e&&(i=ae({inputs:{x:i},backend:r,attrs:{shape:e}}),d.push(i))}const p=ue({a:u?h:c,b:u?c:h,transposeA:l,transposeB:!1,backend:r,bias:i,activation:o,preluActivationWeights:s,leakyreluAlpha:a}),f=ae({inputs:{x:p},backend:r,attrs:{shape:n.outShape}});d.push(p);for(const e of d)r.disposeData(e.dataId);return f}({x:e,filter:n,convInfo:r,backend:i,bias:s,activation:u,preluActivationWeights:a,leakyreluAlpha:o});let f;const m=[r.padInfo.top,r.padInfo.left],g=[{type:"int32",data:[r.filterHeight,r.filterWidth]},{type:"int32",data:[...m]},{type:"int32",data:[r.strideHeight,r.strideWidth]},{type:"int32",data:[r.dilationHeight,r.dilationWidth]}];if(p)f=new Tn(r,l,u,d);else{const e=h?r.outHeight*r.outWidth:r.outChannels,t=h?r.outChannels:r.outHeight*r.outWidth,n=r.filterHeight*r.filterWidth*r.inChannels;g.push({type:"int32",data:[e]},{type:"int32",data:[t]},{type:"int32",data:[n]});const s=i.adapterInfo.isIntel();f=new Rn(r,e,t,n,l,u,d,s)}const b=[],x=[e,n];l&&(h||1!==s.shape.length||(s=ae({inputs:{x:s},backend:i,attrs:{shape:[s.shape[0],1,1]}}),b.push(s)),x.push(s)),d&&(h||1!==a.shape.length||(a=ae({inputs:{x:a},backend:i,attrs:{shape:[a.shape[0],1,1]}}),b.push(a)),x.push(a)),"leakyrelu"===u&&(g.push({type:"float32",data:[o]}),f.uniforms+=" alpha : f32,");const w=i.runWebGPUProgram(f,x,e.dtype,g);for(const e of b)i.disposeData(e.dataId);return w}const zn={kernelName:t.Conv2D,backendName:"webgpu",kernelFunc:function(e){const{inputs:n,attrs:r,backend:i}=e,{x:s,filter:a}=n,{strides:o,pad:u,dataFormat:l,dilations:d,dimRoundingMode:h}=r,c=t.backend_util.convertConv2DDataFormat(l);return Pn({x:s,filter:a,convInfo:t.backend_util.computeConv2DInfo(s.shape,a.shape,o,d,u,h,!1,c),backend:i})}};class _n{constructor(e){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, stride : vec2<i32>, outBackprop : vec4<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.inShape,t.util.assert("channelsLast"===e.dataFormat,(()=>"TODO: NCHW is unimplemented")),this.isVec4=e.inChannels%4==0&&e.outChannels%4==0,this.dispatchLayout={x:[3],y:[1,2],z:[0]},this.workGroupSize=C(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=$(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=S(this.dispatchLayout,this.outputShape,this.workGroupSize,this.elementsPerThread),this.isVec4&&(this.variableTypes=["vec4<f32>","f32"]),this.shaderKey=`conv2DDerInputMM_${this.isVec4}_${this.elementsPerThread}`}getUserCode(){const e=this.isVec4?j(this.elementsPerThread,this.workGroupSize):Q(this.elementsPerThread,this.workGroupSize);return`\n    ${function(e=4){const t=`if (row < uniforms.dimAOuter && col < uniforms.dimInner) {\n        \n      let outRow = row / uniforms.outShape[2];\n      let outCol = row % uniforms.outShape[2];\n\n      let WRow = col / (uniforms.filterDims[1] * uniforms.outBackprop[3]);\n      let WCol = col / uniforms.outBackprop[3] % uniforms.filterDims[1];\n      let xR = f32(outRow - uniforms.pads[0] + WRow) / f32(uniforms.stride[0]);\n      let xC = f32(outCol - uniforms.pads[1] + WCol) / f32(uniforms.stride[1]);\n      if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {\n        return ${V(e)}(0.0);\n      }\n      if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {\n        return ${V(e)}(0.0);\n      }\n      let coord = vec4<i32>(\n          batch,\n          i32(xR),\n          i32(xC),\n          col % uniforms.outBackprop[3]);\n      return x[getIndexFromCoords4D(coord, uniforms.xShape)/${e}];\n      }\n      return ${V(e)}(0.0);`;return`\n  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${V(e)} {\n    let col = colIn * ${e};\n    ${t}\n  }\n\n  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${V(e)} {\n    let col = colIn * ${e};\n    let coordX = uniforms.filterDims.x - 1 -\n        row / (uniforms.filterDims[1] * uniforms.outBackprop[3]);\n    let coordY = uniforms.filterDims.y - 1 -\n        (row / uniforms.outBackprop[3]) % uniforms.filterDims[1];\n    if (row < uniforms.dimInner && col < uniforms.dimBOuter &&\n        coordX >= 0 && coordY >= 0) {\n      let rowInner = row % uniforms.outBackprop[3];\n      let coord = vec4<i32>(coordX, coordY, col, rowInner);\n      ${(e=>{switch(e){case 1:return"return W[getIndexFromCoords4D(coord, uniforms.wShape)];";case 4:return"\n            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);\n            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);\n            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);\n            let v0 = W[getIndexFromCoords4D(coord, uniforms.wShape)];\n            let v1 = W[getIndexFromCoords4D(coord1, uniforms.wShape)];\n            let v2 = W[getIndexFromCoords4D(coord2, uniforms.wShape)];\n            let v3 = W[getIndexFromCoords4D(coord3, uniforms.wShape)];\n            return vec4<f32>(v0, v1, v2, v3);\n            ";default:throw new Error(`innerElementSize ${e} is not supported.`)}})(e)}\n    }\n    return ${V(e)}(0.0);\n  }\n\n  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${V(e)}) {\n    let col = colIn * ${e};\n    if (row < uniforms.dimAOuter && (col + ${e-1}) < uniforms.dimBOuter) {\n      var value = valueInput;\n      let outCoord = vec4<i32>(\n          batch,\n          row / uniforms.outShape[2],\n          row % uniforms.outShape[2],\n          col);\n      result[getIndexFromCoords4D(outCoord, uniforms.outShape)/${e}] = value;\n    }\n  }`}(this.isVec4?4:1)}\n    ${e}\n    `}}class En{constructor(e){this.variableNames=["dy","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, stride : vec2<i32>, outBackprop : vec4<i32>,",this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=R(this.outputShape),this.dispatch=S(this.dispatchLayout,this.outputShape,this.workGroupSize),this.isChannelsLast="channelsLast"===e.dataFormat,this.shaderKey=`conv2DDerInput_${this.isChannelsLast}`}getUserCode(){const e=this.isChannelsLast?1:2,t=this.isChannelsLast?2:3,n=this.isChannelsLast?3:1;return`\n    ${m("index")} {\n      if(index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords[0];\n        let d1 = coords[${n}];\n\n        let dyCorner = vec2<i32>(coords[${e}], coords[${t}]) - uniforms.pads;\n        let dyRCorner = dyCorner.x;\n        let dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {\n          let dyR = (f32(dyRCorner) + f32(wR)) / f32(uniforms.stride.x);\n          let wRPerm = uniforms.filterDims.x - 1 - wR;\n          if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) || fract(dyR) > 0.0 ||\n              wRPerm < 0) {\n            continue;\n          }\n          let idyR = i32(dyR);\n\n          for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {\n            let dyC = (f32(dyCCorner) + f32(wC)) / f32(uniforms.stride.y);\n            let wCPerm = uniforms.filterDims.y - 1 - wC;\n            if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||\n                fract(dyC) > 0.0 || wCPerm < 0) {\n              continue;\n            }\n            let idyC = i32(dyC);\n\n            for (var d2 = 0; d2 < uniforms.outBackprop[3]; d2 = d2 + 1) {\n              if (${this.isChannelsLast}) {\n                let xValue = getDy(batch, idyR, idyC, d2);\n                let wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd = dotProd + xValue * wValue;\n              } else {\n                let xValue = getDy(batch, d2, idyR, idyC);\n                let wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd = dotProd + xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n  `}}const Nn={kernelName:t.Conv2DBackpropInput,backendName:"webgpu",kernelFunc:function(e){const{inputs:n,backend:r,attrs:i}=e,{dy:s,filter:a}=n,{inputShape:o,strides:u,pad:l,dataFormat:d,dimRoundingMode:h}=i,c=t.backend_util.convertConv2DDataFormat(d),p=t.backend_util.computeConv2DInfo(o,a.shape,u,1,l,h,!1,c),f=[{type:"int32",data:[p.filterHeight,p.filterWidth]},{type:"int32",data:[p.filterHeight-1-p.padInfo.top,p.filterWidth-1-p.padInfo.left]},{type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.batchSize,p.outHeight,p.outWidth,p.outChannels]}];let m;if(t.env().getBool("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE")||p.filterHeight<=2&&p.filterWidth<=2&&p.outChannels<=16&&1===p.inChannels)m=new En(p);else{m=new _n(p);const e=p.inHeight*p.inWidth,t=p.inChannels,n=p.filterHeight*p.filterWidth*p.outChannels;f.push({type:"uint32",data:[e]},{type:"uint32",data:[t]},{type:"uint32",data:[n]})}return r.runWebGPUProgram(m,[s,a],"float32",f)}},Bn=be({opType:M.COS}),Fn={kernelName:t.Cos,backendName:"webgpu",kernelFunc:Bn},On=be({opType:M.COSH}),Dn={kernelName:t.Cosh,backendName:"webgpu",kernelFunc:On};class Gn{constructor(e,t,n,r){this.variableNames=["Image","Boxes","BoxInd"],this.uniforms="extrapolationValue : f32,",this.workGroupSize=[64,1,1],this.size=!0;const[i]=t;this.outputShape=[i,n[0],n[1],e],this.dispatchLayout=R(this.outputShape),this.dispatch=S(this.dispatchLayout,this.outputShape,this.workGroupSize),this.methodId="bilinear"===r?1:0,this.cropHeightBiggerThan1=this.outputShape[1]>1,this.cropWidthBiggerThan1=this.outputShape[2]>1,this.shaderKey=`cropAndResize_${this.methodId}_${this.cropHeightBiggerThan1}_${this.cropWidthBiggerThan1}`}getUserCode(){const[e,t]=["f32(uniforms.imageShape[1] - 1)","f32(uniforms.imageShape[2] - 1)"],[n,r,i]=this.cropHeightBiggerThan1?[`(${e} / f32(uniforms.outShape[1] - 1))`,"(y2-y1) * height_ratio",`y1*${e} + f32(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${e}`],[s,a,o]=this.cropWidthBiggerThan1?[`(${t} / f32(uniforms.outShape[2] - 1))`,"(x2-x1) * width_ratio",`x1*${t} + f32(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${t}`];return`\n    ${m("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let height_ratio = f32(${n});\n        let width_ratio = f32(${s});\n        let b = coords[0];\n        let y = coords[1];\n        let x = coords[2];\n        let d = coords[3];\n        // get box vals\n        let y1 = getBoxes(b, 0);\n        let x1 = getBoxes(b, 1);\n        let y2 = getBoxes(b, 2);\n        let x2 = getBoxes(b, 3);\n        // get image in batch index\n        let bInd = i32(round(getBoxInd(b)));\n        if(bInd < 0 || bInd >= uniforms.outShape[0]) {\n          return;\n        }\n        let height_scale = ${r};\n        let width_scale = ${a};\n        let in_y = ${i};\n        if( in_y < 0.0 || in_y > ${e} ) {\n          setOutputAtIndex(index, uniforms.extrapolationValue);\n          return;\n        }\n        let in_x = ${o};\n        if( in_x < 0.0 || in_x > ${t} ) {\n          setOutputAtIndex(index, uniforms.extrapolationValue);\n          return;\n        }\n        let sourceFracIndexCR = vec2<f32>(in_x,in_y);\n        if(${this.methodId} == 1) {\n          // Compute the four integer indices.\n          let sourceFloorCR = vec2<i32>(sourceFracIndexCR);\n          let sourceCeilCR = vec2<i32>(ceil(sourceFracIndexCR));\n          let topLeft = getImage(bInd, sourceFloorCR.y, sourceFloorCR.x, d);\n          let bottomLeft = getImage(bInd, sourceCeilCR.y, sourceFloorCR.x, d);\n          let topRight = getImage(bInd, sourceFloorCR.y, sourceCeilCR.x, d);\n          let bottomRight = getImage(bInd, sourceCeilCR.y, sourceCeilCR.x, d);\n          let fracCR = sourceFracIndexCR - vec2<f32>(sourceFloorCR);\n          let top = topLeft + (topRight - topLeft) * fracCR.x;\n          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          let newValue = top + (bottom - top) * fracCR.y;\n          setOutputAtIndex(index, newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          let sourceNearestCR = vec2<i32>(floor(\n            sourceFracIndexCR + vec2<f32>(0.5,0.5)));\n          let newValue = getImage(\n            bInd, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutputAtIndex(index, newValue);\n        }\n      }\n    }\n    `}}const Ln={kernelName:t.CropAndResize,backendName:"webgpu",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{image:i,boxes:s,boxInd:a}=t,{cropSize:o,method:u,extrapolationValue:l}=r,d=new Gn(i.shape[3],s.shape,o,u),h=[{type:"float32",data:[l]}];return n.runWebGPUProgram(d,[i,s,a],"float32",h)}};var Un;!function(e){e.Prod="*",e.Sum="+"}(Un||(Un={}));class Mn{constructor(e,t,n,r){this.variableNames=["x"],this.uniforms="index : f32,",this.size=!0;this.workGroupSize=[128,1,1],this.outputShape=t,this.dispatchLayout=R(this.outputShape),this.dispatch=S(this.dispatchLayout,this.outputShape,this.workGroupSize),this.exclusive=n,this.reverse=r,this.op=e,this.shaderKey=`cum_${this.op}_${this.exclusive}_${this.reverse}`}getUserCode(){const e=this.outputShape.length,t=this.op===Un.Prod?"1.0":"0.0",n=this.exclusive?t:`getX(${Wn(e,"coords",this.op)})`,r=this.outputShape[this.outputShape.length-1];let i="",s="";return this.exclusive?(i=this.reverse?"end != "+(r-1):"end != 0",s=this.reverse?"end + 1":"end - 1"):(i=this.reverse?`end + pow2 < ${r}`:"end >= pow2",s=this.reverse?"end + pow2":"end - pow2"),`\n      ${m("index")} {\n       if (index < uniforms.size) {\n         var coords = getCoordsFromIndex(index);\n\n         let end = ${Vn(e,"coords",this.op)};\n         var val = ${n};\n         let pow2 = i32(pow(2.0, uniforms.index));\n         if (${i}) {\n           let idx = ${s};\n           ${Vn(e,"coords",this.op)} = idx;\n           val ${this.op}= getX(${Wn(e,"coords",this.op)});\n         }\n         setOutputAtIndex(index, val);\n       }\n      }\n    `}}function Wn(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.x, ${t}.y`;if(3===e)return`${t}.x, ${t}.y, ${t}.z`;if(4===e)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function Vn(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.y`;if(3===e)return`${t}.z`;if(4===e)return`${t}.w`;throw Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function Hn(e,n,r,i,s,a){const o=n.shape.length,u=t.backend_util.getAxesPermutation([i],o);let l=n;null!=u&&(l=Mt({inputs:{x:n},backend:r,attrs:{perm:u}}));const d=t.backend_util.getInnerMostAxes(1,o)[0];if(d!==o-1)throw new Error(`WebGPU cumprod shader expects an inner-most axis=${n.shape.length-1} but got axis=${i}`);const h=l.shape[d];let c=ce({inputs:{x:l},backend:r});for(let t=0;t<=Math.ceil(Math.log2(h))-1;t++){const n=new Mn(e,l.shape,!1,a),i=c,s=[{type:"float32",data:[t]}];c=r.runWebGPUProgram(n,[c],c.dtype,s),r.disposeData(i.dataId)}if(s){const t=new Mn(e,l.shape,s,a),n=c,i=[{type:"float32",data:[0]}];c=r.runWebGPUProgram(t,[c],c.dtype,i),r.disposeData(n.dataId)}if(null!=u){const e=Mt({inputs:{x:c},backend:r,attrs:{perm:t.backend_util.getUndoAxesPermutation(u)}});return r.disposeData(c.dataId),r.disposeData(l.dataId),e}return c}const qn={kernelName:t.Cumprod,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:s,exclusive:a,reverse:o}=r;return Hn(Un.Prod,i,n,s,a,o)}};const Xn={kernelName:t.Cumsum,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:s,exclusive:a,reverse:o}=r;return Hn(Un.Sum,i,n,s,a,o)}};class Kn{constructor(e,t){this.variableNames=["x"],this.workGroupSize=[64,1,1],this.size=!0,this.uniforms="blockSize : i32,",this.outputShape=e,this.dispatchLayout=R(this.outputShape),this.dispatch=S(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey=`depthToSpace_${t}`,this.dataFormat=t}getUserCode(){return`\n      ${m("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let b = coords[0];\n          let h = ${this.getHeightCoordString()};\n          let w = ${this.getWidthCoordString()};\n          let d = ${this.getDepthCoordString()};\n\n          let in_h = h / uniforms.blockSize;\n          let offset_h = h % uniforms.blockSize;\n          let in_w = w / uniforms.blockSize;\n          let offset_w = w % uniforms.blockSize;\n          let offset_d = (offset_h * uniforms.blockSize + offset_w) *\n            ${this.getOutputDepthSize()};\n          let in_d = d + offset_d;\n\n          let rlt = ${this.getInputSamplingString()};\n          setOutputAtIndex(index, rlt);\n        }\n      }`}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?"uniforms.outShape[3]":"uniforms.outShape[1]"}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const jn={kernelName:t.DepthToSpace,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{blockSize:s,dataFormat:a}=r,o=i.shape[0],u=("NHWC"===a?i.shape[1]:i.shape[2])*s,l=("NHWC"===a?i.shape[2]:i.shape[3])*s,d=("NHWC"===a?i.shape[3]:i.shape[1])/(s*s),h=[{type:"int32",data:[s]}],c=new Kn("NHWC"===a?[o,u,l,d]:[o,d,u,l],a);return n.runWebGPUProgram(c,[i],i.dtype,h)}};class Yn{constructor(e,t,n,r=!1,i=null,s=!1){this.variableNames=["x","W"],this.uniforms="pad : vec2<i32>, inDims : vec2<i32>,",this.workGroupSize=[16,16,1],this.outputShape=e,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=S(this.dispatchLayout,this.outputShape,this.workGroupSize),r&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),this.addBias=r,this.activation=i,this.hasPreluActivation=s,this.filterHeight=t,this.filterWidth=n,this.shaderKey=`depthwiseNCHW_${this.activation}_${this.filterHeight}_${this.filterWidth}`}getUserCode(){const e=this.filterWidth*this.filterHeight,t=this.workGroupSize[0]*this.workGroupSize[1]*this.workGroupSize[2],n=this.workGroupSize[1]+this.filterHeight-1,r=this.workGroupSize[0]+this.filterWidth-1;return`\n      ${H(this.activation,this.hasPreluActivation,!1,4)}\n\n      var<workgroup> mm_Asub : array<array<f32, ${r}>, ${n}>;\n      var<workgroup> mm_Bsub : array<array<f32, ${this.filterWidth}>, ${this.filterHeight}>;\n      fn readX(batch : i32, channel : i32, row : i32, col : i32) -> f32 {\n        var value = 0.0;\n        if (row >=0 && row < uniforms.inDims[0] && col >=0 && col < uniforms.inDims[1])\n        {\n          value = getX(batch, channel, row, col);\n        }\n        return value;\n      }\n\n      \n  @compute @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n\n      fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,\n                @builtin(global_invocation_id) GlobalId : vec3<u32>,\n                @builtin(local_invocation_index) LocalIndex: u32,\n                @builtin(num_workgroups) NumWorkgroups: vec3<u32>) {\n        localId = LocalId;\n        globalId = GlobalId;\n        let localIndex = i32(LocalIndex);\n        numWorkgroups = NumWorkgroups;\n        let coords = getOutputCoords();\n        let batch = coords[0];\n        let xRCCorner = vec2<i32>(coords.zw) - uniforms.pad;\n        let channelMul = uniforms.wShape[3];\n        let d1 = coords[1] / channelMul;\n        let q = coords[1] % channelMul;\n\n        let inputRowStart = xRCCorner.x;\n        let inputColStart = xRCCorner.y;\n\n        let localRow = i32(localId.y);\n        let localCol = i32(localId.x);\n\n        // Load one tile of X into local memory.\n        for (var inputRow = localRow; inputRow < ${n}; inputRow = inputRow + ${this.workGroupSize[1]}) {\n          for (var inputCol = localCol; inputCol < ${r}; inputCol = inputCol + ${this.workGroupSize[0]}) {\n            let rowOffset = inputRow - localRow;\n            let colOffset = inputCol - localCol;\n            mm_Asub[inputRow][inputCol] = readX(batch, d1, inputRowStart + rowOffset, inputColStart + colOffset);\n          }\n        }\n\n        // Load one tile of W into local memory.\n        var wIndex = localIndex;\n        ${e<t?`if (wIndex < ${e})`:`for(; wIndex < ${e}; wIndex = wIndex + ${t})`}\n\n        {\n          let wRow = wIndex / ${this.filterWidth};\n          let wCol = wIndex % ${this.filterWidth};\n          mm_Bsub[wRow][wCol] = getW(wRow, wCol, d1, q);\n        }\n\n        workgroupBarrier();\n\n        var value = 0.0;\n        for (var wR = 0; wR < ${this.filterHeight}; wR = wR + 1) {\n          for (var wC = 0; wC < ${this.filterWidth}; wC = wC + 1) {\n            let xVal = mm_Asub[localRow + wR][localCol + wC];\n            let wVal = mm_Bsub[wR][wC];\n            value = fma(xVal, wVal, value);\n          }\n        }\n        ${q(this.addBias,this.activation)}\n        if (coordsInBounds4D(coords, uniforms.outShape)) {\n          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n        }\n      }\n    `}}class Qn{constructor(e,n=!1,r=null,i=!1){this.variableNames=["x","W"],this.uniforms="pad : vec2<i32>, inDims : vec2<i32>,",this.workGroupSize=[4,4,4],this.workPerThread=4,this.isVec4=!0,this.outputShape=e.outShape,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=S(this.dispatchLayout,this.outputShape,this.workGroupSize,[4,this.workPerThread,1]),t.util.assert("channelsLast"===e.dataFormat,(()=>"TODO: NCHW is unimplemented")),n&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=n,this.activation=r,this.hasPreluActivation=i,this.shaderKey=`depthwiseVec4_${r}_${this.convInfo.filterHeight}_${this.convInfo.filterWidth}_${this.convInfo.strideHeight}_${this.convInfo.strideWidth}_${this.workPerThread}`}getUserCode(){const e=(this.workPerThread-1)*this.convInfo.strideWidth+this.convInfo.filterWidth;return`\n      ${H(this.activation,this.hasPreluActivation,!0,4)}\n      fn readX(batch : i32, row : i32, col : i32, channel : i32) -> vec4<f32> {\n        var value = vec4<f32>(0.0);\n        if (col >=0 && col < uniforms.inDims[1]) {\n          value = getX(batch, row, col, channel);\n        }\n        return value;\n      }\n\n      const strideHeight = ${this.convInfo.strideHeight};\n      const strideWidth = ${this.convInfo.strideWidth};\n      \n  @compute @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\n\n      fn _start(@builtin(global_invocation_id) globalId: vec3<u32>) {\n        let batch = i32(globalId.z) / uniforms.outShape[1];\n        let r = i32(globalId.z) % uniforms.outShape[1];\n        let c = i32(globalId.y) * ${this.workPerThread};\n        let d1 = i32(globalId.x) * 4;\n        let xRCCorner = vec2<i32>(r, c) * vec2<i32>(strideHeight, strideWidth) - uniforms.pad;\n\n        let xRCorner = xRCCorner.x;\n        let xCCorner = xRCCorner.y;\n        var xVals : array<vec4<f32>, ${e}>;\n        var dotProd : array<vec4<f32>, ${this.workPerThread}>;\n        for (var i = 0; i < ${this.workPerThread}; i++) {\n          dotProd[i] = vec4<f32>(0.0);\n        }\n\n        // Use constant instead of uniform can give better performance.\n        for (var wR = 0; wR < ${this.convInfo.filterHeight}; wR = wR + 1) {\n          let xR = xRCorner + wR;\n          if (xR >=0 && xR < uniforms.inDims[0]) {\n            for (var i = 0; i < ${e}; i++) {\n              xVals[i] = readX(batch, xR, xCCorner + i, d1);\n            }\n            for (var wC = 0; wC < ${this.convInfo.filterWidth}; wC = wC + 1) {\n              let wValue = getW(wR, wC, d1, 0);\n              for (var i = 0; i < ${this.workPerThread}; i++) {\n                dotProd[i] = fma(xVals[i * strideWidth + wC], wValue, dotProd[i]);\n              }\n            }\n          }\n        }\n\n        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {\n          let coords = vec4<i32>(batch, r, c + i, d1);\n          if (coordsInBounds4D(coords, uniforms.outShape)) {\n            var value = dotProd[i];\n            ${q(this.addBias,this.activation)}\n            setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n          }\n        }\n      }\n    `}}class Zn{constructor(e,t=!1,n=null,r=!1){this.variableNames=["x","W"],this.uniforms="pad : vec2<i32>, inDims : vec2<i32>, filterHeight : i32,\n      filterWidth : i32, stride : vec2<i32>, dilation : vec2<i32>,",this.workGroupSize=[256,1,1],this.outputShape=e.outShape,this.dispatchLayout=R(this.outputShape),this.dispatch=S(this.dispatchLayout,this.outputShape,this.workGroupSize),this.isChannelsLast="channelsLast"===e.dataFormat,t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=n,this.hasPreluActivation=r,this.shaderKey=`depthwise_${this.activation}_${this.isChannelsLast}`}getUserCode(){const e=this.isChannelsLast?"getX(batch, xR, xC, d1);":"getX(batch, d1, xR, xC);";return`\n      ${H(this.activation,this.hasPreluActivation,!1,4)}\n\n      ${m()} {\n        let coords = getOutputCoords();\n        let batch = coords[0];\n        let xRCCorner = vec2<i32>(coords.${this.isChannelsLast?"yz":"zw"}) * uniforms.stride - uniforms.pad;\n        let d2 = coords[${this.isChannelsLast?3:1}];\n        let channelMul = uniforms.wShape[3];\n        let d1 = d2 / channelMul;\n        let q = d2 % channelMul;\n\n        let inputRowStart = xRCCorner.x;\n        let inputColStart = xRCCorner.y;\n        let inputRowEnd = inputRowStart + uniforms.filterHeight *\n            uniforms.dilation[0];\n        let inputColEnd = inputColStart + uniforms.filterWidth *\n            uniforms.dilation[1];\n\n        // Convolve x(?, ?, d1)|x(d1, ?, ?) with w(:, :, d1, q) to get\n        // y(yR, yC, d2)|y(d2, yR, yC). ? = to be determined. : = across all\n        // values in that axis. x(?, ?, d1) and y(yR, yC, d2) is for NHWC.\n        // x(d1, ?, ?) and y(d2, yR, yC) is for NCHW.\n        var value = 0.0;\n\n        // Extract if checking out of for loop for performance.\n        if (inputRowStart >= 0 && inputColStart >= 0 &&\n          inputRowEnd < uniforms.inDims[0] &&\n              inputColEnd < uniforms.inDims[1]) {\n            for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {\n              let xR = inputRowStart + wR * uniforms.dilation[0];\n\n              for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {\n                let xC = inputColStart + wC * uniforms.dilation[1];\n\n                let xVal = ${e};\n                let wVal = getW(wR, wC, d1, q);\n                value = value + xVal * wVal;\n              }\n            }\n          } else {\n            for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {\n              let xR = inputRowStart + wR * uniforms.dilation[0];\n\n              if (xR < 0 || xR >= uniforms.inDims[0]) {\n                continue;\n              }\n\n              for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {\n                let xC = inputColStart + wC * uniforms.dilation[1];\n\n                if (xC < 0 || xC >= uniforms.inDims[1]) {\n                  continue;\n                }\n\n                let xVal = ${e};\n                let wVal = getW(wR, wC, d1, q);\n                value = value + xVal * wVal;\n              }\n            }\n          }\n          ${q(this.addBias,this.activation)}\n        if (coordsInBounds4D(coords, uniforms.outShape)) {\n          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n        }\n      }\n    `}}const Jn={kernelName:t.DepthwiseConv2dNative,backendName:"webgpu",kernelFunc:function(e){const{inputs:n,backend:r,attrs:i}=e,{x:s,filter:a}=n,{strides:o,pad:u,dataFormat:l,dilations:d,dimRoundingMode:h}=i,c=t.backend_util.convertConv2DDataFormat(l);let p=d;null==p&&(p=[1,1]);const f=t.backend_util.computeConv2DInfo(s.shape,a.shape,o,p,u,h,!0,c),m=[{type:"int32",data:[f.padInfo.top,f.padInfo.left]},{type:"int32",data:[f.inHeight,f.inWidth]}],g="channelsLast"===f.dataFormat;let b;return!g&&f.inHeight>16&&f.inWidth>16&&1===f.strideHeight&&1===f.strideWidth&&1===f.dilationWidth&&1===f.dilationHeight&&f.inChannels===f.outChannels?b=new Yn(f.outShape,f.filterHeight,f.filterWidth):g&&f.inHeight>4&&f.inWidth>4&&f.strideWidth<=2&&f.inChannels===f.outChannels&&1===f.dilationHeight&&1===f.dilationWidth&&f.inChannels%4==0?b=new Qn(f):(b=new Zn(f),m.push({type:"int32",data:[f.filterHeight]},{type:"int32",data:[f.filterWidth]},{type:"int32",data:[f.strideHeight,f.strideWidth]},{type:"int32",data:[f.dilationHeight,f.dilationWidth]})),r.runWebGPUProgram(b,[s,a],s.dtype,m)}},er=xe({opType:B.MUL,cpuKernelImpl:bt,supportsComplex:!0}),tr={kernelName:t.Multiply,backendName:"webgpu",kernelFunc:er};function nr(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:s,keepDims:a}=r;return Qt(i,s,a,"sum",n)}const rr={kernelName:t.Sum,backendName:"webgpu",kernelFunc:nr};const ir={kernelName:t.Einsum,backendName:"webgpu",kernelFunc:function(e){const{inputs:n,backend:r,attrs:i}=e,{equation:s}=i,a=n,{allDims:o,summedDims:u,idDims:l}=t.backend_util.decodeEinsumEquation(s,a.length);t.backend_util.checkEinsumDimSizes(o.length,l,a);const{path:d,steps:h}=t.backend_util.getEinsumComputePath(u,l),c=h.length;let p=null,f=o.length;const m=[];for(let e=0;e<c;++e){for(const n of h[e]){const{permutationIndices:e,expandDims:i}=t.backend_util.getEinsumPermutation(f,l[n]);let s;t.backend_util.isIdentityPermutation(e)?s=a[n]:(s=Mt({inputs:{x:a[n]},backend:r,attrs:{perm:e}}),m.push(s));const o=s.shape.slice();for(let e=0;e<i.length;++e)o.splice(i[e],0,1);t.util.arraysEqual(s.shape,o)||(s=ae({inputs:{x:s},backend:r,attrs:{shape:o}}),m.push(s)),null===p?p=s:(p=er({inputs:{a:s,b:p},backend:r}),m.push(p))}e<c-1&&(d[e]>=0&&(p=nr({inputs:{x:p},backend:r,attrs:{axis:d[e]-(o.length-f),keepDims:!1}}),m.push(p)),f--)}for(const e of m)e!==p&&r.disposeData(e.dataId);return p}},sr=be({opType:M.ELU}),ar={kernelName:t.Elu,backendName:"webgpu",kernelFunc:sr},or=xe({opType:B.EQUAL,dtype:"bool",cpuKernelImpl:rt}),ur={kernelName:t.Equal,backendName:"webgpu",kernelFunc:or},lr=be({opType:M.EXP,cpuKernelImpl:it,dtype:"float32"}),dr={kernelName:t.Exp,backendName:"webgpu",kernelFunc:lr};function hr(e){const{inputs:n,attrs:r,backend:i}=e,{dim:s}=r,{input:a}=n,o=a.shape.length,u=a.shape.slice();let l=s;return s<0&&(t.util.assert(-(o+1)<=s,(()=>`Axis must be in the interval [${-(o+1)}, ${o}]`)),l=o+s+1),u.splice(l,0,1),ae({inputs:{x:a},backend:i,attrs:{shape:u}})}const cr={kernelName:t.ExpandDims,backendName:"webgpu",kernelFunc:hr},pr=be({opType:M.EXPM1,cpuKernelImpl:st}),fr={kernelName:t.Expm1,backendName:"webgpu",kernelFunc:pr};class mr{constructor(e){this.outputShape=[],this.variableNames=["x"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=R(this.outputShape),this.dispatch=S(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="flipLeftRight"}getUserCode(){return`\n      ${m("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let coordX = uniforms.xShape[2] - coords[2] - 1;\n          let outputValue = getX(coords[0], coords[1], coordX, coords[3]);\n          setOutputAtIndex(index, outputValue);\n        }\n      }\n    `}}const gr={kernelName:t.FlipLeftRight,backendName:"webgpu",kernelFunc:({inputs:e,backend:t})=>{const{image:n}=e,r=t,i=new mr(n.shape);return r.runWebGPUProgram(i,[n],n.dtype)}},br=be({opType:M.FLOOR,cpuKernelImpl:at}),xr={kernelName:t.Floor,backendName:"webgpu",kernelFunc:br},wr=xe({opType:B.INT_DIV,dtype:"int32"}),Ir={kernelName:t.FloorDiv,backendName:"webgpu",kernelFunc:wr};class kr{constructor(e,t,n=!1){this.isFromPixels=!0,this.outputShape=[0],this.variableNames=[],this.workGroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout=R(this.outputShape),this.dispatch=S(this.dispatchLayout,this.outputShape,this.workGroupSize,[t,1,1]),this.importVideo=n,this.shaderKey=`fromPixels_${this.importVideo}`}getUserCode(){const e=this.importVideo?"textureLoad(src, vec2<i32>(coords.yx));":"textureLoad(src, vec2<i32>(coords.yx), 0)";return`\n      @binding(1) @group(0) var src: ${this.importVideo?"texture_external":"texture_2d<f32>"};\n      ${m("index")} {\n        let flatIndex = index * uniforms.numChannels;\n        if (flatIndex < uniforms.size) {\n          let coords = getCoordsFromIndex(flatIndex);\n          let values = ${e};\n          for (var i = 0; i < uniforms.numChannels; i = i + 1) {\n            result[flatIndex + i] = i32(floor(255.0 * values[i]));\n          }\n        }\n      }\n  `}}const yr={kernelName:t.FromPixels,backendName:"webgpu",kernelFunc:function(e){const{inputs:n,backend:r,attrs:i}=e;let{pixels:s}=n;const{numChannels:a}=i;if(null==s)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");const o="undefined"!=typeof HTMLVideoElement&&s instanceof HTMLVideoElement,u="undefined"!=typeof HTMLImageElement&&s instanceof HTMLImageElement,l="undefined"!=typeof HTMLCanvasElement&&s instanceof HTMLCanvasElement||"undefined"!=typeof OffscreenCanvas&&s instanceof OffscreenCanvas,d="undefined"!=typeof ImageBitmap&&s instanceof ImageBitmap,[h,c]=o?[s.videoWidth,s.videoHeight]:[s.width,s.height],p=[c,h,a],f=o||u;if(d||l||f){let e;{if(f){const e=t.env().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");null!=Sr&&e===vr||(vr=e,Sr=document.createElement("canvas").getContext("2d",{willReadFrequently:vr})),Sr.canvas.width=h,Sr.canvas.height=c,Sr.drawImage(s,0,0,h,c),s=Sr.canvas}const n=GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,i="rgba8unorm",a=r.textureManager.acquireTexture(p[1],p[0],i,n);r.queue.copyExternalImageToTexture({source:s},{texture:a},[p[1],p[0]]),e={width:h,height:c,format:i,usage:n,texture:a}}const n=t.util.sizeFromShape(p),i=t.util.computeStrides(p),o=new kr(p,a,false),u=[{type:"uint32",data:[n]},{type:"uint32",data:[a]},{type:"uint32",data:[...i]}],l=r.makeTensorInfo([c,h],"int32");r.tensorMap.get(l.dataId).resourceInfo=e;const d=r.runWebGPUProgram(o,[l],"int32",u);return r.disposeData(l.dataId),d}const m=s.data;let g=m;if(null!=a&&4!==a){g=new Uint8Array(s.width*s.height*a);const e=m.length;let t=0;for(let n=0;n<e;n++)n%4<a&&(g[t++]=m[n])}const b=r.makeTensorInfo(p,"int32",new Int32Array(g));return r.uploadToGPU(b.dataId),b}};let Sr,vr=t.env().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");class Cr{constructor(e,n,r,i,s){this.uniforms="varianceEpsilon : f32,",this.workGroupSize=[128,1,1],this.size=!0,this.variableNames=["x","mean","variance"],t.backend_util.assertAndGetBroadcastShape(e,n),t.backend_util.assertAndGetBroadcastShape(e,r),this.outputShape=e,this.dispatchLayout=R(this.outputShape),this.dispatch=S(this.dispatchLayout,this.outputShape,this.workGroupSize),null!=i&&(t.backend_util.assertAndGetBroadcastShape(e,i),this.variableNames.push("offset")),null!=s&&(t.backend_util.assertAndGetBroadcastShape(e,s),this.variableNames.push("scale")),this.offsetShape=i,this.scaleShape=s,this.shaderKey="batchNorm"}getUserCode(){let e="0.0";null!=this.offsetShape&&(e="getOffsetByOutputIndex(index)");let t="1.0";null!=this.scaleShape&&(t="getScaleByOutputIndex(index)");return`\n      ${m("index")} {\n        if (index < uniforms.size)\n        {\n          let xValue = getXByOutputIndex(index);\n          let meanValue = getMeanByOutputIndex(index);\n          let varianValue = getVarianceByOutputIndex(index);\n          let offsetValue = ${e};\n          let scaleValue = ${t};\n          let inv = scaleValue * inverseSqrt(varianValue + f32(uniforms.varianceEpsilon));\n          setOutputAtIndex(index,dot(vec3<f32>(xValue, -meanValue, offsetValue), vec3<f32>(inv, inv, 1.0)));\n        }\n      }\n  `}}const $r={kernelName:t.FusedBatchNorm,backendName:"webgpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r,scale:i,offset:s,mean:a,variance:o}=e,{varianceEpsilon:u}=t,l=n,d=[r,a,o];let h=null;null!=s&&(h=s.shape,d.push(s));let c=null;null!=i&&(c=i.shape,d.push(i));const p=new Cr(r.shape,a.shape,o.shape,h,c),f=[{type:"float32",data:[u]}];return l.runWebGPUProgram(p,d,r.dtype,f)}};const Rr={kernelName:t.FusedConv2D,backendName:"webgpu",kernelFunc:function(e){const{inputs:n,backend:r,attrs:i}=e,{x:s,filter:a,bias:o,preluActivationWeights:u}=n,{strides:l,pad:d,dataFormat:h,dilations:c,dimRoundingMode:p,activation:f,leakyreluAlpha:m}=i,g=t.backend_util.convertConv2DDataFormat(h);return Pn({x:s,filter:a,convInfo:t.backend_util.computeConv2DInfo(s.shape,a.shape,l,c,d,p,!1,g),backend:r,bias:o,preluActivationWeights:u,leakyreluAlpha:m,activation:f})}};const Tr={kernelName:t.FusedDepthwiseConv2D,backendName:"webgpu",kernelFunc:function(e){const{inputs:n,backend:r,attrs:i}=e,{x:s,filter:a,bias:o,preluActivationWeights:u}=n,{strides:l,pad:d,dilations:h,dimRoundingMode:c,activation:p,leakyreluAlpha:f}=i;let m=h;null==m&&(m=[1,1]),t.util.assert(t.backend_util.eitherStridesOrDilationsAreOne(l,m),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`));const g=t.backend_util.computeConv2DInfo(s.shape,a.shape,l,m,d,c,!0),b=[s,a],x=null!=o,w=null!=u;x&&b.push(o),w&&b.push(u);const I=[{type:"int32",data:[g.padInfo.top,g.padInfo.left]},{type:"int32",data:[g.inHeight,g.inWidth]}];let k;return g.inHeight>4&&g.inWidth>4&&g.strideWidth<=2&&g.inChannels===g.outChannels&&1===g.dilationHeight&&1===g.dilationWidth&&g.inChannels%4==0?k=new Qn(g,x,p,w):(k=new Zn(g,x,p,w),I.push({type:"int32",data:[g.filterHeight]},{type:"int32",data:[g.filterWidth]},{type:"int32",data:[g.strideHeight,g.strideWidth]},{type:"int32",data:[g.dilationHeight,g.dilationWidth]})),"leakyrelu"===p&&(I.push({type:"float32",data:[f]}),k.uniforms+=" alpha : f32,"),r.runWebGPUProgram(k,b,"float32",I)}};class Ar{constructor(e,t){this.variableNames=["A","indices"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=R(this.outputShape),this.dispatch=S(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey=`gathernd_${e}`,this.sliceDim=e,this.uniforms=`sliceDim : i32, strides : ${p(e)},`}getUserCode(){let e;e=this.sliceDim>1?"uniforms.strides[j]":"uniforms.strides";return`\n      ${m("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          var flattenIndex = 0;\n          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {\n            let indexTemp = i32(round(getIndices(coords[0], j)));\n            let strideNum = ${e};\n            flattenIndex = flattenIndex + indexTemp * strideNum;\n          }\n\n          setOutputAtIndex(index, getA(flattenIndex, coords[1]));\n        }\n      }\n      `}}const Pr={kernelName:t.GatherNd,backendName:"webgpu",kernelFunc:function(e){const{inputs:n,backend:r}=e,{params:i,indices:s}=n,a=s.shape,o=a[a.length-1],u=t.util.sizeFromShape(i.shape),[l,d,h,c]=t.backend_util.prepareAndValidate(i,s),p=ae({inputs:{x:s},backend:r,attrs:{shape:[d,o]}}),f=ae({inputs:{x:i},backend:r,attrs:{shape:[t.util.sizeFromShape(i.shape)/h,h]}});if(r.shouldExecuteOnCPU([i,s])||"string"===i.dtype){const e=r.readSync(s.dataId),t=r.bufferSync(i),n=ot(e,t,i.dtype,d,o,h,c,i.shape,u);return r.makeTensorInfo(l,i.dtype,n.values)}const m=new Ar(o,[d,h]),g=[{type:"int32",data:[o]},{type:"int32",data:c}],b=r.runWebGPUProgram(m,[f,p],f.dtype,g),x=ae({inputs:{x:b},backend:r,attrs:{shape:l}});return r.disposeData(p.dataId),r.disposeData(f.dataId),r.disposeData(b.dataId),x}};class zr{constructor(e,t){this.variableNames=["A","indices"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e.slice(),this.aShape=e,this.outputShape=t,this.dispatchLayout=R(this.outputShape),this.dispatch=S(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="gather"}getUserCode(){const e=function(e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let r=0;r<e.length;r++)2===r?n.push("indexZ"):n.push(`${t[r]}`);return n.join()}(this.aShape);return`\n      ${m("index")} {\n        if (index < uniforms.size) {\n          let resRC = getCoordsFromIndex(index);\n          let indexZ = i32(getIndices(resRC.x, resRC.z));\n          let inBounds = select(0.0, 1.0, indexZ >= 0 && indexZ < uniforms.aShape[2]);\n          setOutputAtIndex(index, inBounds * getA(${e}));\n        }\n      }\n    `}}function _r(e){const{inputs:n,backend:r,attrs:i}=e,{x:s,indices:a}=n,{axis:o,batchDims:u}=i,l=t.util.parseAxisParam(o,s.shape)[0],d=t.backend_util.segment_util.collectGatherOpShapeInfo(s,a,l,u),h=t.util.sizeFromShape(a.shape),c=[],p=ae({inputs:{x:s},backend:r,attrs:{shape:[d.batchSize,d.outerSize,d.dimSize,d.sliceSize]}}),f=ae({inputs:{x:a},backend:r,attrs:{shape:[d.batchSize,h/d.batchSize]}});c.push(p),c.push(f);const m=[d.batchSize,d.outerSize,h/d.batchSize,d.sliceSize];if(r.shouldExecuteOnCPU([s,a])){const e=r.tensorMap.get(f.dataId).values,n=t.buffer(f.shape,f.dtype,e),i=r.tensorMap.get(p.dataId).values,s=t.buffer(p.shape,p.dtype,i),a=ut(s,n,m);return c.forEach((e=>r.disposeData(e.dataId))),r.makeTensorInfo(d.outputShape,a.dtype,a.values)}const g=new zr(p.shape,m),b=r.runWebGPUProgram(g,[p,f],p.dtype);c.push(b);const x=ae({inputs:{x:b},backend:r,attrs:{shape:d.outputShape}});return c.forEach((e=>r.disposeData(e.dataId))),x}const Er={kernelName:t.GatherV2,backendName:"webgpu",kernelFunc:_r},Nr=xe({opType:B.GREATER,cpuKernelImpl:dt,dtype:"bool"}),Br={kernelName:t.Greater,backendName:"webgpu",kernelFunc:Nr},Fr=xe({opType:B.GREATER_EQUAL,dtype:"bool",cpuKernelImpl:lt}),Or={kernelName:t.GreaterEqual,backendName:"webgpu",kernelFunc:Fr},Dr=be({opType:M.IS_NAN,dtype:"bool"}),Gr={kernelName:t.IsNan,backendName:"webgpu",kernelFunc:Dr};const Lr={kernelName:t.LeakyRelu,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{alpha:s}=r,a=[{type:"float32",data:[s]}],o=new ge(i.shape,M.LEAKYRELU);return o.uniforms="alpha : f32,",n.runWebGPUProgram(o,[i],"float32",a)}},Ur=xe({opType:B.LESS,dtype:"bool",cpuKernelImpl:ct}),Mr={kernelName:t.Less,backendName:"webgpu",kernelFunc:Ur},Wr=xe({opType:B.LESS_EQUAL,dtype:"bool",cpuKernelImpl:ht}),Vr={kernelName:t.LessEqual,backendName:"webgpu",kernelFunc:Wr},Hr=be({opType:M.LOG,cpuKernelImpl:pt}),qr={kernelName:t.Log,backendName:"webgpu",kernelFunc:Hr},Xr=xe({opType:B.LOGICAL_AND,dtype:"bool"}),Kr={kernelName:t.LogicalAnd,backendName:"webgpu",kernelFunc:Xr},jr=be({opType:M.LOGICAL_NOT}),Yr={kernelName:t.LogicalNot,backendName:"webgpu",kernelFunc:jr},Qr=xe({opType:B.MAX,cpuKernelImpl:mt}),Zr={kernelName:t.Maximum,backendName:"webgpu",kernelFunc:Qr};const Jr={kernelName:t.MaxPool,backendName:"webgpu",kernelFunc:function(e){const{inputs:n,backend:r,attrs:i}=e,{x:s}=n,{filterSize:a,strides:o,pad:u,dimRoundingMode:l}=i;return nn(s,t.backend_util.computePool2DInfo(s.shape,a,o,1,u,l),"max",r)}};const ei={kernelName:t.Min,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:s,keepDims:a}=r;return Qt(i,s,a,"min",n)}},ti=xe({opType:B.MIN,cpuKernelImpl:gt}),ni={kernelName:t.Minimum,backendName:"webgpu",kernelFunc:ti};class ri{constructor(e,t,n){this.uniforms="",this.variableNames=["x"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1])),this.dispatchLayout=R(this.outputShape),this.dispatch=S(this.dispatchLayout,this.outputShape,this.workGroupSize),this.xShape=e,t.map(((e,t)=>{this.uniforms+=` pad${t} : vec2<i32>,`})),this.offset="reflect"===n?0:1,this.shaderKey=`mirrorPad_${n}`}getUserCode(){const e=this.xShape.length,t=this.xShape.map(((e,t)=>`uniforms.pad${t}[0]`)).join(","),n=this.xShape.map(((t,n)=>`uniforms.pad${n}[0] + uniforms.xShape${e>1?`[${n}]`:""}`)).join(","),r=1===e?"start":"start[i]",i=1===e?"end":"end[i]",s=1===e?"outC":"outC[i]",a=p(e),o=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return`\n      ${m("index")} {\n        if (index < uniforms.size) {\n          let start = ${a}(${t});\n          let end = ${a}(${n});\n          var outC = getCoordsFromIndex(index);\n          for (var i = 0; i < ${e}; i = i + 1) {\n            if (${s} < ${r}) {\n              ${s} = ${r} * 2 - ${s} - ${this.offset};\n            } else if(${s} >= ${i}) {\n              ${s} = (${i} - 1) * 2 - ${s} + ${this.offset};\n            }\n          }\n          let coords = outC - start;\n          setOutputAtIndex(index, getX(${o}));\n        }\n      }\n    `}}const ii={kernelName:t.MirrorPad,backendName:"webgpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{paddings:i,mode:s}=t,a=n,o=i.map((e=>({type:"int32",data:[e[0],e[1]]}))),u=new ri(r.shape,i,s);return a.runWebGPUProgram(u,[r],r.dtype,o)}};const si={kernelName:t.Neg,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])){const e=n.tensorMap.get(r.dataId),[t,i]=xt(e.values,r.shape,r.dtype);return n.makeTensorInfo(i,r.dtype,t)}const i=new ge(r.shape,M.NEG);return n.runWebGPUProgram(i,[r],r.dtype)}};const ai={kernelName:t.NonMaxSuppressionV3,backendName:"webgpu",kernelFunc:function(e){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:n,backend:r,attrs:i}=e,{boxes:s,scores:a}=n,{maxOutputSize:o,iouThreshold:u,scoreThreshold:l}=i,d=r.readSync(s.dataId),h=r.readSync(a.dataId),{selectedIndices:c}=t.kernel_impls.nonMaxSuppressionV3Impl(d,h,o,u,l);return r.makeTensorInfo([c.length],"int32",new Int32Array(c))}};const oi={kernelName:t.NonMaxSuppressionV5,backendName:"webgpu",kernelFunc:function(e){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:n,backend:r,attrs:i}=e,{boxes:s,scores:a}=n,{maxOutputSize:o,iouThreshold:u,scoreThreshold:l,softNmsSigma:d}=i,h=r.readSync(s.dataId),c=r.readSync(a.dataId),p=o,f=u,m=l,g=d,{selectedIndices:b,selectedScores:x}=t.kernel_impls.nonMaxSuppressionV5Impl(h,c,p,f,m,g);return[r.makeTensorInfo([b.length],"int32",new Int32Array(b)),r.makeTensorInfo([x.length],"float32",new Float32Array(x))]}};function ui(e){const{inputs:t,backend:n}=e,{x:r}=t;if("complex64"===r.dtype){const e=pn({inputs:{input:r},backend:n}),t=ui({inputs:{x:e},backend:n}),i=yn({inputs:{input:r},backend:n}),s=ui({inputs:{x:i},backend:n}),a=fe({inputs:{real:t,imag:s},backend:n});return n.disposeData(e.dataId),n.disposeData(t.dataId),n.disposeData(i.dataId),n.disposeData(s.dataId),a}return ie({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:n})}const li={kernelName:t.ZerosLike,backendName:"webgpu",kernelFunc:ui};const di={kernelName:t.OnesLike,backendName:"webgpu",kernelFunc:function e(t){const{inputs:n,backend:r}=t,{x:i}=n;if("string"===i.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===i.dtype){const t=pn({inputs:{input:i},backend:r}),n=e({inputs:{x:t},backend:r}),s=yn({inputs:{input:i},backend:r}),a=ui({inputs:{x:s},backend:r}),o=fe({inputs:{real:n,imag:a},backend:r});return r.disposeData(t.dataId),r.disposeData(n.dataId),r.disposeData(s.dataId),r.disposeData(a.dataId),o}return ie({attrs:{shape:i.shape,dtype:i.dtype,value:1},backend:r})}};const hi={kernelName:t.Pack,backendName:"webgpu",kernelFunc:function(e){const{inputs:n,backend:r,attrs:i}=e,{axis:s}=i;if(1===n.length)return hr({inputs:{input:n[0]},backend:r,attrs:{dim:s}});const a=n[0].shape,o=n[0].dtype;n.forEach((e=>{t.util.assertShapesMatch(a,e.shape,"All tensors passed to stack must have matching shapes"),t.util.assert(o===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const u=[],l=Cn({inputs:n.map((e=>{const t=hr({inputs:{input:e},backend:r,attrs:{dim:s}});return u.push(t),t})),backend:r,attrs:{axis:s}});return u.forEach((e=>r.disposeData(e.dataId))),l}};class ci{constructor(e,t){this.variableNames=["x"],this.uniforms="constantValue : f32,",this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1])),this.dispatchLayout=R(this.outputShape),this.dispatch=S(this.dispatchLayout,this.outputShape,this.workGroupSize),t.map(((e,t)=>{this.uniforms+=` pad${t} : vec2<i32>,`})),this.xShape=e,this.shaderKey="pad"}getUserCode(){const e=this.xShape.length,t=p(e),n=this.xShape.map(((e,t)=>`uniforms.pad${t}[0]`)).join(","),r=this.xShape.map(((t,n)=>`uniforms.pad${n}[0] + uniforms.xShape${e>1?`[${n}]`:""}`)).join(","),i=e>1?`${t}(${n})`:`${n}`,s=e>1?`${t}(${r})`:`${r}`,a=e>1?"any(outC < start)":"outC < start",o=e>1?"any(outC >= end)":"outC >= end",u=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return`\n      ${m("index")} {\n        if (index < uniforms.size) {\n          let start = ${i};\n          let end = ${s};\n          let outC = getCoordsFromIndex(index);\n\n          if (${a} || ${o}) {\n            setOutputAtIndex(index, uniforms.constantValue);\n          } else {\n            let coords = outC - start;\n            setOutputAtIndex(index, getX(${u}));\n          }\n        }\n      }\n    `}}const pi=e=>{const{inputs:n,backend:r,attrs:i}=e,{x:s}=n,{paddings:a,constantValue:o}=i;if(a.every((e=>t.util.arraysEqual(e,[0,0]))))return ce({inputs:{x:s},backend:r});if(0===t.util.sizeFromShape(s.shape)){return ie({backend:r,attrs:{shape:a.map(((e,t)=>e[0]+s.shape[t]+e[1])),value:o,dtype:s.dtype}})}const u=[{type:"float32",data:[o]}];a.map((e=>u.push({type:"int32",data:[e[0],e[1]]})));const l=new ci(s.shape,a);return r.runWebGPUProgram(l,[s],s.dtype,u)},fi={kernelName:t.PadV2,backendName:"webgpu",kernelFunc:pi},mi=xe({opType:B.POW}),gi={kernelName:t.Pow,backendName:"webgpu",kernelFunc:mi};const bi={kernelName:t.Prelu,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r,alpha:i}=t,s=new he(B.PRELU,r.shape,i.shape);return n.runWebGPUProgram(s,[r,i],"float32")}};const xi={kernelName:t.Prod,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:s,keepDims:a}=r;return Qt(i,s,a,"prod",n)}},wi={kernelName:t.Range,backendName:"webgpu",kernelFunc:e=>{const{backend:t,attrs:n}=e,{start:r,stop:i,step:s,dtype:a}=n,o=kt(r,i,s,a);return t.makeTensorInfo([o.length],a,o)}},Ii=xe({opType:B.DIV}),ki={kernelName:t.RealDiv,backendName:"webgpu",kernelFunc:Ii},yi=be({opType:M.RECIPROCAL}),Si={kernelName:t.Reciprocal,backendName:"webgpu",kernelFunc:yi},vi=be({opType:M.RELU}),Ci={kernelName:t.Relu,backendName:"webgpu",kernelFunc:vi},$i=be({opType:M.RELU6}),Ri={kernelName:t.Relu6,backendName:"webgpu",kernelFunc:$i};class Ti{constructor(e,t,n){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, halfPixelCenters : f32,",this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],t,n,e[3]],this.dispatchLayout=R(this.outputShape),this.dispatch=S(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="resizeBilinear"}getUserCode(){return`\n      ${m("index")} {\n        if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n          let b = coords[0];\n          let d = coords[3];\n          let rc = coords.yz;\n\n          let effectiveInSize = vec2<f32>(\n            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveOutSize = vec2<f32>(\n            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveInputOverOutputRatioRC =\n              effectiveInSize / effectiveOutSize;\n\n          // Fractional source index\n          let sourceFracIndexRC =\n            (vec2<f32>(rc) + vec2<f32>(uniforms.halfPixelCenters)) *\n            effectiveInputOverOutputRatioRC - vec2<f32>(uniforms.halfPixelCenters);\n\n          // Compute the four integer indices.\n          let sourceFloorRC = vec2<i32>(sourceFracIndexRC);\n          let sourceCeilRC = vec2<i32>(\n            min(vec2<f32>(uniforms.xShape.yz) - vec2<f32>(1.0), ceil(sourceFracIndexRC)));\n\n          let topLeft = getX(b, sourceFloorRC.x, sourceFloorRC.y, d);\n          let bottomLeft = getX(b, sourceCeilRC.x, sourceFloorRC.y, d);\n          let topRight = getX(b, sourceFloorRC.x, sourceCeilRC.y, d);\n          let bottomRight = getX(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n          let fracRC = sourceFracIndexRC - vec2<f32>(sourceFloorRC);\n\n          let top = topLeft + (topRight - topLeft) * fracRC.y;\n          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n          let newValue = top + (bottom - top) * fracRC.x;\n\n          setOutputAtIndex(index, newValue);\n        }\n      }\n    `}}const Ai={kernelName:t.ResizeBilinear,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:i}=t,{alignCorners:s,size:a,halfPixelCenters:o}=r,[u,l]=a,d=[{type:"float32",data:[s&&u>1?1:0,s&&l>1?1:0]},{type:"float32",data:[o?.5:0]}],h=new Ti(i.shape,u,l);return n.runWebGPUProgram(h,[i],"float32",d)}};class Pi{constructor(e,t,n,r){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, roundBase : f32,",this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],t,n,e[3]],this.dispatchLayout=R(this.outputShape),this.dispatch=S(this.dispatchLayout,this.outputShape,this.workGroupSize),this.halfPixelCenters=r,this.shaderKey=`resizeNearest_${r}`}getUserCode(){let e;e=this.halfPixelCenters?"max((vec2<f32>(rc) + vec2<f32>(0.5)) * effectiveInputOverOutputRatioRC, vec2<f32>(0.0))":"vec2<f32>(rc) * effectiveInputOverOutputRatioRC";return`\n      ${m("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let b = coords[0];\n          let d = coords[3];\n          let rc = coords.yz;\n\n          let effectiveInSize = vec2<f32>(\n            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveOutSize = vec2<f32>(\n            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveInputOverOutputRatioRC =\n              effectiveInSize / effectiveOutSize;\n\n          // Fractional source index\n          let sourceFracIndexRC = ${e};\n\n          // Compute the coordinators of nearest neighbor point.\n          let inputShapeRC = vec2<f32>(f32(uniforms.xShape.y), f32(uniforms.xShape.z));\n          let sourceNearestRC = vec2<i32>(\n            min(inputShapeRC - 1.0, floor(sourceFracIndexRC + uniforms.roundBase)));\n          let newValue = getX(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n          setOutputAtIndex(index, newValue);\n        }\n      }\n    `}}const zi={kernelName:t.ResizeNearestNeighbor,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:i}=t,{alignCorners:s,halfPixelCenters:a,size:o}=r,[u,l]=o,d=[{type:"float32",data:[s&&u>1?1:0,s&&l>1?1:0]},{type:"float32",data:[s?.5:0]}],h=new Pi(i.shape,u,l,a);return n.runWebGPUProgram(h,[i],i.dtype,d)}};class _i{constructor(e,t){this.outputShape=[],this.variableNames=["x"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=R(this.outputShape),this.dispatch=S(this.dispatchLayout,this.outputShape,this.workGroupSize),this.uniforms="centerX : f32, centerY : f32, sinRadians : f32,\n          cosRadians : f32,",this.shaderKey="rotate",this.outputShape=e,"number"==typeof t?(this.uniforms+=" fillValue : f32,",this.fillSnippet="var outputValue = uniforms.fillValue;",this.shaderKey+="_float"):(this.uniforms+=" fillValue : vec3<f32>,",this.fillSnippet="var outputValue = uniforms.fillValue[coords[3]];",this.shaderKey+="_vec3")}getUserCode(){return`\n        ${m("index")} {\n          if (index < uniforms.size) {\n            let coords = getCoordsFromIndex(index);\n            let coordXFloat = (f32(coords[2]) - uniforms.centerX) *\n                uniforms.cosRadians - (f32(coords[1]) - uniforms.centerY) *\n                uniforms.sinRadians;\n            let coordYFloat = (f32(coords[2]) - uniforms.centerX) *\n                uniforms.sinRadians + (f32(coords[1]) - uniforms.centerY) *\n                uniforms.cosRadians;\n            let coordX = i32(round(coordXFloat + uniforms.centerX));\n            let coordY = i32(round(coordYFloat + uniforms.centerY));\n            ${this.fillSnippet}\n            if(coordX >= 0 && coordX < uniforms.xShape[2] && coordY >= 0 &&\n                coordY < uniforms.xShape[1]) {\n              outputValue = getX(coords[0], coordY, coordX, coords[3]);\n            }\n            setOutputAtIndex(index, outputValue);\n          }\n        }\n      `}}const Ei={kernelName:t.RotateWithOffset,backendName:"webgpu",kernelFunc:({inputs:e,attrs:n,backend:r})=>{const{image:i}=e,{radians:s,fillValue:a,center:o}=n,u=r,l=new _i(i.shape,a),[d,h]=t.backend_util.getImageCenter(o,i.shape[1],i.shape[2]),c=[{type:"float32",data:[d]},{type:"float32",data:[h]},{type:"float32",data:[Math.sin(s)]},{type:"float32",data:[Math.cos(s)]}];"number"==typeof a?c.push({type:"float32",data:[Number.parseFloat(a.toFixed(2))]}):c.push({type:"float32",data:a});return u.runWebGPUProgram(l,[i],i.dtype,c)}},Ni=be({opType:M.RSQRT,cpuKernelImpl:yt}),Bi={kernelName:t.Rsqrt,backendName:"webgpu",kernelFunc:Ni};class Fi{constructor(e,t,n,r,i,s,a,o=!0){this.variableNames=["updates","indices"],this.workGroupSize=[64,1,1],this.atomic=!0,this.outputShape=s,this.type=a,this.sumDupeIndices=o,this.dispatchLayout=R(e),this.dispatch=S(this.dispatchLayout,e,this.workGroupSize),this.sliceDimGreaterThanOne=t>1,this.shaderKey=`scatter_${n}_${r}_${this.sliceDimGreaterThanOne}_${a}_${o}`;const u=p(i.length);this.uniforms=`sliceDim : i32, strides: ${u}, size: i32,`,this.updatesRank=r,this.indicesRank=n}getUserCode(){let e="";1===this.indicesRank?e="coords[0]":2===this.indicesRank&&(e="coords[0], j");const t=`getIndices(${e})`,n=this.sliceDimGreaterThanOne?"uniforms.strides[j]":"uniforms.strides";let r="",i="";1===this.dispatchLayout.x.length?(r="flattenedIndex",i="\n      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {\n        return index;\n      }\n      "):2===this.dispatchLayout.x.length&&(r="vec2<i32>(flattenedIndex, coords[1])",i="\n      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {\n        // N.B. |updates| could be a scalar tensor, conceptually representing a\n        // 2D tensor with all values equal to that. By design, its size must be\n        // the same as |outShape[1]| in one dimension, and |indicesShape[0]|\n        // gives the other.\n        let sliceSize = uniforms.outShape[1];\n        let d0 = index / sliceSize;\n        let d1 = index - d0 * sliceSize;\n        return vec2<i32>(d0, d1);\n      }\n      ");const s=`getUpdates(${Array.from({length:this.updatesRank},((e,t)=>`coords[${t}]`)).join(", ")})`;return`\n    ${i}\n\n      ${m("index")} {\n        if (index < uniforms.size) {\n          let coords = getUpdatesCoordsFromFlatIndex(index);\n          var flattenedIndex = 0;\n          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {\n            let indexInside = i32(round(${t}));\n            flattenedIndex = flattenedIndex + indexInside * ${n};\n          }\n          let updateValue =\n              ${k(this.type,!1)}(${s});\n          let flatIndex = getOutputIndexFromCoords(${r});\n\n          ${((e,t)=>{let n=`atomicAdd(${e}, bitcast<i32>(${t}))`;"float32"===this.type&&(n=`\n          {\n            var oldBits = 0;\n            var newBits = bitcast<i32>(${t});\n            loop {\n              let info = atomicCompareExchangeWeak(${e}, oldBits, newBits);\n              if (info.exchanged) {\n                break;\n              }\n              oldBits = info.old_value;\n              let oldValue = bitcast<f32>(oldBits);\n              let newValue = oldValue + (${t});\n              newBits = bitcast<i32>(newValue);\n            }\n          }\n        `);const r=`atomicStore(${e}, bitcast<i32>(${t}));`;return this.sumDupeIndices?n:r})("&result[flatIndex]","updateValue")};\n        }\n      }`}}const Oi={kernelName:t.ScatterNd,backendName:"webgpu",kernelFunc:function(e){const{inputs:n,backend:r,attrs:i}=e,{indices:s,updates:a}=n,{shape:o}=i,{sliceRank:u,numUpdates:l,sliceSize:d,strides:h,outputSize:c}=t.backend_util.calculateShapes(a,s,o),p=[c/d,d];if(0===c)return r.makeTensorInfo(o,s.dtype);const f=ae({inputs:{x:s},backend:r,attrs:{shape:[l,u]}}),m=ae({inputs:{x:a},backend:r,attrs:{shape:[l,d]}}),g=m.dtype,b=ie({backend:r,attrs:{shape:p,value:0,dtype:g}}),x=[{type:"int32",data:[u]},{type:"int32",data:h},{type:"int32",data:[t.util.sizeFromShape(m.shape)]}],w=new Fi(m.shape,u,f.shape.length,m.shape.length,h,p,g),I=r.runWebGPUProgram(w,[m,f],g,x,b),k=ae({inputs:{x:I},backend:r,attrs:{shape:o}});return r.disposeData(f.dataId),r.disposeData(m.dataId),r.disposeData(I.dataId),k}};class Di{constructor(e,t,n){this.variableNames=["c","a","b"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=R(this.outputShape),this.dispatch=S(this.dispatchLayout,this.outputShape,this.workGroupSize),this.cRank=e,this.rank=n,this.shaderKey="select"}getUserCode(){let e,t;if(this.rank>4)throw Error(`Where for rank ${this.rank} is not yet supported`);if(1===this.rank)t="resRC",e="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[],i=[];for(let e=0;e<this.outputShape.length;e++)i.push(`${n[e]}`),e<this.cRank&&r.push(`${n[e]}`);e=r.join(),t=i.join()}return`\n      ${m("index")} {\n        if (index < uniforms.size) {\n          let resRC = getCoordsFromIndex(index);\n          let cVal = getC(${e});\n          if (cVal >= 1.0) {\n            setOutputAtIndex(index, getA(${t}));\n          } else {\n            setOutputAtIndex(index, getB(${t}));\n          }\n        }\n      }\n    `}}const Gi={kernelName:t.Select,backendName:"webgpu",kernelFunc:function(e){const{inputs:n,backend:r}=e,{condition:i,t:s,e:a}=n,o=new Di(i.shape.length,s.shape,s.shape.length);return r.runWebGPUProgram(o,[i,s,a],t.upcastType(s.dtype,a.dtype))}},Li=be({opType:M.SIGMOID}),Ui={kernelName:t.Sigmoid,backendName:"webgpu",kernelFunc:Li},Mi=be({opType:M.SIN}),Wi={kernelName:t.Sin,backendName:"webgpu",kernelFunc:Mi},Vi=be({opType:M.SINH}),Hi={kernelName:t.Sinh,backendName:"webgpu",kernelFunc:Vi},qi=xe({opType:B.SUB,cpuKernelImpl:Tt,supportsComplex:!0}),Xi={kernelName:t.Sub,backendName:"webgpu",kernelFunc:qi};const Ki={kernelName:t.Softmax,backendName:"webgpu",kernelFunc:function(e){const{inputs:n,backend:r,attrs:i}=e,{logits:s}=n,{dim:a}=i,o=t.util.parseAxisParam([a],s.shape),u=Zt({inputs:{x:s},backend:r,attrs:{reductionIndices:o,keepDims:!1}}),l=t.backend_util.expandShapeToKeepDim(u.shape,o),d=ae({inputs:{x:u},backend:r,attrs:{shape:l}}),h=qi({inputs:{a:s,b:d},backend:r}),c=lr({inputs:{x:h},backend:r}),p=nr({inputs:{x:c},backend:r,attrs:{axis:o,keepDims:!1}}),f=ae({inputs:{x:p},backend:r,attrs:{shape:l}}),m=Ii({inputs:{a:c,b:f},backend:r});return r.disposeData(u.dataId),r.disposeData(d.dataId),r.disposeData(h.dataId),r.disposeData(c.dataId),r.disposeData(p.dataId),r.disposeData(f.dataId),m}},ji={kernelName:t.SpaceToBatchND,backendName:"webgpu",kernelFunc:e=>{const{inputs:n,backend:r,attrs:i}=e,{x:s}=n,{blockShape:a,paddings:o}=i;t.util.assert(s.shape.length<=4,(()=>"spaceToBatchND for rank > 4 with a WebGPU backend not implemented yet"));const u=a.reduce(((e,t)=>e*t)),l=[[0,0]];l.push(...o);for(let e=1+a.length;e<s.shape.length;++e)l.push([0,0]);const d=[],h=pi({inputs:{x:s},backend:r,attrs:{paddings:l,constantValue:0}}),c=t.backend_util.getReshaped(h.shape,a,u,!1),p=t.backend_util.getPermuted(c.length,a.length,!1),f=t.backend_util.getReshapedPermuted(h.shape,a,u,!1),m=ae({inputs:{x:h},backend:r,attrs:{shape:c}}),g=Mt({inputs:{x:m},backend:r,attrs:{perm:p}}),b=ae({inputs:{x:g},backend:r,attrs:{shape:f}});return d.push(h),d.push(m),d.push(g),d.forEach((e=>r.disposeData(e.dataId))),b}};class Yi{constructor(e,t){this.variableNames=["A"],this.workGroupSize=[64,1,1],this.size=!0;const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[r]*t[r];this.outputShape=n,this.dispatchLayout=R(this.outputShape),this.dispatch=S(this.dispatchLayout,this.outputShape,this.workGroupSize),this.rank=this.outputShape.length,this.shaderKey="tile"}getUserCode(){const e=function(e,t=""){if(e>=5)throw Error(`Tile for rank ${e} is not yet supported`);if(1===e)return`(resRC % ${t}aShape)`;const n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let i=0;i<e;i++)r.push(`(${n[i]} % ${t}aShape[${i}])`);return r.join()}(this.rank,"uniforms.");return`\n      ${m("index")} {\n        if (index < uniforms.size) {\n          let resRC = getCoordsFromIndex(index);\n          setOutputAtIndex(index, getA(${e}));\n        }\n      }\n    `}}function Qi(e){const{inputs:n,backend:r,attrs:i}=e,{x:s}=n,{reps:a}=i;if(r.shouldExecuteOnCPU([s])||"string"===s.dtype||s.shape.length>=5){const e=r.readSync(s.dataId),n="string"===s.dtype?e.map((e=>t.util.decodeString(e))):e,i=t.buffer(s.shape,s.dtype,n),o=At(i,a);return r.makeTensorInfo(o.shape,o.dtype,o.values)}const o=new Yi(s.shape,a);return r.runWebGPUProgram(o,[s],s.dtype)}const Zi={kernelName:t.Tile,backendName:"webgpu",kernelFunc:Qi};const Ji={kernelName:t.SparseToDense,backendName:"webgpu",kernelFunc:function(e){const{inputs:n,backend:r,attrs:i}=e,{sparseIndices:s,sparseValues:a,defaultValue:o}=n,{outputShape:u}=i,{sliceRank:l,numUpdates:d,sliceSize:h,strides:c,outputSize:p}=t.backend_util.calculateShapes(a,s,u),f=!1;if("string"===a.dtype){const e=r.bufferSync(s),n=r.bufferSync(a),i=t.util.decodeString(r.readSync(o.dataId)[0]),m=St(e,n,u,p,h,d,l,c,i,f);return r.makeTensorInfo(u,m.dtype,m.values)}const m=[p/h,h],g=ae({inputs:{x:s},backend:r,attrs:{shape:[d,l]}}),b=a.shape.length?ae({inputs:{x:a},backend:r,attrs:{shape:[d,h]}}):ce({inputs:{x:a},backend:r}),x=b.dtype,w=r.makeTensorInfo([],x,t.util.makeZerosTypedArray(1,x)),I=ae({inputs:{x:o},backend:r,attrs:{shape:Array(m.length).fill(1)}}),k=Qi({inputs:{x:I},backend:r,attrs:{reps:m}}),y=[{type:"int32",data:[l]},{type:"int32",data:c},{type:"int32",data:[t.util.sizeFromShape([d,h])]}];switch(d){case 0:break;case 1:{const e=new Fi([d,h],l,g.shape.length,b.shape.length,c,m,x,f);r.runWebGPUProgram(e,[b,g],x,y,k)}break;default:{const e=new Fi([d,h],l,g.shape.length,w.shape.length,c,m,x,f);r.runWebGPUProgram(e,[w,g],x,y,k)}{const e=new Fi([d,h],l,g.shape.length,b.shape.length,c,m,x);r.runWebGPUProgram(e,[b,g],x,y,k)}}const S=ae({inputs:{x:k},backend:r,attrs:{shape:u}});return r.disposeData(g.dataId),r.disposeData(b.dataId),r.disposeData(I.dataId),r.disposeData(w.dataId),r.disposeData(k.dataId),S}};const es={kernelName:t.SplitV,backendName:"webgpu",kernelFunc:function(e){const{inputs:n,backend:r,attrs:i}=e,{x:s}=n,{numOrSizeSplits:a,axis:o}=i,u=t.util.parseAxisParam(o,s.shape)[0],l=t.backend_util.prepareSplitSize(s,a,u),d=s.shape.length,h=new Array(d).fill(0),c=s.shape.slice();return l.map((e=>{const t=[...c];t[u]=e;const n=un({inputs:{x:s},backend:r,attrs:{begin:h,size:t}});return h[u]+=e,n}))}},ts=be({opType:M.SQRT}),ns={kernelName:t.Sqrt,backendName:"webgpu",kernelFunc:ts},rs={kernelName:t.Square,backendName:"webgpu",kernelFunc:({inputs:e,backend:t})=>{const{x:n}=e,r=t,i=new ge(n.shape,M.SQUARE);return r.runWebGPUProgram(i,[n],n.dtype)}},is=xe({opType:B.SQUARED_DIFFERENCE}),ss={kernelName:t.SquaredDifference,backendName:"webgpu",kernelFunc:is};class as{constructor(e){this.variableNames=["x"],this.workPerThread=1,this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=R(this.outputShape),this.dispatch=S(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]);const t=p(this.outputShape.length);this.uniforms=`begin : ${t},  strides : ${t}, `,this.shaderKey="stridedSlice"}getUserCode(){let e="";if(1===this.outputShape.length)e="coords * uniforms.strides + uniforms.begin";else{let t=0;e=this.outputShape.map(((e,n)=>(t++,1===this.outputShape.length?`coords * uniforms.strides[${n}] + uniforms.begin[${n}]`:`coords[${t-1}] * uniforms.strides[${n}] + uniforms.begin[${n}]`))).join(",")}return`\n       ${m("index")} {\n         if (index < uniforms.size) {\n           let coords = getCoordsFromIndex(index);\n           setOutputAtIndex(index, getX(${e}));\n         }\n       }\n     `}}const os={kernelName:t.StridedSlice,backendName:"webgpu",kernelFunc:function(e){const{inputs:n,backend:r,attrs:i}=e,{x:s}=n,{begin:a,end:o,strides:u,beginMask:l,endMask:d,ellipsisMask:h,newAxisMask:c,shrinkAxisMask:p}=i,{finalShapeSparse:f,finalShape:m,isIdentity:g,sliceDim0:b,isSimpleSlice:x,begin:w,end:I,strides:k}=t.slice_util.sliceInfo(s.shape,a,o,u,l,d,h,c,p);let y;if(g)y=ae({inputs:{x:s},backend:r,attrs:{shape:m}});else if(b||x){t.util.assert(s.shape.length>=1,(()=>`Input must have rank at least 1, got: ${s.shape.length}`));const e=t.slice_util.computeOutShape(w,I,k),n=un({inputs:{x:s},backend:r,attrs:{begin:w,size:e}});y=ae({inputs:{x:n},backend:r,attrs:{shape:m}}),r.disposeData(n.dataId)}else{if(r.shouldExecuteOnCPU([s])){const e=r.readSync(s.dataId),n=t.buffer(s.shape,s.dtype,e),i=$t(f,n,k,w);y=r.makeTensorInfo(m,s.dtype,i.values)}else{const e=new as(f),t=[{type:"int32",data:w},{type:"int32",data:k}],n=r.runWebGPUProgram(e,[s],s.dtype,t);y=ae({inputs:{x:n},backend:r,attrs:{shape:m}}),r.disposeData(n.dataId)}}return y}};const us={kernelName:t.StringNGrams,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{separator:i,nGramWidths:s,leftPad:a,rightPad:o,padWidth:u,preserveShortSequences:l}=r,{data:d,dataSplits:h}=t,c=n.readSync(d.dataId),p=n.readSync(h.dataId),[f,m]=Rt(c,p,i,s,a,o,u,l);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(h.shape,"int32",m)]}},ls=be({opType:M.TANH}),ds={kernelName:t.Tanh,backendName:"webgpu",kernelFunc:ls};class hs{constructor(e){this.variableNames=["x","indices"],this.workGroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=R(this.outputShape),this.dispatch=S(this.dispatchLayout,this.outputShape,this.workGroupSize),this.uniforms="inputSize : i32, firstPass : i32, negativeInf : f32,\n        dir : i32, inc : i32,",this.shaderKey="swap"}getUserCode(){return`\n        ${m("index")} {\n          if (index < uniforms.size) {\n            let outC = getCoordsFromIndex(index);\n            let batch = outC[0];\n            let elemIdx = outC[1];\n            // We compare elements pair-wise within a group of size 2 * inc.\n            // The comparing rule for each group alternates between ascending\n            // and descending. Within each group, we compare each pair at\n            // positions i and i+inc. To decide whether an element at position i\n            // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n            // inc, it is in the first half of the group, we denote it as x0,\n            // otherwise we denote it as x1.\n            // For example, as shown in the Bitonic top K paper referenced\n            // above, Figure5(a) shows that element[1] is in the second half of\n            // the group when group size is 2, but it is in the first half of\n            // the group when group size is 4.\n            let isFirstInPair = elemIdx % (2 * uniforms.inc) < uniforms.inc;\n            var i = 0;\n            if (isFirstInPair) {\n              i = elemIdx;\n            } else {\n              i = elemIdx - uniforms.inc;\n            }\n\n            var i0 = 0;\n            if (uniforms.firstPass == 1) {\n              i0 = i;\n            } else {\n              i0 = i32(getIndices(batch, i));\n            }\n\n            var i1 = 0;\n            if (uniforms.firstPass == 1) {\n              i1 = i + uniforms.inc;\n            } else {\n              i1 = i32(getIndices(batch, i + uniforms.inc));\n            }\n\n            var x0 = f32(0.0);\n            var x1 = f32(0.0);\n            if (i0 < uniforms.inputSize) {\n              x0 = getX(batch, i0);\n            } else {\n              x0 = uniforms.negativeInf;\n            }\n            if (i1 < uniforms.inputSize) {\n              x1 = getX(batch, i1);\n            } else {\n              x1 = uniforms.negativeInf;\n            }\n\n            let reverse = elemIdx % (2 * uniforms.dir) >= uniforms.dir;\n            let isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n            if (reverse == isGreater) {\n              // Elements in opposite order of direction\n              let iTemp = i0;\n              i0 = i1;\n              i1 = iTemp;\n            }\n            if (isFirstInPair) {\n              setOutputAtIndex(index, f32(i0));\n            } else {\n              setOutputAtIndex(index, f32(i1));\n            }\n          }\n        }\n      `}}class cs{constructor(e){this.variableNames=["x","indices"],this.workGroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=R(this.outputShape),this.dispatch=S(this.dispatchLayout,this.outputShape,this.workGroupSize),this.uniforms="inputSize : i32, firstPass : i32, k : i32,",this.shaderKey="merge"}getUserCode(){return`\n        ${m("index")} {\n          if (index < uniforms.size) {\n            let outC = getCoordsFromIndex(index);\n            let batch = outC[0];\n            let elemIdx = outC[1];\n            // The output size is half of the previous size.\n            // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _\n            // (k=4), we only need to output the indices at positions |, the\n            // indices at positions _ can be thrown away, see Figure5(b) After\n            // Phase 2 (Merge phase) in the Bitonic Top K paper referenced\n            // above.\n            // For example, the paper shows we only need to output the orange\n            // bars. The output sequence should look like this | | | | | | | |.\n            // Because the sequence is halved, to map the output index back to\n            // the previous sequence to find the corresponding value, we need\n            // to double the index. When we double the index, we basically\n            // interpolate a position, so 2i looks like\n            // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k\n            // position of each 2k positions by - elemIdx % k. E.g. for output\n            // at index 4,5,6,7, we want to get the corresponding element at\n            // original index 8,9,10,11, for output at index 8,9,10,11,\n            // we want to get the corresponding element at original index\n            // 16,17,18,19, so on and so forth.\n\n            var i = 0;\n            if (elemIdx < uniforms.k) {\n              i = elemIdx;\n            } else {\n              i = elemIdx * 2 - elemIdx % uniforms.k;\n            }\n            var i0 = 0;\n            if (uniforms.firstPass == 1) {\n              i0 = i;\n            } else {\n              i0 = i32(getIndices(batch, i));\n            }\n            var i1 = 0;\n            if (uniforms.firstPass == 1) {\n              i1 = i + uniforms.k;\n            } else {\n              i1 = i32(getIndices(batch, i + uniforms.k));\n            }\n\n            let x0 = getX(batch, i0);\n            var x1 = f32(0.0);\n            if (i1 < uniforms.inputSize) {\n              x1 = getX(batch, i1);\n            } else {\n              x1 = x0;\n            }\n\n            if (x0 >= x1) {\n              setOutputAtIndex(index, f32(i0));\n            } else {\n              setOutputAtIndex(index, f32(i1));\n            }\n          }\n        }\n      `}}function ps(e,t){null!==t&&e.disposeData(t.dataId)}function fs(e){let t=1;for(;t<e;)t*=2;return t}const ms={kernelName:t.TopK,backendName:"webgpu",kernelFunc:function(e){const{inputs:n,backend:r,attrs:i}=e,{x:s}=n,{k:a,sorted:o}=i,u=s.shape,l=u[u.length-1];if(r.shouldExecuteOnCPU([s])){const e=r.readSync(s.dataId),[t,n]=Pt(e,u,s.dtype,a,o);return[r.makeTensorInfo(t.shape,t.dtype,t.values),r.makeTensorInfo(n.shape,n.dtype,n.values)]}if(0===a)return u[u.length-1]=0,[r.makeTensorInfo(u,s.dtype,[]),r.makeTensorInfo(u,"int32",[])];if(1===l)return[s,ie({attrs:{shape:u,dtype:"int32",value:0},backend:r})];const d=t.util.sizeFromShape(u)/l,h=ae({inputs:{x:s},attrs:{shape:[d,l]},backend:r}),c=fs(a),p=fs(l);let f=null;const m=()=>null===f?[h,h]:[h,f],g=(e,t,n)=>{const i=m(),s=new hs(n),a=[{type:"int32",data:[l]},{type:"int32",data:[null===f?1:0]},{type:"float32",data:[Number.NEGATIVE_INFINITY]},{type:"int32",data:[e]},{type:"int32",data:[t]}],o=f;f=r.runWebGPUProgram(s,i,"int32",a),ps(r,o)};for(let e=1;e<c;e*=2){const t=2*e;for(let n=e;n>=1;n/=2)g(t,n,[d,p])}for(let e=p;e>c;e/=2){const t=m(),n=new cs([d,e/2]),i=[{type:"int32",data:[l]},{type:"int32",data:[null===f?1:0]},{type:"int32",data:[c]}],s=f;f=r.runWebGPUProgram(n,t,"int32",i),ps(r,s);const a=c/2,o=2*a;for(let e=a;e>=1;e/=2)g(o,e,f.shape)}let b=f;f=un({inputs:{x:f},backend:r,attrs:{begin:0,size:[d,a]}}),ps(r,b);let x=_r({inputs:{x:h,indices:f},backend:r,attrs:{axis:1,batchDims:1}});ps(r,h);const w=u.slice(0,-1);w.push(a),b=f,f=ae({inputs:{x:f},attrs:{shape:w},backend:r}),ps(r,b);const I=x;return x=ae({inputs:{x:x},attrs:{shape:w},backend:r}),ps(r,I),[x,f]}};class gs{constructor(e){this.variableNames=["Image","Transforms"],this.uniforms="interpolationModeId : i32, fillModeId : i32, fillValue : f32,",this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=R(this.outputShape),this.dispatch=S(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="transform"}getUserCode(){return`\n          fn mapCoord(outCoord : f32, len : f32) -> f32{\n            var inCoord = outCoord;\n            if(uniforms.fillModeId == 2) {\n              if (inCoord < 0.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz2 = 2.0 * len;\n                  if (inCoord < sz2) {\n                    inCoord = sz2 * f32(i32(f32(-inCoord / sz2))) +\n                    inCoord;\n                  }\n                  if (inCoord < -len) {\n                    inCoord = inCoord + sz2;\n                  } else {\n                    inCoord = -inCoord - 1.0;\n                  }\n                }\n              } else if (inCoord > len - 1.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz2 = 2.0 * len;\n                  inCoord = inCoord - sz2 * f32(i32(f32(inCoord / sz2)));\n                  if (inCoord >= len) {\n                    inCoord = sz2 - inCoord - 1.0;\n                  }\n                }\n              }\n              return clamp(inCoord, 0.0, len - 1.0);\n            } else if (uniforms.fillModeId == 3) {\n              if (inCoord < 0.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz = len - 1.0;\n                  inCoord = inCoord + len * (f32(i32(f32(-inCoord / sz))) + 1.0);\n                }\n              } else if (inCoord > len - 1.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz = len - 1.0;\n                  inCoord = inCoord - len * f32(i32(f32(inCoord / sz)));\n                }\n              }\n              return clamp(inCoord, 0.0, len - 1.0);\n            } else if (uniforms.fillModeId == 4) {\n              return clamp(outCoord, 0.0, len - 1.0);\n            }\n            return outCoord;\n          }\n          fn readWithFillValue(batch : i32, coordY : i32, coordX : i32,\n            channel : i32) -> f32 {\n            var outputValue : f32;\n            if (0 <= coordY && coordY < uniforms.imageShape[1] && 0 <= coordX && coordX < uniforms.imageShape[2]) {\n                outputValue = getImage(batch, coordY, coordX, channel);\n            } else {\n              outputValue = uniforms.fillValue;\n            }\n            return outputValue;\n          }\n\n          ${m("index")} {\n            if (index < uniforms.size) {\n              let coords = getCoordsFromIndex(index);\n              var outputValue : f32;\n              let batch = coords[0];\n              let x = coords[2];\n              let y = coords[1];\n              let channel = coords[3];\n              let xf = f32(x);\n              let yf = f32(y);\n              let a1 = getTransforms(batch, 0);\n              let a2 = getTransforms(batch, 1);\n              let a3 = getTransforms(batch, 2);\n              let b1 = getTransforms(batch, 3);\n              let b2 = getTransforms(batch, 4);\n              let b3 = getTransforms(batch, 5);\n              let c1 = getTransforms(batch, 6);\n              let c2 = getTransforms(batch, 7);\n              let projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = uniforms.fillValue;\n              } else {\n                let inX = (a1 * xf + a2 * yf + a3) / projection;\n                let inY = (b1 * xf + b2 * yf + b3) / projection;\n                let mapX = mapCoord(inX, f32(uniforms.imageShape[2]));\n                let mapY = mapCoord(inY, f32(uniforms.imageShape[1]));\n\n                if (uniforms.interpolationModeId == 1) {\n                  let coordY = i32(round(mapY));\n                  let coordX = i32(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  let yFloor = floor(mapY);\n                  let xFloor = floor(mapX);\n                  let yCeil = yFloor + 1.0;\n                  let xCeil = xFloor + 1.0;\n                  let valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, i32(yFloor), i32(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, i32(yFloor), i32(xCeil), channel);\n                  let valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, i32(yCeil), i32(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, i32(yCeil), i32(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutputAtIndex(index, outputValue);\n            }\n          }\n        `}}const bs=[le,Nt,Ft,Dt,Vt,Ht,Xt,rn,sn,dn,mn,bn,In,me,$n,zn,Nn,Fn,Dn,Ln,qn,Xn,jn,Jn,ir,ar,ur,dr,cr,fr,se,gr,yr,xr,Ir,$r,Rr,Tr,Pr,Er,Br,Or,pe,Sn,Gr,Lr,Mr,Vr,qr,Kr,Yr,Jt,Zr,Jr,tn,ei,ni,ii,tr,si,ai,oi,cn,di,hi,fi,gi,bi,xi,wi,fn,ki,Si,Ci,Ri,oe,Ai,zi,Ei,Bi,Oi,Gi,Ui,Wi,Hi,ln,os,us,Ki,ji,Ji,es,ns,rs,ss,Xi,rr,ds,Zi,ms,{kernelName:t.Transform,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:i,transforms:s}=t,{interpolation:a,fillMode:o,fillValue:u,outputShape:l}=r,[d,h,c,p]=i.shape,[f,m]=null!=l?l:[h,c],g=new gs([d,f,m,p]),b="nearest"===a?1:2;let x;switch(o){case"constant":default:x=1;break;case"reflect":x=2;break;case"wrap":x=3;break;case"nearest":x=4}const w=[{type:"int32",data:[b]},{type:"int32",data:[x]},{type:"float32",data:[u]}];return n.runWebGPUProgram(g,[i,s],"float32",w)}},Wt,{kernelName:t.Unpack,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{value:i}=t;let{axis:s}=r;s<0&&(s+=i.shape.length);const a=i,o=a.shape.length,u=i.shape[s],l=new Array(o-1);let d=0;for(let e=0;e<o;e++)e!==s&&(l[d++]=a.shape[e]);const h=[],c=new Array(o).fill(0),p=a.shape.slice();p[s]=1;const f=new Array(u);for(let e=0;e<f.length;e++){c[s]=e;const t=un({inputs:{x:a},backend:n,attrs:{begin:c,size:p}}),r=ae({inputs:{x:t},backend:n,attrs:{shape:l}});f[e]=r,h.push(t)}return h.forEach((e=>n.disposeData(e.dataId))),f}},li];for(const e of bs)t.registerKernel(e);e.WebGPUBackend=N,e.webgpu_util=_,Object.defineProperty(e,"__esModule",{value:!0})}));
//# sourceMappingURL=tf-backend-webgpu.es2017.min.js.map
